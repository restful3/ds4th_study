# Messages

Messages are the fundamental unit of context for models in LangChain. They represent the input and output of models, carrying both the content and metadata needed to represent the state of a conversation when interacting with an LLM.

Messages are objects that contain:

- **Role** - Identifies the message type (e.g. system, user)
- **Content** - Represents the actual content of the message (like text, images, audio, documents, etc.)
- **Metadata** - Optional fields such as response information, message IDs, and token usage

LangChain provides a standard message type that works across all model providers, ensuring consistent behavior regardless of the model being called.

## Basic usage

The simplest way to use messages is to create message objects and pass them to a model when invoking.

```python
from langchain.chat_models import init_chat_model
from langchain.messages import HumanMessage, AIMessage, SystemMessage

model = init_chat_model("gpt-5-nano")

system_msg = SystemMessage("You are a helpful assistant.")
human_msg = HumanMessage("Hello, how are you?")

# Use with chat models
messages = [system_msg, human_msg]
response = model.invoke(messages)  # Returns AIMessage
```

### Text prompts

Text prompts are strings - ideal for straightforward generation tasks where you don’t need to retain conversation history.

```python
response = model.invoke("Write a haiku about spring")
```

Use text prompts when:

- You have a single, standalone request
- You don’t need conversation history
- You want minimal code complexity

### Message prompts

Alternatively, you can pass in a list of messages to the model by providing a list of message objects.

```python
from langchain.messages import SystemMessage, HumanMessage, AIMessage

messages = [
    SystemMessage("You are a poetry expert"),
    HumanMessage("Write a haiku about spring"),
    AIMessage("Cherry blossoms bloom...")
]
response = model.invoke(messages)
```

Use message prompts when:

- Managing multi-turn conversations
- Working with multimodal content (images, audio, files)
- Including system instructions

### Dictionary format

You can also specify messages directly in OpenAI chat completions format.

```python
messages = [
    {"role": "system", "content": "You are a poetry expert"},
    {"role": "user", "content": "Write a haiku about spring"},
    {"role": "assistant", "content": "Cherry blossoms bloom..."}
]
response = model.invoke(messages)
```

## Message types

- [System message](#system-message) - Tells the model how to behave and provide context for interactions
- [Human message](#human-message) - Represents user input and interactions with the model
- [AI message](#ai-message) - Responses generated by the model, including text content, tool calls, and metadata
- [Tool message](#tool-message) - Represents the outputs of [tool calls](07-models.md#tool-calling)

### System message

A `SystemMessage` represent an initial set of instructions that primes the model’s behavior. You can use a system message to set the tone, define the model’s role, and establish guidelines for responses.

#### Basic instructions

```python
system_msg = SystemMessage("You are a helpful coding assistant.")

messages = [
    system_msg,
    HumanMessage("How do I create a REST API?")
]
response = model.invoke(messages)
```

#### Detailed persona

```python
from langchain.messages import SystemMessage, HumanMessage

system_msg = SystemMessage("""
You are a senior Python developer with expertise in web frameworks.
Always provide code examples and explain your reasoning.
Be concise but thorough in your explanations.
""")

messages = [
    system_msg,
    HumanMessage("How do I create a REST API?")
]
response = model.invoke(messages)
```

### Human message

A `HumanMessage` represents user input and interactions. They can contain text, images, audio, files, and any other amount of multimodal content.

#### Text content

Message object:

```python
response = model.invoke([
  HumanMessage("What is machine learning?")
])
```

String shortcut:

```python
response = model.invoke("What is machine learning?")
```

#### Message metadata

Add metadata:

```python
human_msg = HumanMessage(
    content="Hello!",
    name="alice",  # Optional: identify different users
    id="msg_123",  # Optional: unique identifier for tracing
)
```

> The `name` field behavior varies by provider – some use it for user identification, others ignore it. To check, refer to the model provider’s reference.

### AI message

An `AIMessage` represents the output of a model invocation. They can include multimodal data, tool calls, and provider-specific metadata that you can later access.

```python
response = model.invoke("Explain AI")
print(type(response))  # <class 'langchain.messages.AIMessage'>
```

`AIMessage` objects are returned by the model when calling it, which contains all of the associated metadata in the response.

Providers weigh/contextualize types of messages differently, which means it is sometimes helpful to manually create a new AIMessage object and insert it into the message history as if it came from the model.

```python
from langchain.messages import AIMessage, SystemMessage, HumanMessage

# Create an AI message manually (e.g., for conversation history)
ai_msg = AIMessage("I'd be happy to help you with that question!")

# Add to conversation history
messages = [
    SystemMessage("You are a helpful assistant"),
    HumanMessage("Can you help me?"),
    ai_msg,  # Insert as if it came from the model
    HumanMessage("Great! What's 2+2?")
]

response = model.invoke(messages)
```

<details>
<summary>Attributes</summary>

-   `text` `string`

    The text content of the message.

-   `content` `string | dict[]`

    The raw content of the message.

-   `content_blocks` `ContentBlock[]`

    The standardized [content blocks](#standard-content-blocks) of the message.

-   `tool_calls` `dict[] | None`

    The tool calls made by the model.

    Empty if no tools are called.

-   `id` `string`

    A unique identifier for the message (either automatically generated by LangChain or returned in the provider response)

-   `usage_metadata` `dict | None`

    The usage metadata of the message, which can contain token counts when available.

-   `response_metadata` `ResponseMetadata | None`

    The response metadata of the message.

</details>

#### Tool calls

When models make tool calls, they’re included in the `AIMessage`:

```python
from langchain.chat_models import init_chat_model

model = init_chat_model("gpt-5-nano")

def get_weather(location: str) -> str:
    """Get the weather at a location."""
    ...

model_with_tools = model.bind_tools([get_weather])
response = model_with_tools.invoke("What's the weather in Paris?")

for tool_call in response.tool_calls:
    print(f"Tool: {tool_call['name']}")
    print(f"Args: {tool_call['args']}")
    print(f"ID: {tool_call['id']}")
```

Other structured data, such as reasoning or citations, can also appear in message content.

#### Token usage

An `AIMessage` can hold token counts and other usage metadata in its `usage_metadata` field:

```python
from langchain.chat_models import init_chat_model

model = init_chat_model("gpt-5-nano")

response = model.invoke("Hello!")
response.usage_metadata
```

```python
{'input_tokens': 8,
 'output_tokens': 304,
 'total_tokens': 312,
 'input_token_details': {'audio': 0, 'cache_read': 0},
 'output_token_details': {'audio': 0, 'reasoning': 256}}
```

See [UsageMetadata](https://reference.langchain.com/python/langchain/messages/#langchain.messages.UsageMetadata) for details.

#### Streaming and chunks

During streaming, you’ll receive `AIMessageChunk` objects that can be combined into a full message object:

```python
chunks = []
full_message = None
for chunk in model.stream("Hi"):
    chunks.append(chunk)
    print(chunk.text)
    full_message = chunk if full_message is None else full_message + chunk
```

Learn more:
- [Streaming tokens from chat models](07-models.md#stream)
- [Streaming tokens and/or steps from agents](streaming.md)

### Tool message

For models that support tool calling, AI messages can contain tool calls. Tool messages are used to pass the results of a single tool execution back to the model.

Tools can generate `ToolMessage` objects directly. Below, we show a simple example. Read more in the [tools guide](tools.md).

```python
from langchain.messages import AIMessage
from langchain.messages import ToolMessage

# After a model makes a tool call
# (Here, we demonstrate manually creating the messages for brevity)
ai_message = AIMessage(
    content=[],
    tool_calls=[{
        "name": "get_weather",
        "args": {"location": "San Francisco"},
        "id": "call_123"
    }]
)

# Execute tool and create result message
weather_result = "Sunny, 72°F"
tool_message = ToolMessage(
    content=weather_result,
    tool_call_id="call_123"  # Must match the call ID
)

# Continue conversation
messages = [
    HumanMessage("What's the weather in San Francisco?"),
    ai_message,  # Model's tool call
    tool_message,  # Tool execution result
]
response = model.invoke(messages)  # Model processes the result
```

<details>
<summary>Attributes</summary>

-   `content` `string` `required`

    The stringified output of the tool call.

-   `tool_call_id` `string` `required`

    The ID of the tool call that this message is responding to.

    Must match the ID of the tool call in the `AIMessage`.

-   `name` `string` `required`

    The name of the tool that was called.

-   `artifact` `dict`

    Supplementary data not sent to the model but accessible programmatically (e.g., raw results, debugging info).

</details>


> The artifact field stores supplementary data that won’t be sent to the model but can be accessed programmatically. This is useful for storing raw results, debugging information, or data for downstream processing without cluttering the model’s context.

<details>
<summary>Example: Using artifact for retrieval metadata</summary>

For example, a retrieval tool could retrieve a passage from a document for reference by a model. Where message content contains text that the model will reference, an artifact can contain document identifiers or other metadata that an application can use (e.g., to render a page). See example below:


```python
from langchain.messages import ToolMessage

# Sent to model
message_content = "It was the best of times, it was the worst of times."

# Artifact available downstream
artifact = {"document_id": "doc_123", "page": 0}

tool_message = ToolMessage(
    content=message_content,
    tool_call_id="call_123",
    name="search_books",
    artifact=artifact,
)
```
See the RAG tutorial for an end-to-end example of building retrieval agents with LangChain.

</details>

## Message content

You can think of a message’s content as the payoff of data that gets sent to the model. Messages have a `content` attribute that is loosely-typed, supporting strings and lists of untyped objects (e.g., dictionaries). This allows support for provider-native structures directly in LangChain chat models, such as multimodal content and other data.

Separately, LangChain provides dedicated content types for text, reasoning, citations, multi-modal data, server-side tool calls, and other message content. See [content blocks](#standard-content-blocks) below.

LangChain chat models accept message content in the `content` attribute.

This may contain either:

1.  A string
2.  A list of content blocks in a provider-native format
3.  A list of LangChain’s standard content blocks

See below for an example using multimodal inputs:

```python
from langchain.messages import HumanMessage

# String content
human_message = HumanMessage("Hello, how are you?")

# Provider-native format (e.g., OpenAI)
human_message = HumanMessage(content=[
    {"type": "text", "text": "Hello, how are you?"},
    {"type": "image_url", "image_url": {"url": "https://example.com/image.jpg"}}
])

# List of standard content blocks
human_message = HumanMessage(content_blocks=[
    {"type": "text", "text": "Hello, how are you?"},
    {"type": "image", "url": "https://example.com/image.jpg"},
])
```

> Specifying `content_blocks` when initializing a message will still populate message content, but provides a type-safe interface for doing so.

### Standard content blocks

LangChain provides a standard representation for message content that works across providers.

Message objects implement a `content_blocks` property that will lazily parse the `content` attribute into a standard, type-safe representation. For example, messages generated from ChatAnthropic or ChatOpenAI will include thinking or reasoning blocks in the format of the respective provider, but can be lazily parsed into a consistent `ReasoningContentBlock` representation:

**Anthropic**

```python
from langchain.messages import AIMessage

message = AIMessage(
    content=[
        {"type": "thinking", "thinking": "...", "signature": "WaUjzkyp..."},
        {"type": "text", "text": "..."},
    ],
    response_metadata={"model_provider": "anthropic"}
)
message.content_blocks
```

```python
[{'type': 'reasoning',
  'reasoning': '...',
  'extras': {'signature': 'WaUjzkyp...'}},
 {'type': 'text', 'text': '...'}]
```

**OpenAI**

```python
from langchain.messages import AIMessage

message = AIMessage(
    content=[
        {
            "type": "reasoning",
            "id": "rs_abc123",
            "summary": [
                {"type": "summary_text", "text": "summary 1"},
                {"type": "summary_text", "text": "summary 2"},
            ],
        },
        {"type": "text", "text": "...", "id": "msg_abc123"},
    ],
    response_metadata={"model_provider": "openai"}
)
message.content_blocks
```
```
[{'type': 'reasoning', 'id': 'rs_abc123', 'reasoning': 'summary 1'},
 {'type': 'reasoning', 'id': 'rs_abc123', 'reasoning': 'summary 2'},
 {'type': 'text', 'text': '...', 'id': 'msg_abc123'}]
```

See the [integrations guides](https://docs.langchain.com/oss/python/integrations/providers/overview) to get started with the inference provider of your choice.

#### Serializing standard content

If an application outside of LangChain needs access to the standard content block representation, you can opt-in to storing content blocks in message content.

To do this, you can set the `LC_OUTPUT_VERSION` environment variable to `v1`. Or, initialize any chat model with `output_version="v1"`:

```python
from langchain.chat_models import init_chat_model

model = init_chat_model("gpt-5-nano", output_version="v1")
```

### Multimodal

Multimodality refers to the ability to work with data that comes in different forms, such as text, audio, images, and video. LangChain includes standard types for these data that can be used across providers.

Chat models can accept multimodal data as input and generate it as output. Below we show short examples of input messages featuring multimodal data.

> Extra keys can be included top-level in the content block or nested in `"extras": {"key": value}`.
>
> OpenAI and AWS Bedrock Converse, for example, require a filename for PDFs. See the provider page for your chosen model for specifics.

#### Image input

```python
# From URL
message = {
    "role": "user",
    "content": [
        {"type": "text", "text": "Describe the content of this image."},
        {"type": "image", "url": "https://example.com/path/to/image.jpg"},
    ]
}

# From base64 data
message = {
    "role": "user",
    "content": [
        {"type": "text", "text": "Describe the content of this image."},
        {
            "type": "image",
            "base64": "AAAAIGZ0eXBtcDQyAAAAAGlzb21tcDQyAAACAGlzb2...",
            "mime_type": "image/jpeg",
        },
    ]
}

# From provider-managed File ID
message = {
    "role": "user",
    "content": [
        {"type": "text", "text": "Describe the content of this image."},
        {"type": "image", "file_id": "file-abc123"},
    ]
}
```

#### PDF document input

```python
# From URL
message = {
    "role": "user",
    "content": [
        {"type": "text", "text": "Describe the content of this document."},
        {"type": "file", "url": "https://example.com/path/to/document.pdf"},
    ]
}

# From base64 data
message = {
    "role": "user",
    "content": [
        {"type": "text", "text": "Describe the content of this document."},
        {
            "type": "file",
            "base64": "AAAAIGZ0eXBtcDQyAAAAAGlzb21tcDQyAAACAGlzb2...",
            "mime_type": "application/pdf",
        },
    ]
}

# From provider-managed File ID
message = {
    "role": "user",
    "content": [
        {"type": "text", "text": "Describe the content of this document."},
        {"type": "file", "file_id": "file-abc123"},
    ]
}
```

#### Audio input

```python
# From base64 data
message = {
    "role": "user",
    "content": [
        {"type": "text", "text": "Describe the content of this audio."},
        {
            "type": "audio",
            "base64": "AAAAIGZ0eXBtcDQyAAAAAGlzb21tcDQyAAACAGlzb2...",
            "mime_type": "audio/wav",
        },
    ]
}

# From provider-managed File ID
message = {
    "role": "user",
    "content": [
        {"type": "text", "text": "Describe the content of this audio."},
        {"type": "audio", "file_id": "file-abc123"},
    ]
}
```

#### Video input

```python
# From base64 data
message = {
    "role": "user",
    "content": [
        {"type": "text", "text": "Describe the content of this video."},
        {
            "type": "video",
            "base64": "AAAAIGZ0eXBtcDQyAAAAAGlzb21tcDQyAAACAGlzb2...",
            "mime_type": "video/mp4",
        },
    ]
}

# From provider-managed File ID
message = {
    "role": "user",
    "content": [
        {"type": "text", "text": "Describe the content of this video."},
        {"type": "video", "file_id": "file-abc123"},
    ]
}
```

> Not all models support all file types. Check the model provider’s reference for supported formats and size limits.

### Content block reference

Content blocks are represented (either when creating a message or accessing the `content_blocks` property) as a list of typed dictionaries. Each item in the list must adhere to one of the following block types:

<details>
<summary>Core</summary>

<details>
<summary>TextContentBlock</summary>

-   `type` `"text"` `required`

-   `text` `string` `required`

    The text content.

-   `annotations` `dict[] | None`

    Annotations for the text.

-   `extras` `dict | None`

    Annotations for the text.

Example:
```
{
    "type": "text",
    "text": "Hello world",
    "annotations": []
}
```

</details>

<details>
<summary>ReasoningContentBlock</summary>

-   `type` `"reasoning"` `required`

-   `reasoning` `string | None`

    The reasoning content.

-   `content_id` `string | None`

-   `extras` `dict | None`

Example:
```
{
    "type": "reasoning",
    "reasoning": "The user is asking about...",
    "extras": {"signature": "abc123"},
}
```

</details>

</details>

<details>
<summary>Multimodal</summary>

<details>
<summary>ImageContentBlock</summary>

-   `type` `"image"` `required`

-   `url` `string | None`

    The URL of the image.

-   `base64` `string | None`

    The base64 encoded image data.

-   `id` `string | None`

    The provider-generated ID for the image.

-   `mime_type` `string | None`

    The MIME type of the image.

Example:
```python
# From URL
message = {
    "role": "user",
    "content": [
        {"type": "text", "text": "Describe the content of this image."},
        {"type": "image", "url": "https://example.com/path/to/image.jpg"},
    ]
}

# From base64 data
message = {
    "role": "user",
    "content": [
        {"type": "text", "text": "Describe the content of this image."},
        {
            "type": "image",
            "base64": "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==",
            "mime_type": "image/png",
        },
    ]
}
```

</details>

<details>
<summary>AudioContentBlock</summary>

-   `type` `"audio"` `required`

-   `url` `string | None`

    The URL of the audio.

-   `base64` `string | None`

    The base64 encoded audio data.

-   `id` `string | None`

    The provider-generated ID for the audio.

-   `mime_type` `string | None`

    The MIME type of the audio.

Example:
```python
# From URL
message = {
    "role": "user",
    "content": [
        {"type": "text", "text": "Describe the content of this audio."},
        {"type": "audio", "url": "https://example.com/path/to/audio.mp3"},
    ]
}

# From base64 data
message = {
    "role": "user",
    "content": [
        {"type": "text", "text": "Describe the content of this audio."},
        {
            "type": "audio",
            "base64": "AAAAIGZ0eXBtcDQyAAAAAGlzb21tcDQyAAACAGlzb2...",
            "mime_type": "audio/wav",
        },
    ]
}
```

</details>

<details>
<summary>VideoContentBlock</summary>

-   `type` `"video"` `required`

-   `url` `string | None`

    The URL of the video.

-   `base64` `string | None`

    The base64 encoded video data.

-   `id` `string | None`

    The provider-generated ID for the video.

-   `mime_type` `string | None`

    The MIME type of the video.

Example:
```python
# From base64 data
message = {
    "role": "user",
    "content": [
        {"type": "text", "text": "Describe the content of this video."},
        {
            "type": "video",
            "base64": "AAAAIGZ0eXBtcDQyAAAAAGlzb21tcDQyAAACAGlzb2...",
            "mime_type": "video/mp4",
        },
    ]
}

# From provider-managed File ID
message = {
    "role": "user",
    "content": [
        {"type": "text", "text": "Describe the content of this video."},
        {"type": "video", "file_id": "file-abc123"},
    ]
}
```

</details>

<details>
<summary>FileContentBlock</summary>

-   `type` `"file"` `required`

-   `url` `string | None`

    The URL of the file.

-   `base64` `string | None`

    The base64 encoded file data.

-   `id` `string | None`

    The provider-generated ID for the file.

-   `mime_type` `string | None`

    The MIME type of the file.

Example:
```python
# From URL
message = {
    "role": "user",
    "content": [
        {"type": "text", "text": "Describe the content of this document."},
        {"type": "file", "url": "https://example.com/path/to/document.pdf"},
    ]
}

# From base64 data
message = {
    "role": "user",
    "content": [
        {"type": "text", "text": "Describe the content of this document."},
        {
            "type": "file",
            "base64": "AAAAIGZ0eXBtcDQyAAAAAGlzb21tcDQyAAACAGlzb2...",
            "mime_type": "application/pdf",
        },
    ]
}
```

</details>

<details>
<summary>PlainTextContentBlock</summary>

-   `type` `"text-plain"` `required`

-   `text` `string` `required`

    The plain text content.

-   `mime_type` `string | None`

    The MIME type of the text content.

Example:
```json
{
    "type": "text",
    "text": "Hello world",
    "annotations": []
}
```

</details>

</details>

<details>
<summary>Tool Calling</summary>

<details>
<summary>ToolCall</summary>

-   `type` `"tool_call"` `required`

-   `name` `string` `required`

    The name of the tool to be called.

-   `args` `dict` `required`

    The arguments to the tool call.

-   `id` `string` `required`

    The ID of the tool call.

Example:
```json
{
    "type": "tool_call",
    "name": "search",
    "args": {"query": "weather"},
    "id": "call_123"
}
```

</details>

<details>
<summary>ToolCallChunk</summary>

-   `type` `"tool_call_chunk"` `required`

-   `name` `string | None`

    The name of the tool to be called.

-   `args` `string | None`

    The arguments to the tool call.

-   `id` `string | None`

    The ID of the tool call.

-   `index` `integer | None`

    The index of the tool call in the sequence.

</details>

<details>
<summary>InvalidToolCall</summary>

-   `type` `"invalid_tool_call"` `required`

    A tool call that failed to parse.

-   `name` `string | None`

    The name of the tool to be called.

-   `args` `string | None`

    The arguments to the tool call.

-   `error` `string | None`

    The error message associated with the failure.

</details>

</details>

<details>
<summary>Server-Side Tool Execution</summary>

<details>
<summary>ServerToolCall</summary>

-   `type` `"server_tool_call"` `required`

-   `id` `string` `required`

    The ID of the tool call.

-   `name` `string` `required`

    The name of the tool that was called.

-   `args` `dict` `required`

    The arguments to the tool call.

</details>

<details>
<summary>ServerToolCallChunk</summary>

-   `type` `"server_tool_call_chunk"` `required`

-   `id` `string | None`

    The ID of the tool call.

-   `name` `string | None`

    The name of the tool that was called.

-   `args` `string | None`

    The arguments to the tool call.

-   `index` `integer | None`

    The index of the tool call in the sequence.

</details>

<details>
<summary>ServerToolResult</summary>

-   `type` `"server_tool_result"` `required`

-   `tool_call_id` `string` `required`

    The ID of the tool call that this result is for.

-   `id` `string | None`

    A unique identifier for the result.

-   `status` `"success" | "error"` `required`

    The status of the tool execution.

-   `output` `string | None`

    The output of the tool execution.

</details>

</details>

<details>
<summary>Provider-Specific Blocks</summary>

<details>
<summary>NonStandardContentBlock</summary>

-   `type` `"non_standard"` `required`

-   `value` `any` `required`

    The raw content of the block.

</details>

</details>

View the canonical type definitions in the [API reference](https://reference.langchain.com/python/langchain/messages).

Content blocks were introduced as a new property on messages in LangChain v1 to standardize content formats across providers while maintaining backward compatibility with existing code.

Content blocks are not a replacement for the `content` property, but rather a new property that can be used to access the content of a message in a standardized format.

## Use with chat models

Chat models accept a sequence of message objects as input and return an `AIMessage` as output. Interactions are often stateless, so that a simple conversational loop involves invoking a model with a growing list of messages.

Refer to the below guides to learn more:

- Built-in features for [persisting and managing conversation histories](short-term-memory.md)
- Strategies for [managing context windows](short-term-memory.md#managing-context-window), including trimming and summarizing messages
