# 딥 에이전트(Deep Agents)

> 계획을 수립하고, 서브에이전트를 사용하며, 복잡한 작업을 위해 파일 시스템을 활용할 수 있는 에이전트 구축

![Deep Agents 아키텍처 개요](./images/summary.png)

---

## 목차

### 시작하기
| 문서 | 설명 |
|------|------|
| [개요](01-overview_ko.md) | Deep Agents의 핵심 개념과 사용 사례, LangChain 생태계와의 관계 |
| [빠른 시작](02-quickstart_ko.md) | 첫 번째 Deep Agent를 몇 분 만에 만들어보는 튜토리얼 |

### 핵심 기능
| 문서 | 설명 |
|------|------|
| [커스터마이징](03-customization_ko.md) | 모델, 시스템 프롬프트, 도구 등 에이전트 커스터마이징 옵션 |
| [에이전트 하네스](04-harness_ko.md) | 파일 시스템, 대용량 결과 제거, 할 일 목록 등 내장 기능 |
| [백엔드](05-backends_ko.md) | StateBackend, FilesystemBackend, StoreBackend 등 스토리지 전략 |

### 고급 기능
| 문서 | 설명 |
|------|------|
| [서브에이전트](06-subagents_ko.md) | 컨텍스트 격리와 작업 위임을 위한 서브에이전트 활용법 |
| [Human-in-the-loop](07-human-in-the-loop_ko.md) | 민감한 도구 작업에 대한 사람 승인 워크플로우 |
| [장기 메모리](08-long-term-memory_ko.md) | 스레드 간 영구 메모리로 에이전트 확장하기 |

### 아키텍처 & 도구
| 문서 | 설명 |
|------|------|
| [미들웨어](09-middleware_ko.md) | TodoList, Filesystem, SubAgent 미들웨어 아키텍처 |
| [CLI](10-cli_ko.md) | 대화형 명령줄 인터페이스로 에이전트 빌드 및 테스트 |

---

## 요약

**딥 에이전트(Deep Agents)** 는 **LangGraph** 를 기반으로 구축된 독립형 라이브러리로, 복잡하고 여러 단계에 걸친 작업을 처리할 수 있는 고급 에이전트를 구축하기 위해 설계되었습니다. 이 라이브러리의 핵심은 **계획 수립**, **서브에이전트 활용**, **파일 시스템을 통한 컨텍스트 관리** 능력을 통합하여 기존 에이전트 프레임워크의 한계를 넘어서는 것입니다.

딥 에이전트의 핵심 역량은 네 가지 주요 기능에 기반합니다.

1. **계획 및 작업 분해**: 내장된 `write_todos` 도구를 사용하여 복잡한 목표를 실행 가능한 하위 단계로 나누고, 진행 상황을 추적하며, 새로운 정보에 따라 계획을 동적으로 수정합니다.
2. **고급 컨텍스트 관리**: 가상 파일 시스템을 통해 대규모 컨텍스트를 효율적으로 관리합니다. 이는 플러그형 백엔드(임시 메모리, 로컬 디스크, 영구 저장소)를 지원하며, 대용량 도구 결과를 자동으로 파일에 저장하여 컨텍스트 창 포화를 방지합니다.
3. **서브에이전트를 통한 위임**: 전문화된 서브에이전트를 생성하여 특정 작업을 위임합니다. 이는 **컨텍스트 격리(Context Quarantine)** 를 통해 메인 에이전트의 컨텍스트를 깔끔하게 유지하고, 병렬 실행 및 토큰 효율성을 극대화합니다.
4. **영구적인 장기 기억**: 단일 대화 스레드를 넘어 정보를 유지하는 장기 기억을 구현합니다. `StoreBackend`를 사용하여 특정 경로(`/memories/`)의 파일을 영구적으로 저장함으로써, 에이전트가 여러 세션에 걸쳐 학습하고 지식을 축적할 수 있도록 합니다.

이러한 기능들은 **에이전트 하네스(Agent Harness)** 라는 개념으로 통합됩니다. 이는 단순한 도구 호출 루프를 넘어, 대화 기록 요약, 불완전한 도구 호출 복구, **인간 참여 루프(Human-in-the-loop)** 와 같은 견고하고 내재된 기능들을 제공하는 핵심 실행 환경을 의미합니다. 딥 에이전트는 LangChain 생태계(LangChain, LangGraph, LangSmith)와 긴밀하게 통합되어 원활한 도구 연동, 실행, 관찰 및 배포를 지원하며, 개발 및 테스트를 위한 강력한 대화형 CLI도 함께 제공됩니다.

---

## 1. 딥 에이전트(Deep Agents) 개요

### 1.1. 핵심 정의

**딥 에이전트** 는 계획 수립, 서브에이전트 생성, 파일 시스템 활용을 통해 복잡한 다단계 작업을 처리하도록 설계된 독립형 에이전트 구축 라이브러리입니다. **Claude Code**, **Deep Research**, **Manus** 와 같은 애플리케이션에서 영감을 받아 LangGraph 위에 구축되었습니다.

### 1.2. 주요 사용 사례

딥 에이전트는 다음과 같은 요구사항이 있을 때 가장 효과적입니다.

* **복잡한 다단계 작업**: 계획 수립과 작업 분해가 필요한 경우
* **대규모 컨텍스트 관리**: 파일 시스템 도구를 통해 컨텍스트 창 오버플로우를 방지해야 하는 경우
* **작업 위임**: 컨텍스트 격리를 위해 전문화된 서브에이전트에 작업을 위임해야 할 때
* **영구적인 기억**: 대화와 스레드를 넘어 정보를 지속적으로 유지해야 할 경우

단순한 사용 사례의 경우, LangChain의 기본 에이전트나 사용자 정의 LangGraph 워크플로우를 사용하는 것이 더 적합할 수 있습니다.

### 1.3. 핵심 역량

* **계획 및 작업 분해**: 내장된 `write_todos` 도구를 통해 복잡한 작업을 개별 단계로 나누고 진행 상황을 추적합니다.
* **컨텍스트 관리**: `ls`, `read_file`, `write_file`, `edit_file`과 같은 파일 시스템 도구를 사용하여 컨텍스트를 오프로드합니다.
* **서브에이전트 생성**: 내장된 `task` 도구를 통해 전문화된 서브에이전트를 생성하여 컨텍스트를 격리하고 하위 작업을 처리합니다.
* **장기 기억**: LangGraph의 Store를 활용하여 스레드를 넘어 지속되는 영구 메모리를 구현합니다.

### 1.4. LangChain 생태계와의 관계

딥 에이전트는 LangChain 생태계의 핵심 구성 요소 위에 구축됩니다.

* **LangGraph**: 기본 그래프 실행 및 상태 관리를 제공합니다.
* **LangChain**: 도구 및 모델 통합이 원활하게 작동합니다.
* **LangSmith**: 관찰 가능성, 평가 및 배포를 지원합니다. 딥 에이전트 애플리케이션은 LangSmith Deployment를 통해 배포하고 모니터링할 수 있습니다.

---

## 2. 핵심 아키텍처: 에이전트 하네스(Agent Harness)

딥 에이전트는 **에이전트 하네스** 로 간주될 수 있습니다. 이는 다른 에이전트 프레임워크와 동일한 핵심 도구 호출 루프를 가지면서, 강력한 내장 도구와 기능을 추가로 제공하는 구조를 의미합니다.

### 2.1. 파일 시스템 접근 및 컨텍스트 관리

파일을 에이전트 환경의 핵심 요소로 취급하며, 다음과 같은 도구와 기능을 제공합니다.

| 도구 | 설명 |
|------|------|
| `ls` | 디렉토리 내 파일 목록을 메타데이터(크기, 수정 시간)와 함께 표시합니다. |
| `read_file` | 파일 내용을 줄 번호와 함께 읽으며, 대용량 파일을 위한 오프셋/제한을 지원합니다. |
| `write_file` | 새로운 파일을 생성합니다. |
| `edit_file` | 파일 내에서 정확한 문자열 교체를 수행합니다 (전체 교체 모드 지원). |
| `glob` | 패턴과 일치하는 파일을 찾습니다 (예: `**/*.py`). |
| `grep` | 파일 내용을 검색하며, 다양한 출력 모드를 지원합니다. |

* **대용량 도구 결과 자동 축출(Large Tool Result Eviction)**: 도구 결과가 설정된 토큰 임계값(기본 20,000)을 초과하면, `FilesystemMiddleware`가 자동으로 해당 결과를 파일 시스템에 저장합니다. 이후 도구 결과는 잘린 미리보기와 파일 참조로 대체되어 컨텍스트 창 포화를 방지합니다.
* **대화 기록 요약(Conversation History Summarization)**: 토큰 사용량이 모델의 최대 입력 값의 85%에 도달하면 오래된 대화 기록을 자동으로 압축합니다. 이는 최근 컨텍스트는 보존하면서 오래된 기록을 요약하여 매우 긴 대화가 가능하게 합니다.

### 2.2. 작업 위임: 서브에이전트

메인 에이전트는 임시 **서브에이전트** 를 생성하여 격리된 다단계 작업을 위임할 수 있습니다.

* **목적**: 서브에이전트의 작업이 메인 에이전트의 컨텍스트를 어지럽히는 것을 방지하고(**컨텍스트 격리**), 여러 서브에이전트를 동시에 실행하며(**병렬 실행**), 특정 작업에 최적화된 도구와 설정을 사용하고(**전문화**), 대규모 하위 작업의 컨텍스트를 단일 결과로 압축하여(**토큰 효율성**) 이점을 얻습니다.
* **작동 방식**: 메인 에이전트가 `task` 도구를 호출하면, 자체 컨텍스트를 가진 새로운 에이전트 인스턴스가 생성됩니다. 이 서브에이전트는 자율적으로 작업을 수행한 후 최종 보고서를 메인 에이전트에게 반환합니다.

### 2.3. 견고성 및 제어

* **불완전한 도구 호출 복구(Dangling Tool Call Repair)**: 사용자의 취소나 오류로 인해 도구 호출이 중단되었을 때, 에이전트가 혼란에 빠지지 않도록 호출이 취소되었음을 나타내는 합성 `ToolMessage`를 생성하여 메시지 기록을 자동으로 복구합니다.
* **To-Do 리스트 추적(To-do List Tracking)**: `write_todos` 도구를 통해 에이전트가 구조화된 작업 목록을 유지하고 복잡한 작업을 체계적으로 관리할 수 있도록 돕습니다.
* **인간 참여 루프(Human-in-the-loop)**: `interrupt_on` 매개변수를 통해 특정 도구 호출 전에 실행을 일시 중지하고 인간의 승인, 수정 또는 거부를 받을 수 있습니다. 이는 파괴적인 작업에 대한 안전장치 역할을 합니다.

### 2.4. 최적화

* **프롬프트 캐싱(Anthropic)**: Anthropic 모델을 사용할 때, 여러 차례에 걸쳐 반복되는 프롬프트 부분(예: 긴 시스템 프롬프트)을 캐싱하여 지연 시간과 비용을 크게 줄입니다.

---

## 3. 모듈식 구성 요소 심층 분석

딥 에이전트의 기능은 독립적으로 사용하거나 조합할 수 있는 **모듈식 미들웨어** 로 구현됩니다.

### 3.1. 플러그형 스토리지 백엔드

파일 시스템 도구는 다양한 스토리지 전략을 지원하는 플러그형 백엔드를 통해 작동합니다.

* **StateBackend(임시)**: 현재 스레드의 LangGraph 에이전트 상태에 파일을 저장합니다. 스레드가 끝나면 사라지므로 임시 작업 공간에 적합합니다.
* **FilesystemBackend(로컬 디스크)**: 로컬 기계의 실제 파일 시스템에 읽고 씁니다. 특정 루트 디렉토리로 접근을 제한하는 샌드박스 모드를 지원합니다.
* **StoreBackend(영구 저장소)**: LangGraph `BaseStore`(예: Redis, Postgres)를 사용하여 스레드를 넘어 지속되는 내구성 있는 저장소를 제공합니다.
* **CompositeBackend(라우터)**: 경로 접두사에 따라 파일 작업을 다른 백엔드로 라우팅합니다. 이를 통해 하이브리드 스토리지 전략을 구현할 수 있습니다.

### 3.2. 장기 기억

`CompositeBackend`를 사용하여 영구적인 **장기 기억** 을 구현할 수 있습니다.

* **구현 방법**: `/memories/`와 같은 특정 경로를 영구적인 `StoreBackend`로 라우팅하고, 나머지 경로는 임시 `StateBackend`를 사용하도록 설정합니다.
* **작동 원리**: 파일 경로에 `/memories/` 접두사가 있으면 Store에 저장되어 모든 스레드와 세션에서 접근 가능하며, 그렇지 않으면 현재 스레드에서만 유효한 임시 파일로 처리됩니다.
* **주요 활용 사례**: 사용자 선호도 저장, 피드백을 통한 자체 지침 개선, 여러 대화에 걸친 지식 베이스 구축, 장기 연구 프로젝트 상태 유지 등.

### 3.3. 서브에이전트

**서브에이전트** 는 **컨텍스트 팽창 문제(Context Bloat Problem)** 를 해결하는 핵심적인 기능입니다.

* **핵심 가치**: 웹 검색이나 파일 읽기와 같이 큰 출력을 내는 도구 사용 시 발생하는 중간 결과물들을 서브에이전트 내부에 격리시켜, 메인 에이전트는 최종 요약 결과만 받도록 합니다.
* **설정 방법**: 각 서브에이전트는 이름, 설명, 시스템 프롬프트, 도구 목록을 포함하는 딕셔너리(`SubAgent`)로 정의하거나, 사전 빌드된 LangGraph 그래프(`CompiledSubAgent`)로 제공할 수 있습니다.
* **범용 서브에이전트**: 사용자가 정의한 서브에이전트 외에도, 메인 에이전트와 동일한 지침 및 도구를 가진 **범용 서브에이전트** 가 항상 제공됩니다. 이는 전문화 없이 순수하게 컨텍스트 격리가 필요할 때 유용합니다.
* **모범 사례**: 메인 에이전트가 올바른 서브에이전트를 선택하고 효율적으로 사용하도록 명확한 설명과 상세한 시스템 프롬프트를 작성하고, 필요한 최소한의 도구만 제공하는 것이 중요합니다.

### 3.4. 미들웨어 아키텍처

딥 에이전트의 핵심 기능은 각각 별도의 **미들웨어** 로 구현됩니다. `create_deep_agent` 함수는 다음의 핵심 미들웨어를 자동으로 연결합니다.

* **TodoListMiddleware**: `write_todos` 도구를 제공하여 계획 수립을 지원합니다.
* **FilesystemMiddleware**: 파일 시스템 관련 도구(`ls`, `read_file` 등)를 제공하여 컨텍스트와 메모리를 관리합니다.
* **SubAgentMiddleware**: `task` 도구를 통해 서브에이전트를 생성하고 관리합니다.

---

## 4. 개발 및 테스트: CLI

**딥 에이전트 CLI** 는 에이전트를 대화형으로 구축하고 테스트하기 위한 터미널 인터페이스를 제공합니다.

### 4.1. 주요 기능

* **파일 작업**: 프로젝트 내 파일 읽기, 쓰기, 편집.
* **셸 명령어 실행**: 테스트 실행, 프로젝트 빌드, 종속성 관리.
* **웹 검색**: 최신 정보 및 문서 검색 (Tavily API 키 필요).
* **HTTP 요청**: API 및 외부 서비스와 데이터 통합.
* **작업 계획 및 추적**: 내장된 To-Do 시스템으로 진행 상황 추적.
* **메모리 저장 및 검색**: 세션 간 정보 저장 및 검색.
* **인간 참여 루프**: 민감한 도구 작업에 대한 인간의 승인 요구.

### 4.2. 메모리를 통한 프로젝트 관습 설정

CLI는 `~/.deepagents/AGENT_NAME/memories/` 경로에 프로젝트별 메모리를 저장합니다. 에이전트는 이 메모리를 세 가지 방식으로 활용합니다.

1. **연구**: 작업을 시작하기 전 관련 컨텍스트를 메모리에서 검색합니다.
2. **응답**: 실행 중 불확실할 때 메모리를 확인합니다.
3. **학습**: 향후 세션을 위해 새로운 정보를 자동으로 저장합니다.

예를 들어, "이 프로젝트의 모든 Python 코드는 black 포맷터를 사용해야 합니다"라고 에이전트에게 지시하면, 이 관습이 메모리에 저장되어 향후 모든 작업에 자동으로 적용됩니다.

### 4.3. 원격 샌드박스

**원격 샌드박스** (Runloop, Daytona, Modal 지원)는 코드 실행을 위한 격리된 환경을 제공하여 다음과 같은 이점을 가집니다.

* **안전성**: 로컬 시스템을 잠재적으로 유해한 코드 실행으로부터 보호합니다.
* **정리된 환경**: 로컬 설정 없이 특정 종속성이나 OS 구성을 사용합니다.
* **병렬 실행**: 격리된 환경에서 여러 에이전트를 동시에 실행합니다.
* **재현성**: 팀 전체에 걸쳐 일관된 실행 환경을 보장합니다.

`--sandbox` 플래그를 사용하여 CLI를 실행하면, 에이전트는 로컬에서 실행되지만 모든 코드 관련 작업은 원격 샌드박스 내에서 수행됩니다.
