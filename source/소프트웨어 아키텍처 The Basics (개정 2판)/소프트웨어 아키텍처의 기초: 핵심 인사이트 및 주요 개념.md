# 소프트웨어 아키텍처의 기초: 핵심 인사이트 및 주요 개념

## 요약

본 브리핑 문서는 마크 리처즈와 닐 포드의 저서 **"소프트웨어 아키텍처의 기초, 2판(Fundamentals of Software Architecture, Second Edition)"** 에서 발췌한 핵심 주제와 아이디어를 종합적으로 분석합니다. 이 책의 핵심 사상은 소프트웨어 아키텍처가 정답이 없는 트레이드오프(trade-off) 분석의 연속이며, 끊임없이 변화하는 기술 생태계 내에서 최적의 균형점을 찾는 과정이라는 것입니다.

소프트웨어 아키텍트는 단순히 기술 전문가를 넘어, 중요한 아키텍처 결정을 내리고, 팀을 이끌며, 비즈니스 목표를 이해하고, 조직 내 정치를 헤쳐나가는 다각적인 역할을 수행해야 합니다. 성공적인 아키텍트는 개발자와 같은 기술적 깊이보다는 다양한 기술을 아우르는 **기술적 폭(technical breadth)** 을 갖추는 것이 중요합니다.
 
 핵심 원칙으로는 시스템의 성공에 결정적인 비기능적 요구사항인 **아키텍처 특성(-ilities)** 의 식별, 시스템의 배포 및 종속성 범위를 정의하는 아키텍처 퀀텀(architectural quantum), 아키텍처 원칙 준수를 자동화하는 피트니스 함수(fitness functions), 그리고 중요한 결정을 체계적으로 기록하는 **아키텍처 결정 기록(ADRs)** 이 강조됩니다.
 
 계층형 아키텍처, 마이크로서비스, 이벤트 기반 아키텍처 등 다양한 아키텍처 스타일이 존재하며, 각 스타일은 고유의 장단점을 가집니다. 따라서 특정 상황과 요구되는 아키텍처 특성에 가장 적합한, 즉 '가장 덜 나쁜(least worst)' 아키텍처를 선택하는 것이 아키텍트의 핵심 과제입니다.

![소프트웨어 아키텍처의 기초 인포그래픽](./info-graphic.png)

---

## 서론: 현대 소프트웨어 아키텍처의 본질

### 끊임없이 진화하는 생태계

소프트웨어 개발 생태계는 '동적 평형' 상태에 있습니다. 특정 시점에는 안정적으로 보이지만, 장기적으로는 끊임없이 변화합니다. 쿠버네티스와 같은 컨테이너화 기술의 등장은 지난 10년간 생태계가 얼마나 극적으로 변했는지를 보여주는 대표적인 예입니다.

모든 아키텍처는 그 시대적 맥락의 산물입니다. 예를 들어, 2002년에는 상용 운영체제와 데이터베이스 라이선스 비용이 매우 비쌌기 때문에 마이크로서비스와 같은 분산 아키텍처는 상상할 수 없을 정도로 비용이 많이 들었습니다. 오늘날 오픈 소스와 데브옵스(DevOps) 기술의 발전 덕분에 이러한 아키텍처가 실현 가능해졌습니다.

트레이드오프 분석의 핵심

"아키텍처에는 정답이나 오답이 없으며, 오직 트레이드오프만 있을 뿐이다." — 닐 포드(Neal Ford)

아키텍처의 가장 근본적인 원칙은 모든 결정에 장점, 단점, 그리고 절충점이 있다는 것을 이해하는 것입니다. 아키텍트는 특정 기술에 대한 개인적 선호를 배제하고 모든 결정의 득과 실을 냉정하게 평가해야 합니다.

"프로그래머는 모든 것의 장점은 알지만 아무것의 트레이드오프도 모른다. 아키텍트는 둘 다 이해해야 한다." — 리치 히키(Rich Hickey)

#### 예시: 경매 시스템의 메시징 방식

* 토픽 (Publish-Subscribe 모델): 새로운 구독자(서비스)를 추가할 때 기존 인프라 변경이 필요 없어 확장성이 뛰어납니다. 하지만 모든 구독자가 동일한 데이터 계약을 사용해야 하며, 데이터 접근 보안에 취약할 수 있습니다.
* 큐 (Point-to-Point 모델): 각 서비스가 독립적인 데이터 계약을 가질 수 있고, 특정 소비자만 메시지를 수신하므로 보안성이 높습니다. 하지만 새로운 서비스를 추가할 때마다 메시지 생산자의 코드를 수정해야 하는 등 확장성이 낮습니다.

아키텍처와 설계의 구분

아키텍처와 설계는 종종 혼용되지만 명확히 구분됩니다.

* 아키텍처: 집의 층수, 지붕 모양, 방의 개수처럼 시스템의 전반적인 구조를 결정하는 것입니다. 이는 시스템의 중요한 특성(확장성, 성능 등)에 큰 영향을 미치며 변경하기 어렵습니다.
* 설계: 집의 카펫, 벽지 색, 조명처럼 내부의 세부적인 구현을 다루는 것입니다. 클래스 구조, 디자인 패턴 선택 등이 여기에 해당하며, 아키텍처 결정에 비해 상대적으로 변경이 용이합니다.


---

## 소프트웨어 아키텍트의 역할과 기대치

소프트웨어 아키텍트의 역할은 단순한 선임 개발자를 넘어섭니다. 성공적인 아키텍트가 되기 위해 요구되는 8가지 핵심 기대치는 다음과 같습니다.

기대치	설명
1. 아키텍처 결정 내리기	시스템의 구조, 기술 스택, 의존성 등 중요한 기술적 결정을 주도합니다.
2. 아키텍처 지속적으로 분석하기	기존 아키텍처의 유효성을 지속적으로 평가하고 개선 방안을 제안합니다.
3. 최신 동향 파악하기	기술 및 산업 트렌드를 지속적으로 학습하여 미래에도 유효한 결정을 내립니다.
4. 결정 사항 준수 보장하기	개발팀이 아키텍처 결정과 설계 원칙을 따르는지 확인하고 관리합니다.
5. 다양한 기술 이해하기	특정 기술의 전문가가 아니더라도 여러 기술, 프레임워크, 플랫폼을 폭넓게 이해합니다.
6. 비즈니스 도메인 파악하기	비즈니스 목표와 요구사항을 깊이 이해하고 이를 기술적 해결책으로 전환합니다.
7. 팀 리딩 및 대인관계 기술 보유	기술적 리더십뿐만 아니라 팀워크, 중재, 소통 능력을 통해 팀을 이끌어갑니다.
8. 조직 내 정치 이해 및 탐색	중요한 결정을 관철시키기 위해 조직의 정치적 상황을 이해하고 협상 능력을 발휘합니다.

### 기술적 깊이 vs. 기술적 폭

개발자는 특정 기술에 대한 기술적 깊이가 중요하지만, 아키텍트는 다양한 기술에 대해 얕더라도 넓게 아는 기술적 폭이 더 중요합니다. 이는 '지식의 피라미드' 모델로 설명할 수 있습니다.

* 아는 것 (Stuff you know): 매일 사용하는 기술. 전문 지식의 영역. (피라미드 최상단)
* 모른다는 것을 아는 것 (Stuff you know you don't know): 들어는 봤지만 전문성은 없는 기술. (중간)
* 모른다는 것조차 모르는 것 (Stuff you don't know you don't know): 존재 자체를 모르는 기술. (최하단)

아키텍트의 목표는 피라미드 최하단의 지식을 중간 단계로 끌어올려, 문제 해결에 사용할 수 있는 선택지의 폭을 넓히는 것입니다.

### 최신 동향 파악 기법

* 20분 규칙 (The 20-Minute Rule): 매일 최소 20분, 가급적 아침에 이메일을 확인하기 전에 새로운 기술이나 주제를 학습하는 습관입니다. 추천 자료로는 InfoQ, DZone Refcardz, Thoughtworks Technology Radar 등이 있습니다.
* 개인 기술 레이더 (Personal Technology Radar): 현재 및 새로운 기술의 위험과 기회를 평가하는 문서입니다.
  * 사분면: 도구(Tools), 언어 및 프레임워크(Languages & Frameworks), 기술(Techniques), 플랫폼(Platforms).
  * 링: 보류(Hold), 평가(Assess), 시험(Trial), 채택(Adopt).


---

## 아키텍처의 구조적 기초

### 모듈성 측정: 결합도, 응집도, 동시성

잘 설계된 아키텍처는 높은 모듈성을 가집니다. 이는 세 가지 주요 지표로 측정할 수 있습니다.

* 응집도 (Cohesion): 모듈 내부의 요소들이 얼마나 밀접하게 관련되어 있는지를 나타내는 척도입니다. 기능적 응집도가 가장 이상적이며, 논리적/시간적 응집도는 낮은 수준으로 간주됩니다. **LCOM(Lack of Cohesion in Methods)** 은 메서드 간의 응집도 부족을 측정하는 지표입니다.
* 결합도 (Coupling): 모듈 간의 의존성 정도를 나타냅니다.
  * 구심적 결합도 (Afferent Coupling): 다른 모듈에서 해당 모듈로 들어오는 의존성의 수.
  * 원심적 결합도 (Efferent Coupling): 해당 모듈에서 다른 모듈로 나가는 의존성의 수.
* 핵심 지표:
  * 추상도 (Abstractness, A): 추상적인 요소(인터페이스, 추상 클래스)와 구체적인 요소의 비율.
  * 불안정도 (Instability, I): 원심적 결합도와 전체 결합도의 비율. 불안정도가 높을수록 변경에 취약합니다.
  * 주계열과의 거리 (Distance from the Main Sequence, D): D = |A + I - 1|. 이 값이 0에 가까울수록 추상도와 불안정도가 이상적인 균형을 이룹니다. 이 선에서 멀어질수록 '고통의 영역(Zone of Pain, 너무 구체적이고 불안정)' 또는 '무용지물의 영역(Zone of Uselessness, 너무 추상적이고 안정적)'에 속하게 됩니다.
* 동시성 (Connascence): 결합도를 더 세분화하여 표현하는 개념으로, 두 컴포넌트가 변경을 위해 함께 변경되어야 하는 경우를 의미합니다. 리팩토링은 강한 동시성(정체성, 값)에서 약한 동시성(이름, 타입)으로 향해야 합니다.
  * 정적 동시성: 소스 코드 수준에서 분석 가능한 결합 (이름, 타입, 의미, 알고리즘, 위치).
  * 동적 동시성: 런타임에 분석해야 하는 결합 (실행, 시간, 값, 정체성).

### 아키텍처 특성 (-ilities)

아키텍처 특성은 성능, 확장성, 보안 등과 같이 시스템의 성공에 필수적인 비기능적 요구사항입니다.

* 분류:
  * 운영 특성: 가용성, 성능, 확장성, 복원성, 신뢰성 등.
  * 구조적 특성: 유지보수성, 이식성, 확장성, 테스트 용이성 등.
  * 기타: 보안, 법률 준수, 사용성 등.
* 도메인 관심사 변환: 비즈니스 요구사항을 아키텍처 특성으로 변환하는 것이 중요합니다. 예를 들어, '시장 출시 시간 단축(Time to Market)'은 '민첩성(Agility)', '테스트 용이성(Testability)'으로, '인수 합병(Mergers and Acquisitions)'은 '상호운용성(Interoperability)', '확장성(Scalability)'으로 변환될 수 있습니다.

### 아키텍처 퀀텀 (Architectural Quantum)

아키텍처 퀀텀은 높은 기능적 응집도를 가지며 독립적으로 배포 가능한 아키텍처 구성 요소입니다.

* 정의: 퀀텀 내의 컴포넌트들은 동기식 통신(synchronous connascence)으로 강하게 결합됩니다.
* 범위: 아키텍처 특성들은 개별 퀀텀 수준에서 정의되고 적용됩니다.
* 경계: 동기식 호출은 여러 서비스를 하나의 퀀텀으로 묶는 반면, 비동기식 호출은 별개의 퀀텀을 형성합니다. 이는 모놀리식 아키텍처와 분산 아키텍처 중 어떤 스타일을 선택할지 결정하는 데 중요한 기준이 됩니다.


---

## 아키텍처 거버넌스와 문서화

### 피트니스 함수 (Fitness Functions)

피트니스 함수는 아키텍처 원칙과 제약 조건이 잘 지켜지고 있는지 객관적으로 측정하고 검증하는 자동화된 메커니즘입니다.

* 목적: 아키텍처 거버넌스를 자동화하여 아키텍처의 구조적 부패를 방지합니다.
* 예시:
  * JDepend와 같은 도구를 사용하여 컴포넌트 간의 순환 의존성을 감지하는 테스트.
  * ArchUnit과 같은 라이브러리를 사용하여 계층형 아키텍처의 규칙(예: 프레젠테이션 계층이 퍼시스턴스 계층에 직접 접근 금지)을 강제하는 테스트.
  * 넷플릭스(Netflix)의 카오스 몽키(Chaos Monkey): 프로덕션 환경에서 무작위로 장애를 발생시켜 시스템의 복원력을 테스트하는 피트니스 함수.

### 아키텍처 결정 기록 (ADRs)

ADR은 중요한 아키텍처 결정을 기록하는 간결한 문서 형식입니다. 이는 왜 그런 결정이 내려졌는지에 대한 맥락을 제공하여 미래의 혼란을 방지합니다.

* 핵심 구성 요소:
  * 제목(Title): 결정을 요약하는 간결한 문장.
  * 상태(Status): 제안됨(Proposed), 수락됨(Accepted), 대체됨(Superseded).
  * 맥락(Context): 결정을 내리게 된 배경과 문제 상황.
  * 결정(Decision): 내린 결정과 그에 대한 기술적/비즈니스적 근거.
  * 결과(Consequences): 결정으로 인해 발생하는 긍정적/부정적 영향 및 트레이드오프.
* 저장: ADR은 소스 코드와 함께 버전 관리되거나, 별도의 위키나 Git 저장소에 중앙 집중적으로 관리될 수 있습니다.


---

## 아키텍처 스타일 개요


아키텍처 스타일은 시스템의 구조를 정의하는 청사진입니다. 각 스타일은 고유한 특성과 트레이드오프를 가집니다.

아키텍처 스타일	설명	장점	단점
계층형 아키텍처	관심사를 프레젠테이션, 비즈니스, 퍼시스턴스 등의 계층으로 분리.	단순하고 비용이 저렴하며 개발이 용이함.	테스트, 배포, 확장성이 떨어짐. 모놀리식 구조.
모듈형 모놀리스	단일 배포 단위 내에서 기술 계층이 아닌 도메인 중심으로 코드를 분할.	계층형보다 모듈성이 높고 도메인 기반 변경에 유리함.	여전히 모놀리스이며, 확장성에 한계가 있음.
파이프라인 아키텍처	파이프와 필터 구조로, 단방향 데이터 처리 흐름에 적합. (예: ETL)	단순하고 재사용성이 높음.	복잡한 양방향 통신이나 상태 관리에는 부적합.
마이크로커널 아키텍처	핵심 시스템(Core)과 플러그인(Plug-in) 컴포넌트로 구성. (예: Eclipse IDE)	확장성과 진화 가능성이 뛰어남. 기능별 분리가 용이.	코어 시스템 설계가 복잡하고, 플러그인 간 통신이 어려울 수 있음.
서비스 기반 아키텍처	4~12개의 독립적으로 배포 가능한 도메인 서비스로 구성. 데이터베이스를 공유할 수 있음.	모놀리스와 마이크로서비스의 절충안. ACID 트랜잭션 지원 용이.	마이크로서비스보다 민첩성과 확장성이 낮음.
이벤트 기반 아키텍처(EDA)	비동기 이벤트 통신을 기반으로 하는 분산 아키텍처.	높은 성능, 확장성, 탄력성, 복원력.	워크플로우가 비결정적이라 테스트와 디버깅이 복잡함.
공간 기반 아키텍처	인메모리 데이터 그리드를 사용하여 데이터베이스 병목 현상을 제거.	극단적인 탄력성과 확장성.	매우 복잡하고 비용이 높음.
마이크로서비스 아키텍처	작고 독립적인 서비스들이 제한된 컨텍스트(Bounded Context)를 중심으로 구성.	높은 배포 독립성, 기술 이질성, 복원력, 진화 가능성.	분산 시스템의 복잡성, 높은 운영 비용, 데이터 일관성 문제.
오케스트레이션 기반 SOA	ESB(Enterprise Service Bus)가 중앙에서 서비스 워크플로우를 조정(오케스트레이션).	재사용성과 통합에 중점을 둠.	서비스 간 결합도가 높고, 민첩성과 성능이 떨어짐.


--------------------------------------------------------------------------------


## 리더십과 팀 효율성

아키텍처는 기술적 활동일 뿐만 아니라 사람과 관련된 활동입니다. 아키텍트는 효과적인 리더이자 협상가여야 합니다.

### 협상 및 리더십 기술

* 아키텍처의 4C: 명확성(Clarity), 간결성(Conciseness), 협업(Collaboration), 소통(Communication)은 리더십의 핵심입니다.
* 실용적이면서 비전을 제시: 현재의 제약 속에서 실용적인 해결책을 제시하는 동시에, 미래의 방향성을 제시할 수 있어야 합니다.
* 시연은 논쟁을 이긴다: 의견이 다를 때 논쟁하기보다, 개념 증명(POC)을 통해 데이터를 기반으로 설득하는 것이 효과적입니다.
* 비즈니스 근거 제시: "어제 필요했다"는 비즈니스 용어는 '시장 출시 시간'의 중요성을, "번개처럼 빨라야 한다"는 '성능'의 중요성을 의미합니다. 기술적 결정을 비즈니스 가치(비용, 시장 출시 시간, 사용자 만족도 등)로 정당화해야 합니다.

### 효과적인 팀 만들기

* 적절한 경계 설정: 개발팀에게 너무 엄격하거나 느슨한 제약을 두지 않고, 창의성을 발휘할 수 있는 적절한 '공간'을 만들어주어야 합니다.
* 체크리스트 활용: 코드 완성, 단위 테스트, 소프트웨어 릴리스 등 반복적이고 실수하기 쉬운 작업에 체크리스트를 도입하여 팀의 효율성과 안정성을 높입니다.
* 개발팀의 '몰입(Flow)' 상태 보호: 불필요한 회의를 줄이고, 개발자들이 집중해서 작업할 수 있는 환경을 조성하는 것이 중요합니다.
* 협력적 언어 사용: "이것은 어리석은 생각이다"와 같은 지시적 언어 대신 "이런 방법을 고려해 보셨나요?"와 같은 질문형 언어를 사용하여 협력적인 분위기를 조성합니다.
