# 이벤트 기반 아키텍처(EDA) 브리핑 문서

## Executive Summary

이벤트 기반 아키텍처(Event-Driven Architecture, EDA)는 높은 확장성과 성능을 갖춘 애플리케이션을 구축하기 위한 분산형 비동기 아키텍처 스타일입니다. 이 아키텍처는 비동기적으로 이벤트를 발생시키고 이에 반응하는 느슨하게 결합된(decoupled) 이벤트 처리 구성 요소들로 이루어져 있습니다. EDA는 요청에 따라 결정론적으로 작동하는 전통적인 요청 기반 모델과 달리, 시스템에서 이미 발생한 이벤트에 반응하여 동작함으로써 유연성과 적응성을 극대화합니다.

핵심적인 특징은 다음과 같습니다:

* 두 가지 주요 토폴로지: 코레오그래피(Choreographed) 모델은 중앙 조정자 없이 이벤트 프로세서들이 이벤트를 브로드캐스팅하여 서로 통신하는 분산형 방식입니다. 이는 높은 성능과 확장성을 제공하지만 워크플로우 제어가 어렵습니다. 반면, 중재자(Mediator) 모델은 중앙 이벤트 중재자를 통해 워크플로우를 오케스트레이션하여 제어력과 오류 처리를 강화하지만, 성능 저하 및 병목 현상이 발생할 수 있습니다.
* 이벤트 페이로드 설계의 중요성: 이벤트에 담기는 데이터, 즉 페이로드(payload)를 설계하는 것은 EDA의 성능과 유지보수성에 큰 영향을 미칩니다. 데이터 기반(data-based) 페이로드는 처리의 필요한 모든 데이터를 포함하여 성능을 높이지만 데이터 일관성 및 계약 관리의 복잡성을 야기합니다. 키 기반(key-based) 페이로드는 이벤트 식별자(ID)만 포함하여 데이터 일관성을 유지하기 쉽지만, 데이터를 얻기 위한 추가적인 데이터베이스 조회가 필요해 성능에 부담을 줄 수 있습니다.
* 장점과 단점: EDA는 비동기 통신을 통해 시스템의 응답성, 확장성, 탄력성, 내결함성을 크게 향상시킵니다. 그러나 이벤트 흐름의 비결정적 특성으로 인해 테스트와 디버깅이 복잡하며, 전체 워크플로우의 상태를 추적하고 오류를 처리하는 것이 주요 과제입니다.

결론적으로, EDA는 동적인 사용자 프로세스와 실시간 의사결정이 필요한 복잡한 시스템에 강력한 솔루션을 제공합니다. 그러나 그 복잡성을 관리하기 위해 신중한 설계와 트레이드오프에 대한 깊은 이해가 필수적입니다.


--------------------------------------------------------------------------------


## 1. 이벤트 기반 아키텍처(EDA) 개요

**이벤트 기반 아키텍처(Event-Driven Architecture, EDA)**는 확장성이 뛰어나고 성능이 우수한 애플리케이션 구축에 널리 사용되는 **분산형 비동기 아키텍처 스타일**입니다. 이 스타일은 느슨하게 결합된 **이벤트 처리 컴포넌트**들이 비동기적으로 이벤트를 발생시키고 이에 반응하는 구조를 가집니다. EDA는 독립적인 아키텍처 스타일로 사용될 수도 있고, **마이크로서비스 아키텍처**와 같은 다른 스타일에 통합되어 **하이브리드 아키텍처**를 구성할 수도 있습니다.

저자들은 EDA가 단순한 아키텍처 패턴이 아니라, 전체 시스템을 구축하는 데 사용될 수 있는 완전한 아키텍처 스타일이라고 주장합니다.

## 2. 요청 기반 모델 vs. 이벤트 기반 모델

대부분의 애플리케이션은 **요청 기반(request-based) 모델**을 따릅니다. 이 모델에서 사용자의 요청은 **요청 오케스트레이터**를 통해 여러 **요청 프로세서**로 동기적이고 결정론적으로 전달됩니다. 예를 들어, 고객이 주문 내역을 조회하는 것은 시스템이 반응해야 할 이벤트가 아니라, 특정 컨텍스트에서 데이터를 조회하는 **결정론적 요청**입니다.

요청 기반 모델의 흐름:

1. Request (요청): 사용자가 시스템에 요청을 보냅니다.
2. Request Orchestrator (요청 오케스트레이터): 요청을 받아 처리할 프로세서에게 동기적으로 전달합니다.
3. Request Processor (요청 프로세서): 데이터베이스에서 정보를 조회하고 업데이트하여 요청을 처리합니다.
4. Database (데이터베이스): 데이터 저장소 역할을 합니다.



반면, **이벤트 기반(event-based) 모델**은 특정 이벤트에 반응하여 동작을 수행합니다. 예를 들어, 온라인 경매에서 입찰하는 행위는 시스템에 대한 요청이 아니라, "현재 가격이 공지된 후 입찰이 발생했다"는 **이벤트**를 트리거합니다. 시스템은 이 이벤트에 반응하여 다른 입찰과 비교하고 최고 입찰자를 결정해야 합니다.

## 3. EDA의 핵심 토폴로지 및 구성 요소

EDA는 **'실행 후 망각(fire-and-forget)' 방식**의 **비동기 통신**을 사용합니다. 아키텍처는 주로 4가지 핵심 구성 요소로 이루어집니다.

* **시작 이벤트(Initiating Event)**: 전체 이벤트 흐름을 시작하는 최초의 이벤트입니다.
* **이벤트 브로커(Event Broker)**: 이벤트를 수신하여 관심 있는 이벤트 프로세서들에게 전달하는 중앙 구성 요소입니다. 일반적으로 여러 도메인 기반 클러스터 인스턴스로 구성되며, **이벤트 채널**(큐, 토픽 등)을 포함합니다.
* **이벤트 프로세서(Event Processor)**: 이벤트를 수신하여 특정 작업을 수행하는 서비스입니다.
* **파생 이벤트(Derived Event)**: 이벤트 프로세서가 작업을 완료한 후, 시스템의 다른 부분에 "무슨 일을 했는지" 알리기 위해 발생시키는 새로운 이벤트입니다.

이벤트 처리 흐름 예시 (온라인 주문 시스템):

1. 주문 접수 (시작 이벤트): 고객이 책을 주문하면 Order Placement 서비스가 'place order' 이벤트를 받습니다.
2. 주문 생성 및 파생 이벤트: Order Placement 서비스는 주문을 데이터베이스에 저장하고, 'order placed'라는 파생 이벤트를 브로커에게 보냅니다.
3. 병렬 처리: 'order placed' 이벤트에 관심 있는 여러 프로세서(Notification, Payment, Inventory)가 동시에 작업을 시작합니다.
  * Notification 서비스는 고객에게 주문 확인 이메일을 보내고 'email sent' 이벤트를 발생시킵니다.
  * Inventory 서비스는 재고를 조정하고 'inventory updated' 이벤트를 발생시킵니다.
  * Payment 서비스는 결제를 시도하고, 결과에 따라 'payment applied' 또는 'payment denied' 이벤트를 발생시킵니다.
4. 연쇄 반응: 하나의 파생 이벤트가 다른 이벤트 프로세서의 작업을 트리거하며, 모든 파생 이벤트가 처리될 때까지 이 과정이 계속됩니다. 예를 들어 'payment applied' 이벤트는 Order Fulfillment 서비스의 작업을 유발하고, 이 서비스는 다시 'order fulfilled' 이벤트를 발생시킵니다.



**주의할 점: 포이즌 이벤트(Poison Event)** 파생 이벤트가 서비스들 사이에서 무한 루프에 빠지는 현상을 **포이즌 이벤트**라고 합니다. 예를 들어, Inventory 서비스가 재고를 조정한 후 'inventory adjusted' 이벤트를 발생시키고, 이 이벤트에 스스로 다시 반응하면 무한 루프가 발생할 수 있습니다. 이는 EDA 설계 시 반드시 피해야 할 문제입니다.

## 4. 주요 아키텍처 특성 및 패턴

### 이벤트와 메시지의 차이점

EDA에서 이벤트와 메시지는 명확히 구분됩니다. 이 둘의 차이를 이해하는 것은 아키텍처의 핵심을 파악하는 데 중요합니다.

구분	이벤트 (Event)	메시지 (Message)
의미	이미 발생한 사실을 알림 ("주문이 접수되었습니다.")	수행해야 할 명령이나 쿼리 ("이 주문에 대한 결제를 적용하세요.")
응답 기대	일반적으로 응답이 필요 없음 (Fire-and-Forget)	보통 응답이 필요함
통신 모델	Publish-and-Subscribe (1:N)	Point-to-Point (1:1)
물리적 채널	Topic, Stream, Notification Service	Queue, Message Service

### 파생 이벤트 및 확장성

* **파생 이벤트(Derived Events)**: 이벤트 프로세서가 시작 이벤트를 처리한 후 생성하고 트리거하는 이벤트입니다. 하나의 프로세서는 처리 결과에 따라 여러 개의 파생 이벤트를 발생시킬 수 있습니다. 예를 들어, 신용카드 결제 시 Fraud Detection 서비스는 'fraud detected'와 'no fraud detected'라는 두 가지 다른 파생 이벤트를 생성할 수 있습니다.
* **확장 가능한 이벤트(Extensible Events)**: 현재 이 이벤트에 반응하는 다른 프로세서가 없더라도, 모든 이벤트 프로세서는 자신이 수행한 작업을 파생 이벤트를 통해 시스템에 알리는 것이 좋습니다. 이를 통해 향후 새로운 기능이 필요할 때 기존 시스템을 변경하지 않고도 새로운 이벤트 프로세서를 추가하여 해당 이벤트에 반응하도록 할 수 있습니다. 이는 시스템의 **아키텍처 확장성**을 지원하는 중요한 관행입니다.

### 비동기 통신의 장점

* **응답성(Responsiveness) vs. 성능(Performance)**: **비동기 통신**은 시스템의 전체 처리 시간(성능)을 단축하지 않더라도, 사용자가 느끼는 응답 시간을 극적으로 개선할 수 있습니다. 예를 들어, 사용자가 3초 걸리는 댓글을 게시할 때, 동기 방식에서는 3초를 기다려야 하지만 비동기 방식에서는 요청이 접수되었다는 응답을 즉시(예: 25ms) 받고, 실제 처리는 백그라운드에서 진행됩니다.
* **동적 디커플링과 아키텍처 퀀텀(Architectural Quantum)**: **동기 통신**은 두 시스템을 강하게 결합시켜 하나의 **'아키텍처 퀀텀'**으로 만듭니다. 이는 한 시스템의 장애나 성능 저하가 다른 시스템에 직접적인 영향을 미침을 의미합니다. **비동기 통신**은 이러한 동기적 의존성을 제거하여 시스템들을 별개의 아키텍처 퀀텀으로 분리하고, 각 시스템의 독립적인 배포, 확장, 내결함성을 보장합니다.

### 브로드캐스트 기능

EDA의 특징 중 하나는 이벤트를 수신할 프로세서나 그들이 수행할 작업을 알지 못한 채 이벤트를 브로드캐스팅하는 능력입니다. 이를 **의미론적 디커플링(semantic decoupling)**이라고 하며, 이벤트 생산자가 소비자의 동작에 대해 알 필요가 없거나 의존하지 않음을 의미합니다.

## 5. 이벤트 페이로드 설계

이벤트에 포함된 정보를 **페이로드(payload)**라고 하며, 크게 데이터 기반과 키 기반의 두 가지 유형이 있습니다.

### 데이터 기반 페이로드

처리하는 데 필요한 모든 정보를 이벤트 페이로드에 담아 전송하는 방식입니다.

* 장점:
  * **성능 및 확장성**: 이벤트 수신자가 추가적인 데이터베이스 조회를 할 필요가 없어 처리 속도가 빠릅니다.
* 단점:
  * **데이터 일관성**: 데이터가 데이터베이스와 이벤트 양쪽에 존재하므로, 데이터가 업데이트될 경우 일관성을 유지하기 어렵습니다.
  * **계약 관리 및 버전 관리**: 페이로드의 데이터 구조(계약)가 변경되면 이를 사용하는 모든 이벤트 프로세서가 영향을 받습니다. 이는 시스템을 취약하게 만듭니다.
  * **스탬프 커플링(Stamp Coupling)**: 여러 프로세서가 동일한 데이터 구조를 공유하지만 각자 일부만 사용하는 경우, 사용하지 않는 부분의 변경만으로도 모든 프로세서에 영향을 미치는 문제입니다.
  * **대역폭 사용량**: 불필요한 데이터까지 전송하므로 네트워크 대역폭을 많이 소모할 수 있습니다.

### 키 기반 페이로드

이벤트의 컨텍스트를 식별하는 키(예: 주문 ID)만 페이로드에 담아 전송하는 방식입니다.

* 장점:
  * 데이터 일관성: 데이터는 오직 단일 기록 시스템(데이터베이스)에만 존재하므로 일관성 유지가 용이합니다.
  * 간단한 계약: 페이로드가 단순하여 계약 관리 및 버전 관리 문제가 거의 없습니다.
  * 적은 대역폭 사용량: 전송되는 데이터 양이 적습니다.
* 단점:
  * 성능 및 확장성: 이벤트를 수신하는 모든 프로세서가 필요한 데이터를 얻기 위해 데이터베이스를 조회해야 하므로, 데이터베이스에 부하가 집중되고 성능이 저하될 수 있습니다.

### 절충안 요약

기준	데이터 기반 페이로드	키 기반 페이로드
성능 및 확장성	좋음	나쁨
계약 관리	나쁨	좋음
스탬프 커플링	나쁨	좋음
대역폭 사용량	나쁨	좋음
제한된 DB 접근	좋음	나쁨
시스템 취약성	나쁨	좋음

### 안티패턴

* **빈혈 이벤트(Anemic Events)**: 이벤트 수신자가 다음에 무엇을 해야 할지 결정하기에 충분한 정보가 페이로드에 포함되지 않은 이벤트입니다. 예를 들어, 'profile_updated' 이벤트에 고객 ID만 있고 어떤 정보가 변경되었는지에 대한 내용이 없다면, 수신자는 아무런 조치도 취할 수 없습니다.
* **모기 떼 안티패턴(The Gnat Swarm Antipattern)**: 하나의 이벤트 프로세서가 너무 많은 세분화된(fine-grained) 파생 이벤트를 발생시키는 문제입니다. 예를 들어, 고객 프로필 변경 시 청구지 주소 변경, 배송지 주소 변경, 전화번호 변경에 대해 각각 별도의 이벤트를 발생시키면 시스템이 불필요한 이벤트로 넘쳐나게 됩니다. 이 경우, 모든 변경 사항을 하나의 'profile_updated' 이벤트로 묶는 것이 더 효율적입니다.

## 6. 주요 과제 및 해결 방안

### 오류 처리: 워크플로우 이벤트 패턴

**비동기 워크플로우**에서의 **오류 처리**는 EDA의 주요 과제입니다. **워크플로우 이벤트 패턴**은 이 문제를 해결하기 위한 방법입니다.

1. **위임(Delegation)**: 이벤트 소비자(Consumer)는 데이터 처리 중 오류가 발생하면 즉시 해당 오류를 **워크플로우 프로세서** 서비스에 위임하고 다음 메시지 처리를 계속합니다.
2. **수리(Repair)**: 워크플로우 프로세서는 오류를 분석하여 프로그래밍 방식으로 데이터를 수정하려고 시도합니다. 수정이 성공하면 원래 큐로 메시지를 다시 보냅니다.
3. **수동 개입**: 자동 수정이 불가능한 경우, 해당 메시지는 전문가의 대시보드로 보내져 수동으로 수정된 후 다시 제출됩니다.

이 패턴을 통해 시스템은 오류 발생 시에도 전체적인 응답성을 유지할 수 있습니다.

### 데이터 손실 방지

비동기 통신에서는 이벤트나 메시지가 유실될 위험이 항상 존재합니다. 이를 방지하기 위해 다음과 같은 기술을 사용하는 이벤트 전달 패턴을 적용할 수 있습니다.

* 영구 큐(Persistent Queues) 및 동기 전송(Synchronous Send): 이벤트 브로커가 이벤트를 디스크에 저장한 후에만 생산자에게 확인 응답을 보내 데이터 손실을 방지합니다.
* 클라이언트 확인 모드(Client Acknowledge Mode): 소비자가 이벤트 처리를 완료하고 명시적으로 확인하기 전까지 이벤트가 큐에서 제거되지 않도록 합니다.
* ACID 트랜잭션 및 최종 참여자 지원(LPS): 데이터베이스 커밋과 연계하여 메시지 처리가 완전히 보장될 때만 큐에서 이벤트를 최종적으로 제거합니다.

### 요청-응답 처리

EDA에서도 동기적인 정보 교환이 필요할 때가 있습니다. 이는 보통 **요청-응답 메시징**(유사 동기 통신)을 통해 구현됩니다.

* **상관관계 ID(Correlation ID) 사용**: 요청 메시지의 고유 ID를 응답 메시지의 상관관계 ID 필드에 설정하여, 생산자가 수많은 응답 중에서 자신의 요청에 대한 응답을 식별할 수 있도록 합니다.
* **임시 큐(Temporary Queue) 사용**: 각 요청마다 전용 임시 응답 큐를 생성하여 응답을 수신하는 방식입니다. 구현은 간단하지만 브로커에 부하를 줄 수 있습니다.

## 7. 중재자(Mediator) 토폴로지

이는 EDA의 오케스트레이션(orchestrated) 형태입니다.

* **코레오그래피 토폴로지(Choreographed Topology)**가 분산된 이벤트 프로세서들이 자율적으로 협력하는 방식이라면, **중재자 토폴로지(Mediator Topology)**는 중앙의 **이벤트 중재자(Event Mediator)**가 전체 워크플로우를 관리하고 제어합니다.
* 작동 방식:
  1. 시작 이벤트가 이벤트 중재자에게 전달됩니다.
  2. 중재자는 이벤트 처리에 필요한 단계들을 알고 있으며, 각 단계에 맞는 명령(message)을 생성하여 특정 이벤트 프로세서의 전용 채널(큐)로 보냅니다.
  3. 이벤트 프로세서는 메시지를 처리하고 완료되면 중재자에게 응답합니다.
* 장점:
  * 워크플로우에 대한 중앙 제어가 가능합니다.
  * 상태 관리, 오류 처리, 복구 및 재시작 기능 구현이 용이합니다.
* 단점:
  * 중재자가 단일 장애점(SPOF)이나 성능 병목이 될 수 있습니다.
  * 이벤트 프로세서 간의 결합도가 코레오그래피 방식보다 높아집니다.
  * 성능이 코레오그래피 방식보다 떨어질 수 있습니다.

중재자 구현: 워크플로우의 복잡성에 따라 Apache Camel (단순), BPEL 기반 엔진 (복잡), BPM 엔진 (장기 실행 및 인간 개입 필요) 등 적절한 기술을 선택해야 합니다.

## 8. 데이터 토폴로지

### 모놀리식 데이터베이스 토폴로지

모든 이벤트 프로세서가 단일 중앙 데이터베이스를 공유합니다.

* 장점: 데이터 접근이 용이하고 서비스 간 통신이 줄어듭니다.
* 단점: 내결함성, 확장성, 변경 제어에 취약하며, 전체 시스템이 단일 아키텍처 퀀텀을 형성합니다.

### 도메인 데이터베이스 토폴로지

이벤트 프로세서들을 여러 도메인으로 나누고, 각 도메인이 자체 데이터베이스를 소유합니다.

* 장점: 모놀리식보다 내결함성, 확장성, 변경 제어가 향상됩니다.
* 단점: 다른 도메인의 데이터가 필요할 경우, 이벤트 프로세서 간에 동기적 호출이 발생하여 결합도가 높아질 수 있습니다.

### 전용 데이터베이스 토폴로지

각 이벤트 프로세서가 자신만의 전용 데이터베이스를 가집니다 (서비스별 데이터베이스 패턴).

* 장점: 내결함성, 확장성, 변경 제어 측면에서 가장 우수합니다.
* 단점: 다른 프로세서의 데이터가 필요할 때 동기적 호출이 빈번하게 발생하여 아키텍처의 장점을 상쇄할 수 있습니다. 이벤트 프로세서들이 대부분 독립적일 때 적합합니다.

## 9. 아키텍처 평가

### 스타일 특성 평가

아키텍처 특성	별점 평가
전체 비용	$$$
파티셔닝 유형	기술적 (Technical)
퀀텀 수	1 ~ 다수
단순성	☆☆☆
모듈성	☆☆☆☆
유지보수성	☆☆☆☆
테스트 용이성	☆☆
배포 용이성	☆☆☆☆
진화 가능성	☆☆☆☆☆
응답성	☆☆☆☆☆
확장성	☆☆☆☆
탄력성	☆☆☆☆
내결함성	☆☆☆☆

* 높은 평가: 응답성, 진화 가능성, 확장성, 내결함성 등 운영적 측면에서 매우 강력합니다. 새로운 기능을 추가하기 용이하며(진화 가능성 5점), 비동기 병렬 처리로 높은 성능과 확장성을 달성합니다.
* 낮은 평가: 단순성과 테스트 용이성이 낮습니다(2-3점). 이벤트 흐름이 비결정적이고 동적이어서 전체 워크플로우를 예측하고 테스트하기가 매우 어렵습니다.

### 이벤트 기반 모델의 장단점

요청 기반 모델 대비 장점	절충안 (단점)
동적 사용자 콘텐츠에 대한 더 나은 응답	최종적 일관성(Eventual Consistency)만 지원
더 나은 확장성 및 탄력성	처리 프로세스에 대한 제어력 감소
더 나은 민첩성 및 변경 관리	이벤트 흐름 결과에 대한 불확실성
더 나은 적응성 및 확장성	테스트 및 디버깅의 어려움
더 나은 응답성 및 성능
더 나은 실시간 의사결정
상황 인식에 대한 더 나은 반응

### 적용 사례

EDA는 시스템 내부 또는 외부에서 발생하는 일에 반응해야 하는 모든 비즈니스 문제에 적합합니다.

* 온라인 주문 시스템: 주문 처리 과정을 병렬적이고 느슨하게 결합된 방식으로 처리할 수 있습니다.
* 온라인 경매 시스템: 입찰 행위를 '요청'이 아닌 '발생한 이벤트'로 처리하여 높은 응답성과 확장성을 요구하는 시스템에 이상적입니다. 수많은 입찰자들의 동시적인 활동을 효과적으로 처리할 수 있습니다.
