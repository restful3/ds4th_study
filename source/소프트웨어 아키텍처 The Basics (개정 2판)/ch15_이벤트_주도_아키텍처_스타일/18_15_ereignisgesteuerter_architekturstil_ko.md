---
lang: ko
format:
  html:
    toc: true
    embed-resources: true
    theme: cosmo
---

# 15장. 이벤트 주도 아키텍처 스타일

이 문서는 AI를 사용하여 번역되었습니다. 피드백이나 의견이 있으시면 [translation-feedback@oreilly.com](mailto:translation-feedback@oreilly.com)으로 보내주세요.

*ereignisgesteuerte* Architektur (이벤트 주도 아키텍처, Event-Driven Architecture, EDA)는 고도로 확장 가능하고 성능이 뛰어난 애플리케이션을 구축하는 데 널리 사용되는 분산형 비동기 아키텍처 스타일입니다. 이 스타일은 특히 적응성이 뛰어나기 때문에 작은 시스템부터 크고 복잡한 애플리케이션까지 폭넓게 활용할 수 있습니다. 이벤트 주도 아키텍처는 이벤트를 비동기적으로 발행하고 이에 반응하는, 서로 느슨하게 결합된 이벤트 처리 구성요소로 구성됩니다. 이 스타일은 독립적인 아키텍처 스타일로 사용할 수 있을 뿐 아니라 이벤트 주도 마이크로서비스 아키텍처처럼 다른 아키텍처 스타일 안에 내장할 수도 있습니다.

많은 개발자와 소프트웨어 아키텍트는 EDA를 아키텍처 스타일이라기보다 아키텍처 패턴으로 바라보지만, 우리는 다르게 생각합니다. 저자들은 오로지 EDA에만 의존하는 전체 시스템을 구축해 본 경험이 있으며, 그 결과 EDA는 우선 아키텍처 스타일이라고 주장합니다. 물론 EDA는 마이크로서비스나 공간 기반 아키텍처 같은 다른 스타일 속에서 혼합 아키텍처를 만들기 위해 사용할 수도 있지만, 핵심을 들여다보면 복잡한 시스템을 설계하는 하나의 방법입니다.

대부분의 애플리케이션은 [그림](#page-2-0) 15-1처럼 *요청 기반* 모델을 따릅니다. 예를 들어 사용자가 지난 6개월의 주문 내역을 조회하고 싶다면, 먼저 *요청 오케스트레이터*가 해당 요청을 수신합니다. 요청 오케스트레이터는 보통 사용자 인터페이스이지만 API 계층, 오케스트레이션 서비스, 이벤트 허브, 이벤트 버스, 통합 허브처럼 구현될 수도 있습니다. 이 구성요소의 역할은 요청을 결정론적으로, 그리고 동기적으로 다양한 *요청 처리기*에 전달하는 것입니다. 요청 처리기는 데이터베이스에서 고객 정보를 조회하거나 갱신하여 요청을 처리합니다. 주문 내역을 조회하는 작업은 시스템이 특정 문맥에서 처리해야 하는 데이터 중심의 결정론적 요청이며, 시스템이 반응해야 하는 이벤트가 아니기 때문에 요청 기반 모델에 해당합니다.

반면 *이벤트 기반* 모델은 특정 이벤트가 발생했을 때 이에 반응하여 작업을 실행합니다. 예를 들어 온라인 경매에서 특정 품목에 입찰했다고 해 봅시다. 입찰자는 시스템에 요청을 보내는 것이 아니라 현재 입찰가를 공개한 직후 발생하는 이벤트를 발생시키는 것입니다. 시스템은 동일한 시점에 들어온 다른 입찰과 해당 입찰을 비교하고 현재 최고 입찰자를 판단하는 방식으로 이 이벤트에 반응해야 합니다.

<span id="page-2-0"></span>![](_page_2_Figure_1.jpeg)

그림 15-1. 요청 기반 모델
# 토폴로지

이벤트 주도 아키텍처는 서비스가 이벤트를 발행하고 다른 서비스가 해당 이벤트에 반응하는 비동기식 *Fire-and-Forget-Kommunikation (파이어 앤드 포겟 통신)*을 사용합니다. 이 아키텍처에는 *auslösendes Ereignis (트리거 이벤트)*, *Ereignis-Broker (이벤트 브로커)*, *Ereignis-Prozessor (이벤트 프로세서)*(일반적으로 *서비스*라고 부릅니다), 그리고 *abgeleitetes Ereignis (파생 이벤트)*라는 네 가지 핵심 구성 요소가 있습니다.

*auslösendes Ereignis*는 전체 이벤트 흐름을 시작하는 이벤트입니다. 온라인 경매에서 입찰을 제출하는 단순한 사건일 수도 있고, 직원이 결혼했을 때 건강보험 시스템을 업데이트하는 것처럼 훨씬 복잡한 사건일 수도 있습니다. 트리거 이벤트는 처리하기 위해 *Event Broker*의 이벤트 채널로 전송됩니다. 이후 단일 *Ereignisprozessor*가 이벤트 브로커에서 트리거 이벤트를 수신하고 해당 이벤트를 처리하기 시작합니다.

트리거 이벤트를 받은 이벤트 프로세서는 그 이벤트와 연관된 특정 작업(예: 경매 품목에 대한 입찰 제출)을 수행하고, 자신이 무엇을 했는지 시스템 나머지 부분에 비동기적으로 알려 주기 위해 *abgeleitetes Ereignis*를 *Ereignisbroker*로 발행합니다. 다른 이벤트 프로세서는 이 파생 이벤트에 반응하여 추가 처리를 수행한 뒤, 자신이 수행한 작업을 알리는 새로운 파생 이벤트를 다시 발행합니다. 이 프로세스는 모든 이벤트 프로세서가 유휴 상태가 되고 모든 파생 이벤트가 처리될 때까지 계속됩니다. [그림](#page-5-0) 15-2는 이러한 이벤트 처리 흐름을 보여 줍니다.

<span id="page-5-0"></span>![](_page_5_Picture_0.jpeg)

그림 15-2. 이벤트 주도 아키텍처의 기본 토폴로지

이벤트 브로커 구성 요소는 보통 여러 도메인 기반 클러스터 인스턴스를 보유한 *föderiert (연합형)* 구성입니다. 각 연합형 브로커에는 해당 도메인의 *Ereignisfluss (이벤트 흐름)*, 즉 이벤트 처리 전체 워크플로에서 사용되는 모든 *Ereigniskanäle (이벤트 채널)*(큐, 토픽 등)이 포함됩니다. 이 아키텍처 스타일은 디커플링된 비동기 브로드캐스트인 fire-and-forget 방식을 사용하므로, 브로커 토폴로지는 게시/구독 메시징 모델을 갖춘 토픽, [Topic-Exchanges](https://oreil.ly/TQDvA)(Advanced Message Queuing Protocol, AMQP의 경우) 또는 스트림을 함께 사용합니다.

EDA 처리가 전체적으로 어떻게 작동하는지 설명하기 위해 [그림](#page-7-0) 15-3의 전형적인 소매 주문 시스템 워크플로를 살펴봅니다. 이 예에서 고객은 책과 같은 품목을 주문할 수 있습니다. Order Placement 이벤트 프로세서는 트리거 이벤트인 place order 를 수신한 뒤 주문을 데이터베이스 테이블에 삽입하고 고객에게 주문 ID를 반환합니다. 그리고 나서 order placed 라는 파생 이벤트를 발행해 주문을 생성했음을 시스템 전체에 알립니다. 이 파생 이벤트에 관심이 있는 이벤트 프로세서는 Notification, Payment, Inventory의 세 가지이며, 모두 각자의 작업을 병렬로 실행합니다.

![](_page_7_Figure_0.jpeg)

Notification 이벤트 프로세서는 order placed 파생 이벤트를 수신하고 고객에게 주문 세부 정보를 담은 이메일을 발송합니다. Notification 이벤트 프로세서는 동작을 수행했으므로 email sent 라는 파생 이벤트를 발생시킵니다. 하지만 [그림](#page-7-0) 15-3에서 볼 수 있듯이 다른 이벤트 프로세서는 이 파생 이벤트를 청취하지 않습니다. 이는 EDA에서 흔한 것으로, 기존 시스템을 변경하지 않고도 향후 이벤트 프로세서가 파생 이벤트에 반응할 수 있게 해 주는 이 스타일의 *architektonische Erweiterbarkeit (아키텍처 확장성)*을 보여 줍니다(“[확장 가능한](#page-17-0) 이벤트 발행” 참조).

Inventory 이벤트 프로세서 역시 order placed 파생 이벤트를 수신하고 해당 도서의 재고를 조정합니다. 그런 다음 inventory updated라는 파생 이벤트를 발행하여 자신의 동작을 알리고, 이는 Warehouse 이벤트 프로세서의 응답을 유도합니다. Warehouse 프로세서는 재고를 확인해 창고 간 재고를 조정하며, 재고가 부족해지면 품목을 다시 주문합니다. 재고가 보충되면 Warehouse 이벤트 프로세서는 stock replenished 파생 이벤트를 발행하고, Inventory 프로세서는 다시 현재 재고를 조정합니다.

이 경우 Inventory 이벤트 프로세서는 inventory adjusted 이벤트를 발행하지 않습니다. 만약 발행한다면, *giftetes Ereignis (독성 이벤트)*라고 부르는, 끝없이 반복되는 이벤트 루프를 만들게 됩니다.

#### **경고**

*독성 이벤트*는 파생 이벤트가 서비스들 사이에서 무한 루프를 형성하며 발행되고 처리될 때 발생합니다. 이벤트 주도 아키텍처에서는 이런 일이 자주 일어날 수 있으므로 반드시 주의해야 합니다.

Payment 이벤트 프로세서는 order placed 파생 이벤트에도 반응하여 고객의 신용카드를 청구합니다. [그림](#page-7-0) 15-3에서 보듯이 Payment 이벤트 프로세서의 동작 결과로 두 가지 파생 이벤트가 생성될 수 있습니다. 하나는 결제가 완료되었음을 시스템에 알리는 payment applied 이고, 다른 하나는 결제가 거부되었음을 알리는 payment denied 입니다. Notification 이벤트 프로세서는 payment denied 파생 이벤트에 관심이 있는데, 이 경우 고객에게 이메일을 보내 카드 정보를 업데이트하거나 다른 결제 수단을 선택하라고 알려야 하기 때문입니다.

Order Fulfillment 이벤트 프로세서는 payment applied 파생 이벤트를 청취하고 피킹/패킹과 관련된 여러 자동화 기능을 실행합니다. 예를 들어 작업자에게 품목 위치나 필요한 상자 크기를 알려 줍니다. 처리가 끝나면 order fulfilled 파생 이벤트를 발행하여 주문이 완료되었음을 시스템에 알립니다. Notification과 Shipping 이벤트 프로세서는 모두 이 파생 이벤트를 청취합니다. 동시에 Notification 이벤트 프로세서는 주문이 완료되어 배송 준비가 되었다고 고객에게 알립니다. Shipping 이벤트 프로세서는 배송 방법을 선택하고 주문을 발송한 뒤 order shipped 파생 이벤트를 발행합니다. Notification 이벤트 프로세서는 이 order shipped 이벤트를 기다렸다가 주문이 배송 중임을 고객에게 다시 알려 줍니다.

모든 이벤트 프로세서는 느슨하게 결합되어 서로 독립적으로 동작합니다. 이 비동기 처리 프로세스를 이해하는 한 가지 방법은 바통을 넘기는 릴레이 경주로 비유하는 것입니다. 릴레이에서 주자는 바통을 쥐고 일정 거리를 달린 후(예: 1.5킬로미터) 다음 주자에게 바통을 건넵니다. 바통을 건네는 순간 해당 주자의 경주는 끝나며 다른 일에 집중할 수 있습니다. 이벤트 프로세서도 마찬가지입니다. 이벤트를 다음 프로세서에게 넘기면 해당 프로세서는 더 이상 그 이벤트를 처리하지 않고 다른 트리거 또는 파생 이벤트에 반응할 수 있습니다. 또한 각 이벤트 프로세서는 서로 다른 부하나 백업 상황에 맞춰 독립적으로 확장할 수 있습니다.
# 스타일 세부 사항

다음 절에서는 이 복잡한 아키텍처 스타일에 포함된 고려 사항, 패턴, 혼합형 구성 등을 포함해 EDA를 더 자세히 살펴봅니다.

## <span id="page-11-0"></span>**이벤트와 메시지**

이벤트 주도 아키텍처는 정보를 전달하고 처리하기 위해 이벤트를 사용합니다. 그런데 *이벤트*는 *메시지*와 얼마나 다를까요? 결론부터 이야기하자면, 매우 다릅니다.

*이벤트*는 "방금 주문을 완료했습니다"처럼 어떤 일이 이미 일어났음을 다른 이벤트 프로세서에게 알립니다. 반면 *메시지*는 "이 주문에 결제를 적용하세요" 혹은 "이 주문에 대한 배송 옵션을 알려주세요"와 같은 명령이나 질의에 가깝습니다. 이는 미묘한 차이가 아닙니다. 우리가 *이벤트 처리*라고 말할 때는 이미 발생한 일에 *반응*하는 것을 의미하며, 메시지는 *아직 수행되어야 할 작업*을 설명합니다. 우리의 예에서 "나는 방금 주문을 완료했습니다"는 주변 이벤트 프로세서에게 작업을 *요청*하지 않습니다. 대신 트리거 이벤트를 내보내며 파생 이벤트를 발생시킵니다.

EDA에서는 이벤트 처리를 위해 AMQP 같은 메시징 기술을 사용할 수도 있지만, 이벤트와 메시지를 구분하는 것이 중요합니다. 이벤트가 계속 이벤트로 남아 있으며, 그에 대한 처리는 누군가를 호출하는 것이 아니라 무언가를 *발생*시킴으로써 이루어져야 합니다.

## **파생 이벤트**

이벤트는 트리거 이벤트 또는 파생 이벤트일 수 있습니다. *파생 이벤트*는 본래 이벤트 처리 구성요소가 특정 작업을 수행한 뒤 자신이 수행한 작업을 시스템 나머지 부분에 알리는 이벤트입니다. 각 이벤트 프로세서는 이러한 파생 이벤트에 반응할지 여부를 스스로 결정합니다. 파생 이벤트는 시스템의 다른 부분과 결정론적으로 결합되지 않으면서도 자신이 수행한 작업을 브로드캐스트할 수 있기 때문에, 이 아키텍처 스타일의 핵심 원칙인 *동적 결합 해소*를 지원합니다.

이벤트 주도 아키텍처에서는 일반적으로 다른 이벤트 프로세서가 해당 작업에 관심이 있든 없든 상관없이, 각 이벤트 프로세서가 자신이 수행한 작업을 시스템 전체에 알리는 것이 좋은 실천법입니다.

다른 이벤트 프로세서가 이벤트에 관심을 두거나 반응하지 않는다면, 이를 *확장 가능한 파생 이벤트*라고 부릅니다. 이러한 이벤트는 이후에 해당 이벤트 처리에 추가 기능이 필요할 때 사용할 수 있는 내장 "훅"을 제공함으로써 *아키텍처 확장성*을 지원합니다. 예를 들어 [그림](#page-18-0) 15-5처럼 복잡한 이벤트 프로세스의 일부로 Notification 이벤트 프로세서가 고객에게 이메일을 발송한다고 합시다. Notification 이벤트 프로세서는 이어서 email sent라는 새로운 파생 이벤트를 발행해 이메일을 보냈음을 시스템에 알립니다. 현재 이 이벤트를 청취하거나 반응하는 다른 이벤트 프로세서는 없으므로 메시지는 사라지거나(이벤트 스트리밍의 경우) 무시됩니다. 겉보기에는 리소스 낭비 같지만 실제로는 그렇지 않습니다. 어느 날 회사가 고객에게 보낸 모든 이메일을 분석하기로 결정한다고 해 봅시다. 이메일 정보가 이미 email sent 파생 이벤트를 통해 제공되고 있으므로, 팀은 다른 이벤트 프로세서를 전혀 변경하지 않고 Email Analyzer 이벤트 프로세서를 추가해 전체 시스템을 손쉽게 확장할 수 있습니다.

<span id="page-18-0"></span>![](_page_18_Figure_0.jpeg)

그림 15-5. Notification 이벤트가 전송되지만 사용되지 않고 무시됨

## **비동기 역량**

이벤트 주도 아키텍처는 *Fire-and-Forget 처리*(응답이 필요 없음)와 *Request/Reply 처리*(응답이 필요한 경우[“요청-응답 처리”](#page-63-0) 참조) 모두에서 비동기 통신을 기본으로 활용한다는 점이 큰 특징입니다. 비동기 통신은 시스템 전체의 *반응성*을 높이는 강력한 기술이 될 수 있습니다.

[그림](#page-20-0) 15-6은 사용자가 웹사이트에 제품 리뷰를 등록하는 상황을 보여 줍니다. 이 예에서 댓글 서비스는 댓글을 검증하고 게시하는 데 3,000밀리초가 필요합니다. 댓글은 여러 파싱 엔진을 거쳐야 합니다. 욕설 검사를 통과해야 하고, "느린 사고"나 "명료하게 생각할 수 없음" 같은 모욕적인 문구가 없는지 확인해야 하며, 마지막으로 댓글이 실제로 제품과 관련 있는지를 확인하는 맥락 검사를 실시해야 합니다.

[그림](#page-20-0) 15-6의 상단 경로는 동기식 RESTful 호출을 통해 댓글을 게시합니다. 서비스가 댓글을 수신하는 데 50밀리초의 네트워크 지연이 필요하고, 댓글을 검증하고 게시하는 데 3,000밀리초, 그리고 댓글이 게시되었음을 사용자에게 알리는 데 또 50밀리초가 필요합니다. 따라서 사용자가 댓글을 게시하는 전체 시간은 3,100밀리초입니다. 이제 비동기 메시지를 사용하는 하단 경로를 살펴보세요. 이 경우 사용자가 댓글을 게시하는 데 체감하는 총 시간은 3,100밀리초가 아니라 25밀리초뿐입니다. 시스템은 여전히 댓글을 수신하는 데 25밀리초, 게시하는 데 3,000밀리초로 총 3,025밀리초가 필요하지만, 최종 사용자 관점에서는 시스템이 댓글을 받아들였다고 응답하기까지 25밀리초만 지나면 됩니다(댓글은 아직 게시되지 않았더라도 말이죠).

<span id="page-20-0"></span>![](_page_20_Figure_1.jpeg)

![](_page_20_Figure_2.jpeg)

그림 15-6. 동기식 통신과 비동기식 통신 비교

3,100밀리초와 25밀리초의 응답 시간 차이는 놀랍습니다. 하지만 한 가지 제약이 있습니다. 동기식 상단 경로에서는 최종 사용자가 자신의 댓글이 게시되었다는 *보장*을 받습니다. 비동기식 하단 경로에서는 댓글이 나중에 게시될 것이라는 약속과 함께 수신 확인만 받을 뿐입니다. 만약 사용자의 댓글에 욕설이 포함되어 있어 시스템이 이를 거부하면 어떻게 될까요? 최종 사용자에게 이를 알려줄 방법이 전혀 없을까요? 댓글을 게시하려면 웹사이트에 등록해야 한다면, 시스템은 사용자의 댓글에 문제가 있다는 메시지를 보내 해결 방법을 안내할 수 있습니다.

이 예는 *반응성*(사용자에게 정보를 돌려주는 데 필요한 시간)과 *성능*(댓글을 데이터베이스에 삽입하는 데 필요한 시간)의 차이를 잘 보여 줍니다. 사용자가 추가 정보를 필요로 하지 않는다면(확인이나 감사 메시지 정도만 필요하다면) 왜 기다려야 할까요? 반응성은 사용자의 요청이 접수되어 곧 처리될 것임을 알려 주는 데 초점을 맞추고, 성능은 엔드투엔드 프로세스를 더 빠르게 만드는 데 초점을 맞춥니다. 비동기식 하단 경로에서 아키텍트는 댓글 서비스가 댓글을 처리하는 방식을 최적화하지 않았습니다(이는 *반응성*에 해당합니다). 만약 아키텍트가 텍스트 및 문법 파싱 엔진을 병렬로 실행하거나 캐싱을 사용하는 등 다른 최적화 기법을 적용했지만 여전히 동기식 통신을 사용했다면, 이는 *전체 성능*을 개선하는 작업이 될 것입니다.

이 예는 단순하지만, 더 복잡한 사례도 살펴볼 수 있습니다. 이번에는 사용자가 비동기적으로 주식을 구매하는 *온라인 주식 거래*를 생각해 봅시다. 오류가 발생했는데 사용자를 알릴 방법이 없다면 어떻게 될까요?

비동기 통신은 반응성을 크게 개선하지만, 오류 처리는 큰 과제로 남습니다. 오류 상태를 다루기 어려울수록 이 아키텍처 스타일의 복잡성이 증가합니다. “[오류 처리](#page-51-0)”에서는 오류 처리 문제를 해결하는 반응형 아키텍처 패턴인 *워크플로 이벤트 패턴*을 소개합니다.

비동기 통신은 반응성이 뛰어날 뿐 아니라 동적 결합을 완화해 동기 통신 시 발생하는 *dynamische Quantenverschränkung (동적 양자 얽힘)*이라는 안티패턴을 피하는 데도 도움이 됩니다. [7장](#page--1-0)을 떠올려 보면, *architektonisches Quantum (아키텍처 퀀텀)*은 시스템의 나머지 부분과 독립적으로 배포될 수 있고 동기 동적 결합으로 묶이며, 아키텍처 특성이 퀀텀 수준에 존재한다는 점을 기억할 것입니다. 두 아키텍처 퀀텀이 서로에게 의존하게 되면 사실상 *얽히게* 되며, 이 의존 때문에 결국 하나의 아키텍처 퀀텀처럼 행동하게 됩니다. 비동기 통신은 이러한 동적 의존을 제거해 아키텍처 퀀텀을 분리하는 데 도움이 됩니다.

이 중요한 포인트를 보여 주기 위해 [그림](#page-23-0) 15-7의 두 시스템을 살펴봅니다. 이 예에서 Portfolio Management 시스템은 주식을 구매하기 위한 거래 주문을 생성합니다. 이 주문은 규정 준수 검사를 수행하고 거래 주문을 생성하는 Trade Order 시스템으로 동기식으로 전달됩니다. 두 시스템 간 통신이 동기식이므로, Portfolio Management 시스템은 Trade Order 시스템에서 거래 확인 번호를 받을 때까지 반드시 대기해야 합니다. 이 두 시스템은 얽혀 단일 아키텍처 퀀텀을 형성합니다.

<span id="page-23-0"></span>![](_page_23_Figure_2.jpeg)

그림 15-7. 동기식 동적 결합으로 인해 단일 아키텍처 퀀텀을 형성하는 시스템

이렇게 얽히면 아키텍처 특성이 두 시스템 *사이*에 존재하게 됩니다. Trade Order 시스템이 사용할 수 없거나 응답하지 않으면 Portfolio Management 시스템은 거래 주문을 제출할 수 없습니다. 이는 반응성을 저하시킵니다. Trade Order 시스템이 느리면 Portfolio Management 시스템의 응답도 느릴 것입니다. 확장성 역시 악영향을 받습니다. Portfolio Management 시스템을 확장해야 한다면 Trade Order 시스템도 함께 확장해야 하며, Trade Order 시스템을 확장할 수 없다면 Portfolio Management 시스템 역시 확장할 수 없습니다.

아키텍트는 [그림](#page-24-0) 15-8처럼 두 시스템 간 동기 호출을 비동기 호출로 바꿔 이 아키텍처 퀀텀을 분리할 수 있습니다.

<span id="page-24-0"></span>![](_page_24_Picture_2.jpeg)

그림 15-8. 비동기 동적 결합으로 인해 별개의 아키텍처 퀀텀을 형성하는 시스템

비동기 통신을 사용하면 Portfolio Management 시스템은 큐나 다른 비동기 수단을 통해 거래 주문을 전송할 수 있으며, Trade Order 시스템이 주문을 만들 때까지 기다릴 필요가 없습니다. Trade Order 시스템이 검사를 수행하고 거래 주문을 생성하면 별도의 비동기 채널을 통해 Portfolio Management 시스템에 확인 번호를 보낼 수 있습니다. 이렇게 두 시스템 간 동적 결합 의존을 제거하면 두 시스템은 각각 독립적인 아키텍처 퀀텀이 됩니다. Trade Order 시스템이 사용 불가능하거나 응답하지 않더라도 Portfolio Management 시스템은 거래 주문이 언젠가는 생성되어 확인 번호가 돌아올 것임을 알고 계속 주문을 제출할 수 있습니다.

## **브로드캐스트 역량**

EDA의 또 다른 독특한 특징은 어떤 다른 처리 단위가(있다면) 이벤트를 수신하고 이에 반응할지 전혀 알지 못한 채 이벤트를 브로드캐스트할 수 있다는 점입니다. [그림](#page-26-0) 15-9에서 보듯이 이러한 특성 덕분에 이벤트 프로세서 간 동적 결합이 해소됩니다.

![](_page_26_Figure_0.jpeg)

브로드캐스트 역량은 궁극적 일관성과 복잡 이벤트 처리(CEP)를 포함한 많은 패턴의 핵심 요소입니다. 예를 들어 주식 시장에서 거래되는 상품의 가격은 자주 변동합니다. 새로운 시세(특정 주식의 현재 가격)가 발표될 때마다 여러 이벤트 프로세서가 가격에 반응할 수 있습니다(거래 분석, 주식 매수/매도 등). 최신 시세를 게시하는 이벤트 프로세서는 이 정보가 어떻게 사용될지 알지 못한 채 단순히 브로드캐스트만 합니다. 이를 *semantische Entkopplung (의미적 디커플링)*이라고 부르는데, 이벤트 프로세서는 다른 이벤트 프로세서의 동작을 알거나 그에 의존하지 않기 때문입니다.

## <span id="page-27-0"></span>**이벤트 페이로드**

이벤트에 포함된 정보는 *페이로드*라고 합니다. 페이로드는 간단한 키-값 쌍부터 이후 처리에 필요한 모든 정보를 담은 복잡한 구조까지 매우 다양할 수 있습니다. 기본 유형은 *데이터 기반*과 *키 기반* 이벤트 페이로드 두 가지입니다. 아키텍트는 시스템에서 발행되는 각 이벤트에 대해 어떤 옵션이 적합한지 결정하기 위해 신중한 트레이드오프 분석을 수행해야 합니다. 이 절에서는 두 유형의 페이로드와 그에 따른 절충점을 설명합니다.

### **데이터 기반 이벤트 페이로드**

*데이터 기반 이벤트 페이로드*는 처리에 필요한 모든 정보를 함께 전달하는 페이로드입니다. [그림](#page-29-0) 15-10의 예에서 고객이 주문을 생성합니다. 먼저 Order Placement 이벤트 프로세서는 전체 주문을 데이터베이스(시스템 오브 레코드)에 삽입합니다. 그런 다음 주문의 모든 세부 정보를 포함한 order\_placed라는 이벤트를 발행합니다(이번 예에서는 45개의 속성에 총 500KB). Payment 이벤트 프로세서는 이 이벤트에 반응해 페이로드에서 주문 ID, 고객 정보, 총 비용을 추출해 결제를 처리합니다. 동시에 Inventory Management 이벤트 프로세서는 페이로드에서 품목 ID와 수량을 사용해 해당 품목의 현재 재고를 조정합니다.

<span id="page-29-0"></span>![](_page_29_Figure_0.jpeg)

그림 15-10. 데이터 기반 이벤트 페이로드가 전체 데이터를 전달함
Payment와 Inventory Management 이벤트 프로세서는 주문 정보를 얻기 위해 데이터베이스를 조회할 필요가 없었습니다. 데이터가 이미 이벤트 페이로드에 포함되어 있기 때문입니다. 이것이 데이터 기반 이벤트 페이로드를 사용하는 가장 큰 장점 중 하나입니다. 이벤트 프로세서가 데이터베이스를 조회하지 않을수록 성능, 반응성, 확장성이 향상됩니다. EDA는 매우 동적이고 디커플링되어 있으므로 Order Placement 이벤트 프로세서는 어떤 다른 이벤트 프로세서가 이벤트에 반응할지 혹은 처리에 필요한 데이터가 무엇인지 알지 못할 수 있습니다. 모든 정보를 이벤트 페이로드에 담으면, 어떤 이벤트 프로세서라도 자신에게 필요한 정보를 반드시 받을 수 있습니다. 특히 엄격히 제한된 컨텍스트나 도메인 기반, 데이터베이스 기반 토폴로지(“[데이터 토폴로지](#page-90-0)” 참조)에서는 이벤트 프로세서가 주문 정보를 담은 데이터베이스에 접근하지 못할 수도 있습니다.

이러한 장점 덕분에 더욱 반응성 높고 확장 가능하며 유연한 시스템을 만들 수 있지만, 데이터 기반 페이로드에는 몇 가지 단점도 있습니다. 첫째, *여러 데이터 시스템*을 보유하고 있다면 데이터 일관성과 무결성을 유지하기가 훨씬 더 어렵습니다. 모든 주문 데이터가 데이터베이스와 시스템 전체에서 발행되는 이벤트 양쪽에 존재하기 때문에, 특히 처리 중에 주문이 업데이트될 경우 데이터가 쉽게 일치하지 않을 수 있습니다.

예를 들어 고객이 실수로 1개 대신 100개의 품목을 주문했는데 주문 직후에 이를 눈치챘다고 해 봅시다. 혹은 주문 직후 잘못된 배송 주소를 입력했다는 사실을 깨닫는 경우도 있습니다(저자들도 자주 겪는 일입니다). 두 경우 모두 고객은 즉시 주문을 올바른 정보로 업데이트합니다. 데이터가 유일하게 보관되는 저장소인 데이터베이스에는 수정된 값이 들어가지만, 기존 값이 담긴 일부 이벤트는 즉시 처리되지 않을 수 있습니다. 이렇게 되면 나중에 처리되는 오래된 잘못된 값이 새롭게 정정된 값을 덮어써 버릴 가능성이 생깁니다. 게다가 EDA에서는 이벤트 타이밍을 제어하기가 매우 어렵기 때문에, 최신 값이 *오래된 값보다 먼저* 처리될 수도 있습니다. 그런 경우 다른 이벤트 프로세서가 이전 값을 사용하면 올바른 최신 값을 덮어쓰게 됩니다.

데이터 기반 이벤트 페이로드의 또 다른 큰 단점은 계약 관리와 버전 관리입니다. 이 시스템의 주문에는 45개의 속성이 있습니다. 모든 정보가 이벤트 페이로드에 포함되어 있으므로 이벤트에는 데이터를 구조화하는 일종의 *계약*이 필요합니다. 아키텍트는 이제 수많은 결정을 내려야 합니다. 페이로드 타입을 JSON 객체로 해야 할까요, 아니면 XML 객체로 해야 할까요? 계약을 엄격하게 유지할까요, 느슨하게 유지할까요? (*엄격한* 계약은 JSON 스키마, GraphQL 스펙, 클래스 정의 같은 스키마나 객체 정의를 이용하는 반면, *느슨한* 계약은 단순한 JSON 이름-값 쌍을 사용할 수 있습니다.) 각 결정은 다양한 트레이드오프를 동반하며, 이벤트 프로세서 간 강한 정적 결합을 만들어 냅니다.

그리고 버전 관리 문제도 있습니다. 엄격한 계약에서는 이벤트 헤더에 [벤더 MIME 타입](https://oreil.ly/gj4TZ)을 사용해 버전 번호를 표시할 수 있습니다. 이렇게 하면 시스템이 보다 애자일하게 변하면서 하위 호환성을 유지할 수 있습니다(다른 이벤트 프로세서가 새 버전을 처리할 준비가 될 때까지 이전 버전을 계속 수용할 수 있도록). 하지만 계약을 변경할 때마다 영향을 받는 모든 이벤트 프로세서가 함께 조정해야 하므로, 전체 시스템이 정적으로 결합될 위험이 있습니다.

### **키 기반 이벤트 페이로드**

*키 기반 이벤트 페이로드*는 처리에 필요한 데이터가 아닌, 필요한 데이터를 조회하는 데 사용할 수 있는 키만 포함합니다. [그림](#page-34-0) 15-11의 예에서는 order\_placed 이벤트 페이로드에 주문 ID만 포함되어 있습니다. Payment와 Inventory 이벤트 프로세서는 이 주문 ID를 사용해 데이터베이스에서 필요한 정보를 조회합니다. 이 방식은 간단한 JSON 키-값 쌍으로 표현될 수 있습니다.

```
{
  "event": "order_placed",
  "order_id": "123"
}
```

키 기반 이벤트 페이로드의 주요 단점 중 하나는 이벤트에 반응하는 모든 이벤트 프로세서가 주문을 처리하는 데 필요한 정보를 얻기 위해 데이터베이스를 조회해야 한다는 점입니다. 예를 들어 Payment 이벤트 프로세서가 이벤트에 반응하면 결제 처리를 위해 필요한 주문 정보를 조회해야 합니다. Inventory 이벤트 프로세서도 동시에 이벤트에 반응하면서 품목 ID와 수량을 얻기 위해 데이터베이스를 조회해야 합니다. 이는 반응성, 성능, 확장성을 저하시킬 수 있으며, 특히 EDA처럼 고도로 병렬적이고 비동기적인 아키텍처에서는 데이터베이스에 큰 부담을 줄 수 있습니다(이 위험을 줄이는 방법은 “[데이터 토폴로지](#page-90-0)” 참조). 필요한 데이터에 접근하기 어렵다면(예: 다른 이벤트 프로세서의 제한된 컨텍스트 안에 있다면) 키 기반 페이로드는 큰 도전 과제가 됩니다. [그림](#page-38-0) 15-12는 이 접근 방식을 보여 줍니다.

<span id="page-38-0"></span>![](_page_38_Picture_0.jpeg)

그림 15-12. 키 기반 페이로드에는 컨텍스트 키만 포함됨

하지만 키 기반 이벤트 페이로드에는 성능과 확장성 문제를 상쇄할 수 있는 다양한 장점도 많습니다. 첫째, 데이터 일관성과 무결성이 전반적으로 더 뛰어납니다. 데이터가 *하나의 시스템 오브 레코드*에만 존재하기 때문입니다. 이벤트에 포함된 데이터가 데이터베이스 하나뿐이므로, 키 기반 페이로드는 데이터 기반 페이로드보다 처리 중 데이터 변경을 훨씬 쉽게 다룰 수 있습니다.

둘째, 키 기반 이벤트 페이로드의 계약은 매우 단순하고 거의 변하지 않으므로, 아키텍트는 보통 느슨하고 스키마 없는 JSON 또는 XML 파일로 구현합니다. 따라서 데이터 기반 페이로드에서 흔히 발생하는 계약 변경 관리, 버전 관리, 커뮤니케이션·사용 중단 전략 문제를 겪지 않습니다.

셋째, 키 기반 이벤트 페이로드는 데이터 기반 페이로드처럼 스탬프 결합과 대역폭 문제에 시달리지 않습니다. 이벤트와 함께 불투명한 데이터가 전달되지 않으므로 계약이 작고 단순하며 대역폭 요구도 낮습니다. 덕분에 네트워크와 메시지 브로커 관점에서 보면 데이터 기반 페이로드보다 빠른 경우가 많습니다.

### **트레이드오프 요약**

데이터 기반 이벤트 페이로드와 키 기반 페이로드 사이를 선택할 때는 신중한 트레이드오프 분석이 필요합니다. 이 선택은 전부 아니면 전무가 아니라는 점을 기억하세요. 이벤트 종류마다 서로 다른 페이로드 유형을 사용할 수 있습니다. [표](#page-40-0) 15-1은 두 유형의 페이로드와 관련된 트레이드오프를 요약합니다.

<span id="page-40-0"></span>표 15-1. 데이터 기반 vs. 키 기반 이벤트 페이로드

| 기준                                           | 데이터 기반 페이로드 | 키 기반 페이로드 |
|-----------------------------------------------|----------------------|------------------|
| 성능 및 확장성                                 | 우수                 | 미흡             |
| 계약 관리                                      | 미흡                 | 우수             |
| 스탬프 결합                                    | 미흡                 | 우수             |
| 대역폭 사용량                                   | 미흡                 | 우수             |
| 제한된 데이터베이스 접근                       | 우수                 | 미흡             |
| 시스템 전반의 취약성                           | 미흡                 | 우수             |

결국 이 둘 사이의 트레이드오프는 확장성과 성능 대 계약 관리·대역폭 사용 사이의 균형 문제입니다. 각 이벤트마다 어떤 요소가 더 중요한지 스스로에게 물어보세요. 어떤 이벤트 처리에는 극단적인 확장성과 성능이 필요할 수 있으며, 이 경우 데이터 기반 페이로드가 적합합니다. 반대로 이벤트 처리 데이터가 자주 변경된다면 키 기반 페이로드가 더 나은 선택일 수 있습니다.

소프트웨어 아키텍처의 대부분의 결정과 마찬가지로, 아키텍트의 선택은 단순한 이진 값이 아니라 스펙트럼을 이룹니다. 따라서 다음 절에서 살펴볼 *빈혈 이벤트*를 피하도록 주의해야 합니다.
### **빈혈 이벤트**

키 기반 페이로드를 사용할 때는 이벤트에 필요한 모든 정보를 포함하지 않아 *빈혈 이벤트*가 되는 상황을 피해야 합니다. [그림](#page-43-0) 15-13의 예에서 고객은 성과 이름, 이메일 주소, 전화번호, 주소를 한 번에 업데이트합니다. 세 개의 이벤트 프로세서가 이러한 변경 사항에 반응해야 합니다.

- 서비스 1은 새 이름과 이메일 주소를 사용해 감사 기록을 생성해야 합니다.
- 서비스 2는 고객의 새 이메일 도메인에 따라 구독 티어를 업그레이드해야 할 수도 있습니다.
- 서비스 3은 고객의 새 주소가 특정 도시인지 확인해 현지 프로모션을 진행해야 합니다.

하지만 이벤트 페이로드에는 profile\_updated 같은 키만 포함되어 있으므로, 각 서비스는 데이터가 무엇으로 바뀌었는지 알기 위해 데이터베이스를 조회해야 합니다. 특히 서비스 2와 서비스 3은 변경 전 값이 무엇이었는지 모르는 상태에서 추가 처리를 해야 하므로 곤란에 빠집니다. 필요한 정보가 충분하지 않기 때문에 이러한 이벤트를 *빈혈 이벤트*라고 부릅니다.

이런 문제를 피하려면 대부분의 데이터베이스가 이전 값을 쉽게 제공하지 않는다는 점을 고려해, 업데이트된 고객 정보 *뿐만 아니라 이전 값*도 이벤트에 포함해야 합니다.

이는 이벤트 페이로드 세분화의 *스펙트럼*을 보여 주는 예입니다. 스펙트럼의 극단적인 왼쪽에는 키 기반 페이로드가 있어 이벤트에 키만 포함합니다. 주문 생성이나 삭제 상황에서는 괜찮지만, 고객이 주문을 업데이트하는 상황에서는 적절하지 않습니다. 반대쪽 극단에는 필요 여부와 상관없이 *모든* 데이터를 포함하는 데이터 기반 페이로드가 있어 스탬프 결합 문제를 야기할 수 있습니다. 고객 프로필 업데이트 시나리오는 이 두 극단 사이 어딘가에 위치하며, 필요한 만큼의 정보만 제공해 빈혈 이벤트 문제를 피합니다.

<span id="page-43-0"></span>![](_page_43_Figure_0.jpeg)

그림 15-13. 이벤트를 처리하기에 충분한 컨텍스트가 없는 빈혈 이벤트
## <span id="page-44-0"></span>**모기 떼 안티패턴**

빈혈 이벤트와 관련된 또 다른 안티패턴은 *모기 떼(Swarm of Gnats)*입니다. 따가운 모기 떼가 머리 주변을 맴돌며 햇볕 좋은 날에도 집 안으로 들어가게 만드는 것처럼, 이 안티패턴은 시스템 전체를 귀찮게 만듭니다. 빈혈 이벤트가 이벤트 *페이로드*의 세분성과 관련되어 있다면, 모기 떼 안티패턴은 이벤트 프로세서가 발생시키는 파생 이벤트 *자체*의 세분성과 관련이 있습니다. 하나의 이벤트 프로세서가 너무 많은 파생 이벤트를 발행하면 모기 떼에 갇힐 위험이 있습니다.

[그림](#page-46-0) 15-14의 신용카드 결제 예를 살펴봅시다. 고객이 주문을 제출하고 신용카드로 결제하면 Payment 이벤트 프로세서가 payment applied 이벤트를 발행합니다. 다행히 Fraud Detection 이벤트 프로세서는 이 이벤트를 청취합니다. 이 프로세서는 모든 결제 건을 분석해 합법적인지 사기인지 판단하며, 그 결과를 담은 fraud\_checked 파생 이벤트를 발행합니다.

<span id="page-46-0"></span>![](_page_46_Figure_0.jpeg)

그림 15-14. 너무 거친 파생 이벤트 예시

신용카드 사기 여부에 관심이 있는 이벤트 프로세서는 세 가지입니다.

- 사기를 감지하면 Credit Card Locking 이벤트 프로세서가 해당 카드의 추가 청구를 차단합니다.
- Customer Notify 이벤트 프로세서는 고객에게 잠재적 사기 가능성을 알립니다.
- 사기가 *발견되지 않은* 경우 Purchase Profile 이벤트 프로세서가 자신의 알고리즘을 업데이트합니다.

문제는 fraud\_checked라는 단 하나의 파생 이벤트만 발행된다는 점입니다. 세 이벤트 프로세서는 모두 이 이벤트를 수신해 페이로드를 검사하고 자신이 조치를 취해야 하는지 판단해야 합니다. 파생 이벤트가 너무 거칠기 때문에 각 프로세서는 추가 처리를 수행해야 하며, 일부 프로세서(예: Purchase Profile 제외)는 실제로 아무 작업도 하지 않으면서도 리소스를 소비합니다.

더 효율적인 접근 방식은 [그림](#page-48-0) 15-15처럼 fraud\_detected와 no\_fraud\_detected라는 *두 개의* 파생 이벤트를 발행하는 것입니다. 이렇게 하면 Fraud Detection 이벤트 프로세서가 페이로드 외부의 컨텍스트를 제공하여, 각 이벤트 프로세서가 이벤트 내부의 세부 정보를 분석하지 않고도 자신이 대응해야 하는지를 판단할 수 있습니다.

<span id="page-48-0"></span>![](_page_48_Figure_0.jpeg)

그림 15-15. 파생 이벤트를 세분화해 모기 떼 안티패턴을 피함

한편, [그림](#page-49-0) 15-16은 또 다른 극단적인 사례를 보여 줍니다. 고객이 프로필을 업데이트하면 Customer Profile 이벤트 프로세서는 데이터베이스를 업데이트하고 각 변경 사항마다 별도의 이벤트를 발행합니다. 이는 시스템 전체에 동일한 사실(고객이 프로필을 업데이트했다)을 알리는 수많은 파생 이벤트를 퍼뜨립니다. 또한 다른 이벤트 프로세서에서도 작은 파생 이벤트가 잇따라 발생해 전체 이벤트 흐름을 이해하기 어렵게 만듭니다.

<span id="page-49-0"></span>![](_page_49_Figure_1.jpeg)

그림 15-16. 너무 미세한 파생 이벤트를 발행하면 모기 떼가 된다

이 패턴을 피하기 위해 아키텍트는 모든 프로필 변경을 하나의 profile\_updated 파생 이벤트 안에 묶고, 업데이트된 필드의 전/후 값을 포함시킬 수 있습니다. [그림](#page-50-0) 15-17에서 보듯이, 이렇게 하면 모기 떼 안티패턴을 피하면서도 필요한 정보를 한 번에 전달할 수 있습니다.

<span id="page-50-0"></span>![](_page_50_Figure_2.jpeg)

그림 15-17. 개별 상태 변경을 하나의 파생 이벤트로 결합해 모기 떼를 방지함

파생 이벤트에 적절한 세분성을 부여하는 일은 상당히 어렵습니다. 우리는 처리 결과나 상태 변경의 *결말*에 집중해 모기 떼를 피하고 이벤트 흐름을 단순화하라고 권장합니다.
## <span id="page-51-0"></span>**오류 처리**

반응형 아키텍처의 워크플로 이벤트 패턴은 비동기 워크플로에서 오류를 처리하는 한 가지 방법입니다. 이 패턴은 비동기 오류를 처리하면서도 시스템 반응성을 유지하도록 내결함성과 반응성 모두를 목표로 합니다.

워크플로 이벤트 패턴은 [그림](#page-53-0) 15-18처럼 *워크플로 대리자*를 사용해 위임, 격리, 복구를 수행합니다. 이벤트 프로세서는 데이터를 비동기적으로 메시지 채널을 통해 이벤트 소비자에게 전달합니다. 데이터 처리 중 오류가 발생하면 이벤트 소비자는 즉시 해당 오류를 Workflow Processor 서비스에 위임하고, 이벤트 큐의 다음 메시지를 처리하기 시작합니다. 이렇게 하면 다음 메시지가 즉시 처리되어 전체 반응성이 유지됩니다. 이벤트 소비자가 오류를 해결하느라 시간을 보내면 큐에 있는 다음 메시지를 처리하지 못해, 해당 메시지뿐 아니라 큐에 있는 다른 모든 메시지도 지연됩니다.

Workflow Processor 서비스가 오류를 받으면 메시지에 어떤 문제가 있는지 파악하려고 시도합니다. 고정된 결정론적 오류일 수도 있고, 머신러닝이나 인공지능 알고리즘을 사용해 데이터의 이상 징후를 분석해야 할 수도 있습니다. 어떤 경우든 Workflow Processor는 *프로그래밍 방식*으로(즉, 사람의 개입 없이) 원본 데이터를 수정해 문제를 해결하고, 수정된 메시지를 원래 큐로 되돌립니다. 이벤트 소비자는 업데이트된 메시지를 새 메시지처럼 받아 다시 처리하며, 이번에는 성공하기를 기대합니다.

물론 Workflow Processor가 항상 문제를 파악해 해결할 수 있는 것은 아닙니다. 이때는 메시지를 다른 큐로 보내고, 숙련된 운영자가 사용하는 대시보드로 전달합니다. 운영자는 메시지를 검토한 뒤 수동으로 수정하고, reply-to 메시지 헤더 변수 등을 사용해 다시 원본 큐로 보냅니다.

<span id="page-53-0"></span>![](_page_53_Picture_0.jpeg)

그림 15-18. 반응형 아키텍처의 워크플로 이벤트 패턴

예를 들어 한 지역의 투자 자문가가 다른 지역의 대형 증권사를 대신해 *거래 지시*를 수신한다고 합시다. 자문가는 이러한 지시를 *장바구니*로 묶어 다른 지역의 중개인에게 비동기적으로 보냅니다. 거래 지시 계약은 다음 조건을 만족해야 한다고 가정합니다.

```
<trade>
  <acct_no>mandatory, number</acct_no>
  <action>mandatory, string, BUY or SELL</action>
  <ticker>mandatory, string</ticker>
  <quantity>mandatory, positive integer</quantity>
</trade>
```

그러나 실제 입력은 다음과 같이 들어올 수 있습니다.

```
12654A87FR4,BUY,AAPL,1254
87R54E3068U,BUY,AAPL,3122
6R4NB7609JJ,BUY,AAPL,5433
2WE35HF6DHF,BUY,AAPL,8756 SHARES
764980974R2,BUY,AAPL,1211
1533G658HD8,BUY,AAPL,2654
```

네 번째 거래 지시(2WE35HF6DHF,BUY,AAPL,8756 SHARES)는 주식 수량 뒤에 SHARES라는 단어가 붙어 있습니다. 기본 시스템이 오류 처리 없이 이 비동기 거래를 처리하면 TradePlacement 서비스에서 다음과 같은 예외가 발생합니다.

```
Exception in thread "main" java.lang.NumberFormatException:
        For input string: "8756 SHARES"
        at java.lang.NumberFormatException.forInputString
        (NumberFormatException.java:65)
        at java.lang.Long.parseLong(Long.java:589)
        at java.lang.Long.<init>(Long.java:965)
        at trading.TradePlacement.execute(TradePlacement.java
        at trading.TradePlacement.main(TradePlacement.java:29
```

비동기 요청인 만큼 이 예외가 발생해도 오류를 바로 수정해 줄 사용자가 없습니다. TradePlacement 서비스는 오류 상태를 기록하는 것 외에는 할 수 있는 일이 없습니다.

워크플로 이벤트 패턴을 적용하면 이 오류를 프로그램적으로 해결할 수 있습니다. 기본 증권사는 투자 자문가나 그가 보낸 데이터에 대한 통제권이 없으므로 스스로 반응해 오류를 수정해야 합니다([그림](#page-57-0) 15-19 참조). 동일한 오류(2WE35HF6DHF,BUY,AAPL,8756 SHARES)가 발생하면 TradePlacement 서비스는 즉시 Trade Placement Error 서비스에 오류 복구를 위임하고, 예외 세부 정보를 함께 보냅니다.

```
Trade Placed: 12654A87FR4,BUY,AAPL,1254
Trade Placed: 87R54E3068U,BUY,AAPL,3122
Trade Placed: 6R4NB7609JJ,BUY,AAPL,5433
Error Placing Trade: "2WE35HF6DHF,BUY,AAPL,8756 SHARES"
Sending to trade error processor <-- delegate the error fixing
Trade Placed: 764980974R2,BUY,AAPL,1211
...
```

워크플로 대리자인 Trade Placement Error 서비스는 오류를 수신해 예외를 확인합니다. 문제는 수량 필드에 SHARES라는 단어가 포함된 데 있다는 사실을 알아냅니다. Trade Placement Error 서비스는 SHARES라는 단어를 제거하고 거래를 재처리하도록 다시 보냅니다.

```
Received Trade Order Error: 2WE35HF6DHF,BUY,AAPL,8756 SHARES
Trade fixed: 2WE35HF6DHF,BUY,AAPL,8756
Resubmitting Trade For Re-Processing
```

이제 TradePlacement 서비스는 수정된 거래를 정상적으로 처리할 수 있습니다.

```
...
trade placed: 1533G658HD8,BUY,AAPL,2654
trade placed: 2WE35HF6DHF,BUY,AAPL,8756 <-- previously failed
```

<span id="page-57-0"></span>![](_page_57_Figure_0.jpeg)

그림 15-19. 워크플로 이벤트 패턴을 사용한 오류 처리

워크플로 이벤트 패턴을 사용하면 오류가 워크플로 프로세서에 전달되고 다시 제출되기 때문에 메시지가 원래 순서대로 처리되지 않을 수 있다는 점을 염두에 두어야 합니다. 거래 예에서처럼 특정 계정 내 모든 거래가 올바른 순서로 처리되어야 한다면(예: 동일한 계정에서는 IBM 매도가 AAPL 매수보다 먼저 처리되어야 함), 순서 보장을 구현해야 합니다. 한 가지 방법은 TradePlacement 서비스가 오류가 발생한 거래의 계정 번호를 큐에 저장해 두고, 동일한 계정 번호를 가진 거래를 임시 큐에 FIFO 순서로 저장해 두었다가 오류가 수정되고 처리되면 남은 거래를 다시 처리하는 것입니다.
## **데이터 손실 방지**

비동기 통신을 다루는 아키텍트는 항상 *데이터 손실* 위험에 직면합니다. 이벤트나 메시지가 손실되거나 목적지에 도달하지 못하는 상황입니다. 다행히 데이터 손실을 막을 수 있는 기본 기법이 있습니다.

이벤트 채널은 다양한 방식으로 구현할 수 있습니다. 대부분의 이벤트 주도 아키텍처는 [Advanced Message Queuing Protocol(AMQP)](https://oreil.ly/X3Dl7)을 사용해 이벤트를 발행하고 구독합니다. Amazon SNS(Simple [Notification Service](https://aws.amazon.com/pm/sns)), [RabbitMQ](https://oreil.ly/XLNKs), [Solace](https://solace.com/), [Azure Event Hubs](https://oreil.ly/b2Lzw)가 대표적인 AMQP 브로커입니다. AMQP에서는 이벤트가 익스체인지에 게시되고, 소비자 이벤트 프로세서가 설정한 바인딩 규칙에 따라 해당 이벤트를 구독한 각 프로세서의 큐로 전달됩니다. AMQP 브로커는 본 절에서 설명하는 *이벤트 전달(Event Forwarding) 패턴*을 사용해 데이터 손실을 방지할 수도 있습니다.

다른 이벤트 채널 구현으로는 Jakarta Messaging API(구 Java Message Service, JMS)가 있습니다. JMS는 큐의 2단계 전달 과정 대신 *토픽*을 사용합니다. 그럼에도 Jakarta Messaging은 이벤트 소비자를 *영구 구독자*로 구성할 경우 이벤트 전달 패턴을 활용해 데이터 손실을 막을 수 있습니다. *영구 구독자*는 이벤트를 반드시 수신하는 구독자를 의미합니다. 이벤트 프로세서가 다운되거나 사용할 수 없으면 JMS 토픽은 프로세서가 다시 돌아올 때까지 이벤트를 저장합니다.

또 다른 구현은 [Kafka](https://kafka.apache.org/) 같은 *이벤트 브로커*를 사용하는 이벤트 스트리밍입니다. 이벤트 스트리밍에서 데이터 손실을 방지하는 방법은 본 절에서 설명하는 이벤트 전달 패턴과 크게 다릅니다. Kafka 웹사이트에서 이 유형의 스트리밍 이벤트 브로커를 사용할 때 데이터 손실을 방지하는 방법을 자세히 확인할 수 있습니다.

이제 일반적인 시나리오를 살펴보겠습니다. 이벤트 프로세서 A가 메시지 브로커에 이벤트를 비동기적으로 발행하면 이벤트는 AMQP 큐나 JMS 토픽으로 전달됩니다. 이벤트 프로세서 B는 이벤트에 반응해 페이로드의 데이터를 데이터베이스에 저장합니다. [그림](#page-61-0) 15-20에 표시했듯이 이 시나리오에서는 세 가지 방식으로 데이터가 손실될 수 있습니다.

1. 이벤트 프로세서 A가 이벤트를 발행하는 중에 브로커 확인 응답을 받기 전에 장애가 발생할 수 있습니다. 혹은 브로커가 A에게 확인을 보낸 뒤, 다른 이벤트 프로세서가 이벤트를 수신하기 전에 브로커가 장애를 일으킬 수도 있습니다.
2. 이벤트 프로세서 B가 큐에서 이벤트를 꺼낸 뒤 처리하기 전에 장애가 발생할 수 있습니다.
3. 이벤트 프로세서 B가 데이터 오류 때문에 메시지를 데이터베이스에 저장하지 못할 수 있습니다.

*이벤트 전달 패턴*을 사용하면 이러한 각 지점을 완화할 수 있습니다.

<span id="page-61-0"></span>![](_page_61_Picture_0.jpeg)

그림 15-20. 이벤트 주도 아키텍처에서 데이터가 손실될 수 있는 지점

첫 번째 경우에는 이벤트가 큐에 도달하지 못하거나, 브로커가 이벤트를 읽기 전에 장애가 발생합니다. 이를 방지하려면 *내구성 큐*와 *동기 전송*을 사용해야 합니다. 내구성 큐는 *보장된 전달*을 제공합니다. 이벤트 브로커가 이벤트를 수신하면 빠른 검색을 위해 메모리에 보관할 뿐 아니라, 파일 시스템이나 데이터베이스 같은 물리적 저장소에 이벤트를 저장합니다. 브로커가 다운되더라도 이벤트는 디스크에 남아 있어, 브로커가 재시작되면 여전히 처리할 수 있습니다. *동기 전송*을 사용하면 브로커가 이벤트를 데이터베이스에 저장했다고 확인하기 전까지 이벤트 프로세서가 블록되어 이벤트를 발행하지 않습니다. 이 두 가지 기본 기법을 사용하면 이벤트가 프로듀서 쪽에 남아 있거나 큐에 영구 저장되므로 프로듀서와 큐 사이에서 데이터가 손실되지 않습니다.

두 번째 문제는 이벤트 프로세서 B가 큐에서 이벤트를 꺼낸 뒤 처리 전에 장애가 발생하는 상황입니다. *클라이언트 확인(Client Acknowledge) 모드*라는 기본 메시징 기법을 사용하면 해결할 수 있습니다. 이벤트가 큐에서 읽히면 기본적으로 즉시 큐에서 제거되는데(이를 *자동 확인 모드*라고 함), 클라이언트 확인 모드에서는 이벤트가 큐 안에 남아 있으며, 다른 소비자가 동일한 이벤트를 읽지 못하도록 클라이언트 ID가 붙습니다. 이벤트 프로세서 B가 장애를 일으키면 이벤트는 큐에 남아 있으므로 메시지가 손실되지 않습니다.

세 번째 문제는 이벤트 프로세서 B가 데이터 오류로 인해 이벤트를 데이터베이스에 저장하지 못하는 상황입니다. 이때는 데이터베이스 커밋을 포함하는 ACID 트랜잭션을 사용하면 됩니다. 이벤트 프로세서가 커밋을 실행하면 데이터가 데이터베이스에 영구 저장됩니다. 이후 *마지막 참가자 지원(LPS, last participant support)*이 모든 처리가 완료되어 이벤트가 영구적으로 저장되었음을 확인하고 큐에서 해당 이벤트를 제거합니다. 이렇게 하면 이벤트가 이벤트 프로세서 A에서 데이터베이스로 이동하는 동안 사라지지 않습니다. 이 기술은 [그림](#page-63-1) 15-21에 나와 있습니다.

<span id="page-63-1"></span>![](_page_63_Picture_1.jpeg)

그림 15-21. 이벤트 주도 아키텍처에서 데이터 손실 방지
## <span id="page-63-0"></span>**요청-응답 처리**

지금까지는 이벤트 소비자에게 즉각적인 응답이 필요 없는 비동기 요청만 살펴봤습니다. 그렇다면 다른 이벤트 프로세서에게 즉시 정보를 받아야 하는 상황—예를 들어 확인 ID나 승인 응답을 받아야만 다음 이벤트를 발행할 수 있는 경우—에는 어떻게 해야 할까요? 이러한 경우 요청을 완료하려면 동기식 통신이 필요합니다.

EDA에서는 보통 *요청-응답 메시징*(혹은 *유사 동기식 통신*)으로 동기식 통신을 구현합니다. 요청-응답 채널은 *요청 큐*와 *응답 큐* 두 개의 큐로 구성됩니다. 최초 요청을 보내는 메시지 프로듀서는 데이터를 요청 큐로 비동기 전송한 뒤 제어권을 돌려받습니다. 이후 다른 작업을 수행하다가 응답 큐에서 응답을 기다립니다. 메시지 컨슈머는 메시지를 받아 처리한 뒤 응답 큐로 응답을 보냅니다. 메시지 프로듀서는 응답 데이터를 포함한 메시지를 받습니다. 기본 흐름은 [그림](#page-65-0) 15-22에 나와 있습니다.

<span id="page-65-0"></span>![](_page_65_Picture_1.jpeg)

그림 15-22. 요청-응답 메시징 처리

요청-응답 메시지를 구현하는 대표적인 방법은 두 가지입니다. 첫 번째이자 가장 널리 사용되는 방법은 응답 메시지 헤더에 *상관관계 ID 필드*(CID)를 추가해 원본 요청 메시지 ID를 기록하는 것입니다. [그림](#page-67-0) 15-23에서 ID라고 표시된 값이 바로 그것입니다. 흐름은 다음과 같습니다.

1. 이벤트 프로듀서는 요청 큐에 메시지를 보내고 고유한 메시지 ID(예: 124)를 기록합니다. 이때 CID는 null입니다.
2. 이벤트 프로듀서는 메시지 필터(또는 *메시지 셀렉터*)를 사용해 응답 큐에서 CID가 원본 메시지 ID(124)인 메시지를 기다립니다. 응답 큐에는 CID 120인 ID 855 메시지와 CID 122인 ID 856 메시지가 있지만, 둘 다 찾는 값(124)과 일치하지 않으므로 가져오지 않습니다.
3. 이벤트 컨슈머가 메시지(ID 124)를 수신해 요청을 처리합니다.
4. 이벤트 컨슈머는 응답을 생성하고 응답 메시지 헤더의 CID를 원본 메시지 ID(124)로 설정합니다.
5. 이벤트 컨슈머는 새 메시지 ID(예: 857)를 응답 큐에 보냅니다.
6. 이벤트 프로듀서는 CID가 124인 메시지를 필터링하고 응답을 수신합니다.

<span id="page-67-0"></span>![](_page_67_Picture_0.jpeg)

그림 15-23. 상관관계 ID를 사용한 요청-응답 처리

두 번째 방법은 *임시 큐*를 응답 큐로 사용하는 것입니다. 임시 큐는 특정 요청에 전용으로 만들어졌다가 요청이 끝나면 삭제됩니다. [그림](#page-69-0) 15-24와 같이, 임시 큐는 해당 요청을 보낸 이벤트 프로듀서만 알고 있으므로 상관관계 ID가 필요 없습니다. 흐름은 다음과 같습니다.

1. 이벤트 프로듀서는 임시 큐를 생성하고(혹은 브로커가 자동 생성) 요청 큐에 메시지를 보내며 Reply-to 헤더(또는 협의된 다른 사용자 정의 헤더)에 임시 큐 이름을 기록합니다.
2. 이벤트 프로듀서는 임시 응답 큐에서 블로킹 상태로 기다립니다. 이 큐에 들어오는 메시지는 해당 프로듀서만 사용할 수 있으므로 메시지 셀렉터가 필요 없습니다.
3. 이벤트 컨슈머는 요청을 처리한 뒤 Reply-to 헤더에 지정된 임시 큐로 응답 메시지를 보냅니다.
4. 이벤트 프로듀서는 응답을 수신하고 임시 큐를 삭제합니다.

<span id="page-69-0"></span>![](_page_69_Figure_0.jpeg)

그림 15-24. 임시 큐를 사용한 요청-응답 처리

임시 큐 기법은 구현이 훨씬 간단하지만, 브로커가 각 요청마다 임시 큐를 만들고 즉시 삭제해야 하므로 브로커가 느려질 수 있고 높은 메시지량과 동시성이 요구되는 환경에서는 전체 성능과 반응성이 저하될 수 있습니다. 이런 이유로 우리는 일반적으로 상관관계 ID 기법을 권장합니다.
### <span id="page-70-0"></span>**중재형 이벤트 주도 아키텍처**

지금까지 이 장에서는 여러 이벤트 프로세서가 브로드캐스트된 이벤트에 반응하는 *안무형* EDA에 초점을 맞췄습니다. 하지만 아키텍트가 이벤트 처리 과정을 더 강력하게 제어하고 싶을 때도 있습니다. 이 경우 *중재자(Mediator)* 토폴로지라고 부르는 *오케스트레이션된* 형태의 EDA를 사용할 수 있습니다.

*중재자 토폴로지*는 지금까지 살펴본 표준 안무형 EDA 토폴로지의 한계를 보완합니다. 핵심에는 여러 이벤트 프로세서를 조율해야 하는 트리거 이벤트의 워크플로를 관리·제어하는 *이벤트 중재자*가 있습니다. 중재자 토폴로지를 구성하는 아키텍처 요소는 트리거 이벤트, 이벤트 큐, 이벤트 중재자, 이벤트 채널, 이벤트 프로세서입니다.

중재자 토폴로지는 일반적으로 *이벤트*가 아니라 *메시지*(“[이벤트 대 메시지](#page-11-0)” 참조)를 사용한다는 점이 중요합니다. 보통 ship\_order 같은 명령 메시지이며, order\_shipped와 같은 이미 발생한 이벤트는 아닙니다.

안무형 토폴로지처럼 전체 프로세스는 트리거 이벤트에서 시작됩니다. 하지만 [그림](#page-73-0) 15-25에서처럼 중재자 토폴로지에서는 이벤트 중재자가 트리거 이벤트를 수신합니다. 중재자는 해당 이벤트를 처리하는 데 필요한 단계만 알고 있으며, 이에 따라 파생 메시지를 생성해 지점 간 전송을 위한 전용 메시지 채널(보통 큐)에 보냅니다. 이벤트 프로세서는 각각 할당된 채널을 청취하고 메시지를 처리한 뒤(대부분) 작업이 끝나면 중재자에게 알립니다. 중재자 토폴로지의 이벤트 프로세서는 자신의 작업을 추가 파생 메시지로 시스템에 알리지 않습니다.

대부분의 중재자 토폴로지 구현에는 여러 중재자가 존재하며, 각 중재자는 특정 도메인이나 이벤트 그룹과 연관됩니다. 이는 단일 실패 지점을 피하고 전체 처리량과 성능을 향상하는 데 도움이 됩니다. 예를 들어 고객 중재자는 신규 가입, 프로필 업데이트 등 고객 관련 이벤트를 처리하고, 주문 중재자는 장바구니 추가, 체크아웃 등 주문 관련 활동을 처리할 수 있습니다.

이벤트 중재자를 어떻게 구현할지는 처리해야 할 메시지의 유형과 복잡도에 따라 달라집니다. 단순한 오류 처리와 오케스트레이션만 필요하다면 [Apache Camel](https://camel.apache.org/), [Mule ESB](https://mulesoft.com/), Spring [Integration](https://oreil.ly/r2e4r) 같은 중재자가 적합합니다. 이러한 중재자에서는 메시지 흐름과 라우팅을 대개 Java나 C# 같은 프로그래밍 코드로 작성합니다.

반면 조건부 처리와 복잡한 오류 처리가 필요한 여러 동적 경로를 다뤄야 한다면 [Apache ODE](https://ode.apache.org/)나 Oracle BPEL Process [Manager](https://oreil.ly/jMtta) 같은 중재자가 더 적합합니다. 이들은 BPEL(Business Process Execution Language)이라는 [XML 유사 언어](https://oreil.ly/Uu-Fo)를 기반으로 하며, 이벤트 처리 단계를 정의하고 오류 처리, 리디렉션, 멀티캐스팅 등을 위한 구조화된 요소를 제공합니다. BPEL은 강력하지만 배우기 어려운 언어이므로, 아키텍트는 대체로 BPEL 엔진이 제공하는 GUI 도구를 사용해 중재자를 구성합니다.

<span id="page-73-0"></span>![](_page_73_Picture_0.jpeg)

그림 15-25. 중재자 토폴로지

BPEL은 복잡하고 동적인 워크플로에는 적합하지만, 사람이 개입해야 하는 장시간 워크플로에는 적합하지 않습니다. 예를 들어 place\_trade라는 트리거 이벤트로 거래를 생성했는데, 처리 중 일정 수 이상의 주식 거래는 수동 승인이 필요하다는 사실이 밝혀졌다고 합시다. 중재자는 이벤트 처리를 중단하고 숙련된 트레이더에게 승인 요청을 보낸 뒤 응답을 기다려야 합니다. 이런 경우에는 이벤트 중재자 대신 [jBPM](https://jbpm.org/) 같은 BPM 엔진이 더 나은 선택입니다.

따라서 이벤트 중재자를 선택하기 전에 어떤 유형의 이벤트를 처리할 것인지 파악하는 것이 중요합니다. 사람의 개입이 필요한 복잡하고 장기적인 이벤트를 Apache Camel로 처리하려 하면 관리와 유지보수가 매우 어렵습니다. 반대로 단순한 이벤트 흐름에 BPM 엔진을 사용하면 몇 달간 불필요한 작업을 하게 될 것입니다.

실제로 모든 이벤트가 정확히 하나의 복잡도 카테고리에 속하는 경우는 드뭅니다. 우리는 이벤트를 단순·중간·복잡으로 분류한 뒤, 각 이벤트를 Apache Camel이나 Mule 같은 간단한 중재자를 거치게 하라고 권장합니다. 단순 중재자는 이벤트를 직접 처리하거나, 복잡도에 따라 다른 중재자(BPEL 또는 BPM)에 위임할 수 있습니다. [그림](#page-76-0) 15-26에 나온 중재자 위임 모델은 모든 이벤트가 가장 효과적으로 처리될 수 있도록 보장합니다.

![](_page_76_Figure_0.jpeg)

[그림](#page-76-0) 15-26에서 보듯이 Simple Event Mediator는 워크플로가 충분히 단순하면 파생 메시지를 직접 생성해 처리합니다. 트리거 이벤트가 무겁거나 복잡하다고 판단되면, 원래의 트리거 이벤트를 BPEL 또는 BPM 중재자에게 전달합니다. 원래 이벤트를 가로챈 Simple Event Mediator는 여전히 이벤트 완료 여부를 추적할 수도 있고, 전체 워크플로(고객 알림 포함)를 다른 중재자에게 완전히 위임할 수도 있습니다.

중재자 토폴로지가 어떻게 동작하는지 살펴보기 위해, 앞서 안무형 토폴로지를 설명할 때 사용했던 소매 주문 시스템을 다시 사용하되 이번에는 중재자 토폴로지를 적용해 보겠습니다. 중재자는 이 이벤트를 처리하는 데 필요한 단계를 알고 있으며, [그림](#page-78-0) 15-27에 내부 이벤트 흐름이 나와 있습니다.

![](_page_78_Figure_0.jpeg)

이전과 마찬가지로 place order 트리거 이벤트가 전용 큐를 통해 이벤트 중재자에게 전달됩니다. Customer Mediator는 트리거 이벤트를 수신하고 [그림](#page-78-0) 15-27의 순서에 따라 파생 메시지를 생성합니다. 2, 3, 4단계의 이벤트는 모두 병렬로 실행되지만, 단계 간에는 순차적 제약이 있습니다. 다시 말해 3단계(주문 이행)가 완료되어야 4단계에서 고객에게 주문이 배송 준비되었음을 알릴 수 있습니다.

트리거 이벤트를 받은 중재자는 create order라는 파생 메시지를 만들어 order placement 큐로 보냅니다([그림](#page-80-0) 15-28). Order Placement 이벤트 프로세서는 메시지를 수신해 주문을 검증하고 생성한 뒤, 주문 ID와 함께 중재자에게 확인을 보냅니다. 이 시점에서 중재자는 고객에게 주문 ID를 전달해 주문이 접수되었음을 알릴 수 있지만, 모든 단계가 끝날 때까지 기다리는 것도 가능합니다(비즈니스 정책에 따라 다름).

![](_page_80_Figure_0.jpeg)

1단계가 끝나면 중재자는 2단계로 이동해 동시에 세 개의 파생 메시지(email customer, apply payment, adjust inventory)를 생성해 각 큐에 보냅니다([그림](#page-82-0) 15-29). 세 이벤트 프로세서는 메시지를 처리하고 완료되었다는 확인을 중재자에게 보냅니다. 중재자는 세 프로세서 모두에게서 성공 응답을 받아야 3단계로 진행할 수 있습니다. 어느 하나라도 오류가 발생하면 중재자가 교정 조치를 취할 수 있습니다(이 절 후반 참조).

![](_page_82_Figure_0.jpeg)

2단계의 모든 이벤트 프로세서로부터 성공 확인을 받으면 중재자는 3단계로 이동해 주문을 이행합니다([그림](#page-84-0) 15-30). 이 단계에서도 fulfill order와 order stock 메시지를 동시에 발행할 수 있습니다. Order Fulfillment와 Warehouse 이벤트 프로세서는 각 메시지를 처리한 뒤 중재자에게 확인을 돌려보냅니다.

![](_page_84_Figure_0.jpeg)

#### 그림 15-30. 중재자 예제의 3단계

중재자는 4단계([그림](#page-86-0) 15-31)로 이동해 ship order 메시지와, 주문이 배송 준비되었음을 고객에게 알리는 email customer 메시지를 생성합니다.

![](_page_86_Figure_0.jpeg)

#### 그림 15-31. 중재자 예제의 4단계

마지막으로 5단계([그림](#page-88-0) 15-32)에서 주문이 실제로 배송되었음을 알리는 또 다른 문맥 기반 email customer 메시지를 생성합니다. 워크플로가 종료되면 중재자는 트리거 이벤트의 처리가 끝났다고 표시하고, 해당 이벤트와 관련된 모든 상태 정보를 제거합니다.

![](_page_88_Figure_0.jpeg)

안무형 토폴로지와 달리, 이 토폴로지에서 중재자는 워크플로를 알고 제어합니다. 따라서 이벤트 상태를 유지하고, 오류 처리와 복구, 재시작 기능을 관리할 수 있습니다. 예를 들어 결제가 신용카드 만료 때문에 실패했다면 중재자는 주문이 완료될 수 없다는 사실(3단계)을 알고 워크플로를 중단한 뒤, 자체 영구 저장소에 상태를 저장합니다. 결제가 완료되면 중재자는 이전에 중단된 지점(이 경우 3단계 시작 부분)에서 워크플로를 다시 시작할 수 있습니다.

중재자 토폴로지는 안무형 토폴로지의 문제를 해결하지만, 자체적인 단점도 있습니다. 복잡한 이벤트 흐름에서 발생하는 동적 처리를 선언적으로 모델링하기가 매우 어렵습니다. 따라서 중재자 토폴로지에서 구현되는 많은 워크플로는 일반 처리를 다룬 후, 재고 부족 같은 복잡한 경우에는 중재자와 안무형 토폴로지를 결합한 하이브리드 모델을 사용합니다. 이벤트 프로세서는 안무형 토폴로지처럼 확장할 수 있지만, 중재자 역시 확장해야 하므로 전체 이벤트 처리 흐름에서 병목이 될 가능성이 있습니다. 또한 중재자 토폴로지의 이벤트 프로세서는 안무형 토폴로지만큼 느슨하게 결합되지는 않습니다. 마지막으로, 중재자가 이벤트 처리를 제어하므로 성능이 안무형 토폴로지만큼 뛰어나지 않습니다.

결국 안무형 토폴로지와 중재자 토폴로지 사이의 트레이드오프는 워크플로 제어 및 오류 처리 능력 대 높은 성능과 확장성 간의 균형입니다. 중재자 토폴로지에서도 성능과 확장성이 우수하지만, 안무형 토폴로지만큼 높지는 않습니다.
# <span id="page-90-0"></span>데이터 토폴로지

이벤트와 이벤트 처리에 대한 논의에 집중하다 보면 EDA의 데이터 측면을 간과하기 쉽습니다. 데이터베이스 토폴로지는 이 아키텍처 스타일의 독특하고 흥미로운 측면입니다. 선택지는 다양하며, 각각 상당한 트레이드오프가 존재해 전체 아키텍처에 큰 영향을 미칠 수 있습니다. EDA의 다양한 데이터베이스 토폴로지를 설명하기 위해 [그림](#page-7-0) 15-3의 예를 단순화한 [그림](#page-92-0) 15-33을 사용합니다.

고객이 주문을 제출하면 Order Placement 이벤트 프로세서가 주문을 생성하고 order placed 이벤트를 발행하며, Payment와 Inventory 이벤트 프로세서가 여기에 반응합니다. 결제가 완료되면 Order Fulfillment 이벤트 프로세서가 작업자에게 주문 포장을 돕고 order fulfilled 이벤트를 발행합니다. Shipping 이벤트 프로세서는 order fulfilled 이벤트에 반응해 주문을 배송하고, 처리를 완료하여 고객 요구를 충족합니다.

![](_page_92_Figure_0.jpeg)

EDA의 복잡성 중 하나는 Order Placement 이벤트 프로세서가 두 가지 정보를 필요로 한다는 점입니다. 현재 재고 수량과 고객 위치에 따라 가능한 배송 옵션입니다. 이 정보를 어떻게 구하느냐는 아키텍처가 사용하는 데이터베이스 토폴로지에 따라 달라집니다. 각 옵션을 살펴보며 주요 트레이드오프를 분석해 보겠습니다.

## **모놀리식 데이터베이스 토폴로지**

EDA에서 가장 흔히 사용되는 데이터베이스 토폴로지는 *단일 모놀리식 데이터베이스 토폴로지*입니다. 이 토폴로지에서는 모든 이벤트 프로세서가 중앙 데이터베이스를 통해 필요한 데이터에 접근합니다.

모놀리식 토폴로지의 가장 큰 장점은 어떤 이벤트 프로세서든 다른 이벤트 프로세서와 동기식으로 통신할 필요 없이 데이터베이스에서 직접 필요한 데이터를 조회할 수 있다는 점입니다. 이는 비동기 통신을 사용해 느슨하게 결합된 이벤트 프로세서에 의존하는 이벤트 주도 아키텍처에 큰 장점입니다. [그림](#page-94-0) 15-34에서 Order Placement 이벤트 프로세서는 중앙 데이터베이스를 조회하여 현재 재고 수량과 고객의 배송 옵션을 바로 얻을 수 있습니다.

![](_page_94_Figure_0.jpeg)

하지만 모놀리식 토폴로지에는 여러 단점도 있습니다. 첫째, 내결함성이 떨어집니다. 중앙 데이터베이스가 장애를 일으키거나 유지보수로 중단되면 모든 이벤트 프로세서가 사용할 수 없게 됩니다.

둘째, 확장성 문제입니다. EDA에서는 각 이벤트 프로세서가 독립적으로 확장할 수 있으며, 이벤트 채널이 역압 역할을 하여 특정 이벤트 프로세서만 필요할 때 확장할 수 있습니다. 그러나 모든 이벤트 프로세서가 동시에 동일한 데이터베이스에 읽기/쓰기를 수행하면 *데이터베이스 자체*가 이러한 요구를 충족하도록 확장되어야 합니다. 많은 데이터베이스는 높은 동시성 부하를 견디기 어렵습니다.

셋째, 변경 관리가 어렵습니다. 데이터베이스 구조가 변경되면(예: 열 삭제) 여러 이벤트 프로세서가 영향을 받으므로 단일 변경에도 서로 조정해야 합니다.

마지막으로, 공용 모놀리식 데이터베이스 때문에 필연적으로 하나의 아키텍처 퀀텀을 형성하게 됩니다.

### **도메인 데이터베이스 토폴로지**

EDA에서 사용할 수 있는 또 다른 토폴로지는 *도메인 데이터베이스 토폴로지*입니다. 여기서는 이벤트 프로세서를 여러 도메인으로 나누고 각 도메인이 자체 데이터베이스를 보유합니다([그림](#page-97-0) 15-35 참조).

![](_page_97_Figure_0.jpeg)

도메인 분할 덕분에 이 토폴로지는 모놀리식 토폴로지보다 향상된 내결함성, 확장성, 변경 관리를 제공합니다. [그림](#page-97-0) 15-35의 예에서 주문 처리 도메인의 데이터베이스(Order Fulfillment, Order Shipping 이벤트 프로세서와 연결)가 장애나 유지보수로 사용할 수 없더라도, 주문 접수 도메인은 여전히 정상적으로 주문을 받을 수 있습니다. payment applied 파생 이벤트가 담긴 이벤트 채널은 역압 지점을 형성하여, 주문 처리 데이터베이스가 다시 가동될 때까지 이벤트를 큐에 저장합니다. 확장성과 변경 관리도 마찬가지입니다. 각 도메인 데이터베이스는 해당 도메인 이벤트 프로세서의 요구에 맞춰 확장하면 되고, 데이터베이스 구조가 변경되면 해당 도메인의 이벤트 프로세서만 수정하면 됩니다.

하지만 Order Placement 이벤트 프로세서가 필요한 두 가지 정보(재고 수량과 배송 옵션)를 다시 생각해 봅시다. 도메인 데이터베이스 토폴로지에서는 이 프로세서가 재고 정보를 얻기 위해 자신의 도메인 데이터베이스를 조회할 수 있습니다. 하지만 배송 옵션을 얻으려면 Order Shipping 이벤트 프로세서에 *동기식* 호출을 해야 하므로, 서비스 간 동기 결합이 발생합니다([그림](#page-100-0) 15-36 참조).

![](_page_100_Figure_0.jpeg)

EDA처럼 고도로 동적이고 디커플링된 아키텍처에서는 동기 결합을 피하는 것이 좋습니다. 동기 호출은 내결함성과 확장성에 부정적인 영향을 미치고, 이 토폴로지가 제공하는 혜택을 무효화할 수 있습니다. 항상 도메인이 서로 독립적으로 유지되도록 주의하고, 동기식 서비스 간 호출을 가능한 한 줄이세요. 서비스 간 동기 통신이 지나치게 많다면 도메인 경계를 재고하거나 도메인을 결합하거나, 심지어 모놀리식 토폴로지로 되돌리는 것도 고려해야 합니다.

## **전용 데이터 토폴로지**

또 다른 실용적인 선택지는 *전용 데이터베이스 토폴로지*입니다. 마이크로서비스 세계에서는 흔히 *서비스별 데이터베이스 패턴*으로 알려져 있습니다. 이 토폴로지에서는 각 이벤트 프로세서가 마이크로서비스처럼 고유한 데이터베이스를 소유하며, 범위가 매우 제한된 컨텍스트를 사용합니다([18장](#page--1-0) “데이터 토폴로지” 참조). [그림](#page-102-0) 15-37에 이 토폴로지가 나와 있습니다.

![](_page_102_Figure_0.jpeg)

예상할 수 있듯이 전용 데이터베이스 토폴로지는 내결함성, 확장성, 변경 관리 측면에서 가장 높은 수준을 제공합니다. 이벤트 프로세서나 데이터베이스가 장애를 일으켜도 영향은 해당 프로세서에 국한됩니다. 나머지는 계속 정상 작동할 수 있습니다. 확장성 측면에서도 각 이벤트 프로세서는 자체 데이터베이스를 독립적으로 확장하면 됩니다. 변경 역시 해당 이벤트 프로세서에만 영향을 미치므로 조정이 쉽습니다.

단점은 데이터베이스 기술에 따라 비용이 상당히 높을 수 있다는 점입니다. 하지만 가장 큰 단점은 이벤트 프로세서 간의 동기 동적 결합입니다. 다시 Order Placement 이벤트 프로세서가 필요한 두 정보를 떠올려 봅시다. 이 토폴로지에서는 Order Placement 이벤트 프로세서가 정보를 얻기 위해 Inventory와 Order Shipment 이벤트 프로세서를 모두 *동기식*으로 호출해야 하므로, 아키텍처 전체에 동기 결합 지점이 생깁니다([그림](#page-105-0) 15-38 참조). 도메인 데이터베이스 토폴로지에서와 마찬가지로, 이 옵션을 선택하기 전에 각 이벤트 프로세서의 데이터 관련 요구 사항을 면밀히 파악해야 합니다.

![](_page_105_Figure_0.jpeg)

전용 데이터베이스 토폴로지는 이벤트 프로세서가 대부분 자신만의 데이터와 데이터베이스 내에서 작업할 때 좋은 선택입니다. 이벤트 프로세서 간 통신이 많다면(“[거버넌스](#page-108-0)” 참조) 전체 성능과 확장성을 개선하기 위해 도메인 또는 모놀리식 토폴로지로 전환하는 것이 좋습니다. 반대로 데이터베이스 구조가 자주 변경된다면, 영향을 받는 이벤트 프로세서 수를 최소화하기 위해 이러한 운영 특성보다 구조적 유연성을 우선시하는 것도 하나의 선택입니다.
# 클라우드 고려 사항

이벤트 주도 아키텍처는 높은 디커플링 덕분에 클라우드 기반 환경 및 구현과 잘 맞습니다. 클라우드 제공업체의 비동기 서비스를 쉽게 활용할 수 있으며, 클라우드 인프라와 서비스의 탄력적인 특성이 EDA의 특성과 자연스럽게 맞물립니다. 요컨대 클라우드 환경은 EDA와 궁합이 좋습니다.

# 공통 위험

EDA의 주요 위험 중 하나는 비결정적인 이벤트 처리 때문에 부작용이 발생할 수 있다는 점입니다. 예를 들어 이벤트 프로세서가 예상치 못한 파생 이벤트를 발행하거나, 이벤트에 제때 반응하지 못할 수 있습니다. 이벤트 워크플로는 이벤트 주도 아키텍처에서 매우 복잡해질 수 있으며, 특정 이벤트가 발행되었을 때 정확히 무엇이 일어날지 파악하기 어려울 때가 많습니다.

또 다른 위험은 이벤트 주도 아키텍처 내부에 지나치게 강한 정적 결합(따라서 취약성)이 생기는 것입니다. EDA는 매우 *동적으로* 결합되지만, 이벤트 페이로드 계약(“[이벤트 페이로드](#page-27-0)” 참조)은 강한 *정적* 결합을 만들어낼 수 있습니다. 계약을 변경하는 일은 어렵습니다. 아키텍트는 특정 이벤트에 어떤 이벤트 프로세서가 반응하는지 항상 알 수 없기 때문입니다. 이벤트 페이로드 계약이 변경되면 다수의 이벤트 프로세서가 영향을 받아 아키텍처를 더욱 취약하게 만듭니다. 키 기반 이벤트 페이로드를 사용하면 이 위험을 완화할 수 있지만, 대신 확장성과 성능 문제가 발생하거나 빈혈 이벤트가 생길 수 있습니다(“[이벤트 페이로드](#page-27-0)” 참조).

이벤트 프로세서 간 동기 통신이 너무 많아지는 것도 주의해야 합니다. EDA는 고도로 동적으로 디커플링된 이벤트 프로세서 덕분에 강력함을 얻습니다. 이벤트 프로세서가 계속 동기 통신을 해야 한다면, EDA가 적절한 아키텍처 스타일이 아니라는 신호일 수 있습니다.

마지막으로 EDA에서 전체 상태를 관리하는 일은 위험이자 도전 과제입니다. 트리거 이벤트가 언제 완전히 처리되었는지 아는 것이 중요하지만, 비결정적이고 비동기적인 병렬 이벤트 처리 때문에 이를 판별하기가 매우 어렵습니다. 때로는 아키텍트가 처리 종료 시점을 파악해 트리거 이벤트를 수신한 이벤트 프로세서가 "종료" 이벤트를 구독하도록 만들 수 있지만, 대부분의 경우 그렇지 않습니다. 따라서 트리거 이벤트가 완전히 처리되었는지 혹은 현재 어떤 상태인지 파악하기 어렵습니다.

# <span id="page-108-0"></span>거버넌스

EDA 거버넌스의 대부분은 구조적이라기보다 관측 가능성(로그 등) 기반으로 이뤄집니다. 인프라와 환경에 따라서는 EDA 관련 거버넌스 지표를 수동으로 수집해야 할 수도 있습니다.

이 스타일에서 가장 중요한 거버넌스 영역은 계약 관리로 인한 정적 결합과 동기 호출로 인한 동적 결합입니다. 두 가지 모두 EDA에서는 구조적 부식으로 간주되므로 면밀히 관찰해야 합니다.

정적 결합 관점에서 아키텍트는 이벤트 페이로드 계약의 변경 빈도와 전반적인 스탬프 결합을 관리할 수 있습니다. EDA는 느슨하게 결합되어 있기 때문에 계약 변경은 매우 위험합니다. 특히 스키마가 없는 이벤트 계약을 변경하면 다운스트림 이벤트 프로세서를 손상시킬 수 있습니다. 비결정적 엔드투엔드 이벤트 흐름을 테스트하기가 어렵다는 점도 위험을 키웁니다.

스탬프 결합(“[이벤트 페이로드](#page-27-0)” 참조)은 이벤트 계약에서 사용되지 않는 필드를 지속적으로 기록하고 관찰함으로써 관리할 수 있습니다. 사용되지 않는 필드를 파악하면 계약 크기를 줄이고 대역폭을 절약할 수 있으며, 스탬프 결합으로 인해 이벤트 프로세서에 가해지는 불필요한 변경을 억제할 수 있습니다.

동적 결합 측면에서 아키텍트는 로그와 기타 관측 가능한 수단(소스 코드 주석, 표준 동기 커스텀 식별자 라이브러리 등)을 활용해 이벤트 프로세서 간 동기 통신을 감시하고 추적하는 자동화된 피트니스 함수를 작성할 수 있습니다. 이벤트 주도 아키텍처에서는 *모든* 동기 통신을 추적하고 그 필요성을 논의해야 합니다. 특히 특정 도메인이나 전용 이벤트 프로세서 간 통신이 필요할 때 그렇습니다.

# 팀 토폴로지 고려 사항

EDA는 각 도메인을 구성하는 아티팩트—여러 이벤트 프로세서, 이벤트 채널, 메시지 브로커, 데이터베이스(데이터 토폴로지에 따라)—가 많기 때문에 대체로 기술적으로 분할된 아키텍처로 간주됩니다. 그럼에도 불구하고, 도메인 영역 내에서 팀이 잘 정렬되어 있다면(예: 전문성을 갖춘 크로스 기능 팀) 효과적으로 작동할 수 있습니다. 하지만 특정 팀 토폴로지(“[팀 토폴로지와 아키텍처](#page--1-2)” 참조)에서는 도전 과제가 될 수 있습니다.

다음은 특정 팀 토폴로지와 EDA를 조정할 때 고려해야 할 사항입니다.

### *스트림 중심 팀*

시스템 규모에 따라 스트림 중심 팀은 도메인 기반 변경을 구현하기 어렵습니다. 이벤트 프로세서가 느슨하게 결합되어 있고, 도메인/서브도메인이 여러 이벤트 프로세서와 파생 이벤트를 통해 구현되기 때문입니다. 예를 들어 주문 처리 워크플로에 단계를 추가하면 여러 이벤트 프로세서를 변경하고, 기존 파생 이벤트가 발생하는 방식과 시점을 재구성해야 할 수 있습니다. 시스템이 클수록 스트림 중심 팀은 덜 효과적이 됩니다.

### *지원(Enabling) 팀*

파생 이벤트와 그 계약에 기반해 이벤트 프로세서가 긴밀하게 통합되어 있으므로, 지원 팀은 EDA에서 잘 작동하지 않습니다. 스트림 내부에서 실험하고 효율적으로 일하려는 지원 팀의 활동이 전체 이벤트 흐름에 대한 스트림 팀의 이해와 관리를 방해할 수 있으며, 스트림 팀과 지원 팀 사이에 과도한 조정을 요구합니다.

### *복잡한 서브시스템 팀*

복잡한 서브시스템 팀은 이벤트 프로세서가 디커플링되고 비동기식이라는 점 덕분에 EDA와 잘 어울립니다. 복잡한 처리를 별도의 이벤트 프로세서로 쉽게 격리해, 복잡한 서브시스템 팀은 해당 부분에만 집중하고 덜 복잡한 처리는 스트림 중심 팀에 맡길 수 있습니다. 이벤트 프로세서가 동적으로 느슨하게 결합되어 있기 때문에, 스트림 중심 팀은 정적 이벤트 페이로드 계약과 파생 이벤트에 대해서만 복잡한 서브시스템 팀과 조율하면 됩니다.

### *플랫폼 팀*

EDA에서는 기술적 분할 덕분에 개발자가 공통 도구, 서비스, API, 작업을 사용해 플랫폼 팀 토폴로지의 혜택을 누릴 수 있습니다. 특히 메시지 브로커, 이벤트 허브, 이벤트 버스 등 인프라 관련 부분을 플랫폼 구성 요소로 취급하면 더욱 그렇습니다.
# 스타일 특성

[그림](#page-114-0) 15-39의 표에서 별 1개는 특정 아키텍처 특성이 해당 스타일에서 잘 지원되지 않음을, 별 5개는 이 스타일의 가장 강력한 특성 중 하나임을 의미합니다. 점수표에 있는 각 특성의 정의는 [4장](#page--1-0)에서 확인할 수 있습니다.

이벤트 주도 아키텍처는 기본적으로 기술적으로 분할된 아키텍처입니다. 특정 도메인이 여러 이벤트 프로세서에 걸쳐 분산되고, 브로커·계약(이벤트 페이로드)·토픽으로 연결됩니다. 특정 도메인을 변경하면 보통 여러 이벤트 프로세서와 메시징 아티팩트에 영향을 주기 때문에, 일반적으로 도메인 분할 아키텍처로 보지는 않습니다.

|             | 아키텍처 특성                | 별 등급                        |
|-------------|------------------------------|--------------------------------|
|             | 총비용                         | \$\$\$                         |
| 구조적        | 분할 유형                      | 기술적                          |
|             | 퀀텀 수                         | 1개 이상                        |
|             | 단순성                         | $\stackrel{\star}{\Rightarrow}$ |
|             | 모듈성                         | ***                            |
| 엔지니어링    | 유지보수성                     | ***                            |
|             | 테스트 가능성                   | $\stackrel{\wedge}{\Rightarrow}$|
|             | 배포 용이성                    | ***                            |
|             | 진화 가능성                    | ***                            |
| 운영적        | 반응성                         | ***                            |
|             | 확장성                         | ****                           |
|             | 탄력성                         | ***                            |
|             | 내결함성                       | ***                            |

EDA에서 퀀텀 수는 이벤트 프로세서에 필요한 데이터베이스 상호작용과 시스템이 요청-응답 처리를 사용하는지 여부에 따라 1개에서 다수까지 다양할 수 있습니다. 비록 EDA의 통신이 비동기 호출에 기반하더라도, 여러 이벤트 프로세서가 단일 데이터베이스 인스턴스를 공유하면 모두 동일한 아키텍처 퀀텀에 속하게 됩니다. 요청-응답 처리도 마찬가지입니다. 통신은 여전히 비동기이지만, 이벤트 소비자로부터 즉각적인 응답이 필요하면 이벤트 프로세서가 동기적으로 연결되어 하나의 퀀텀을 형성합니다.

예를 들어 한 이벤트 프로세서가 다른 이벤트 프로세서에 주문 생성을 요청한다고 합시다. 첫 번째 프로세서는 두 번째 프로세서(주문 생성 및 주문 ID 발급)가 주문 ID를 돌려줄 때까지 기다려야 작업을 이어갈 수 있습니다. 두 번째 프로세서가 다운되면 첫 번째 프로세서는 계속 진행할 수 없습니다. 이 경우 두 프로세서는 서로 비동기 메시지를 주고받지만, 동일한 아키텍처 특성을 공유하는 하나의 퀀텀에 속하게 됩니다.

이벤트 주도 아키텍처는 성능, 확장성, 내결함성이라는 핵심 강점에서 매우 높은 평가(4~5개 별)를 받습니다. 높은 성능은 비동기 통신과 고도의 병렬 처리 조합에서 비롯됩니다. 확장성이 뛰어난 이유는 이벤트 프로세서가 프로그래밍 방식으로 부하를 분산하기 때문입니다(이를 *경쟁 소비자* 또는 *소비자 그룹*이라고도 함). 요청 부하가 증가하면 추가 이벤트 프로세서를 프로그래밍 방식으로 추가해 추가 트래픽을 처리할 수 있습니다. 별 다섯 개가 아닌 네 개를 준 이유는 데이터베이스 때문입니다(해당 특성에서 별 다섯 개를 받은 예시는 [16장](#page--1-0)의 공간 기반 아키텍처에서 확인할 수 있습니다). EDA는 디커플링된 비동기 이벤트 프로세서를 통해 내결함성을 달성합니다. 다운스트림 프로세서가 사용 불가능하더라도, 사용자 인터페이스나 요청을 보낸 이벤트 프로세서가 즉각적인 응답을 요구하지 않는 한 시스템은 나중에 이벤트를 처리할 수 있습니다.

반면 EDA는 전반적인 *단순성*과 *테스트 용이성*이 상대적으로 낮습니다. 이는 비결정적이고 동적인 이벤트 흐름 때문입니다. 요청 기반 모델에서는 결정적 흐름이 일반적으로 알려져 있으므로 테스트가 비교적 쉽습니다. 하지만 이벤트 기반 모델에서는 아키텍트가 동적 이벤트에 이벤트 프로세서가 어떻게 반응하고 어떤 메시지를 생성할지 알기 어려울 때가 많습니다. 이러한 흐름을 *비결정적 워크플로*라고 부릅니다. 해당 시스템의 "이벤트 트리 다이어그램"은 극도로 복잡해져 수백 혹은 수천 개의 시나리오를 만들어낼 수 있으며, 제어나 테스트를 어렵게 만듭니다.

EDA는 진화 가능성이 매우 높기에 별 다섯 개를 받았습니다. 기존 또는 새로운 이벤트 프로세서를 통해 새 기능을 추가하는 일이 비교적 쉽습니다. 파생 이벤트를 통해 훅을 제공하면 이벤트와 관련 데이터가 이미 다른 처리를 위해 제공되므로, 새 기능을 추가하려고 인프라나 기존 이벤트 프로세서를 변경할 필요가 없습니다.

EDA의 단점 중 하나는 트리거 이벤트에 연관된 전체 워크플로를 제어하기 어렵다는 점입니다. 이벤트 처리는 상황 변화에 따라 매우 동적으로 변하며, 트리거 이벤트 기반의 비즈니스 작업이 언제 완료되는지 알기 어렵습니다.

또한 오류 처리는 EDA에서 큰 도전 과제입니다. 대부분의 경우(중재자 토폴로지를 제외하면) 비즈니스 프로세스를 감시하거나 제어하는 중재자가 없기 때문에, 오류가 발생하면 다른 서비스는 장애 사실을 알지 못합니다. 트리거 이벤트 기반 비즈니스 프로세스가 중단된 채로 남아, 자동 또는 수동 개입 없이는 다시 진행할 수 없습니다. 다른 프로세스는 장애를 신경 쓰지 않고 계속 진행하더라도 말입니다.
## **요청 기반 모델과 이벤트 기반 모델 중 선택하기**

요청 기반 모델과 이벤트 기반 모델은 모두 소프트웨어 시스템을 구축하는 데 사용할 수 있는 현실적인 접근 방식입니다. 그러나 올바른 모델을 선택하는 것이 성공의 핵심입니다. 잘 구조화된 데이터 중심 요청(예: 고객 프로필 조회)처럼 보안과 워크플로 제어가 최우선이라면 요청 기반 모델을 추천합니다. 반대로 높은 반응성과 확장성, 복잡하고 동적인 사용자 프로세스가 필요한 액션 기반 이벤트라면 이벤트 기반 모델을 권장합니다.

이벤트 기반 모델의 트레이드오프를 이해하면 더 나은 결정을 내릴 수 있습니다. [표](#page-120-0) 15-2는 EDA의 이벤트 기반 모델이 제공하는 장점과 트레이드오프를 정리합니다.

<span id="page-120-0"></span>표 15-2. 이벤트 기반 모델의 트레이드오프

| 요청 기반 대비 장점                           | 트레이드오프                                   |
|----------------------------------------------|-----------------------------------------------|
| 동적인 사용자 콘텐츠에 대한 더 나은 반응        | 결국 일관성만 지원                             |
| 향상된 확장성과 탄력성                         | 처리 과정에 대한 통제력 감소                   |
| 민첩성과 변경 관리 향상                         | 이벤트 흐름 결과를 확실히 예측하기 어려움        |
| 적응성과 확장성 향상                           | 테스트와 디버깅이 어려움                        |
| 반응성과 성능 개선                              |                                               |
| 실시간 의사 결정 향상                           |                                               |

### **요청 기반 대비 장점**

### **트레이드오프**

상황 인식에 더 잘 대응할 수 있음
# 예시와 사용 사례

시스템 내부 혹은 외부에서 발생하는 사건에 반응해야 하는 모든 비즈니스 문제는 EDA에 적합한 후보입니다. 이 장에서 사용한 주문 입력 시스템 예시는 주문을 병렬로, 그리고 디커플링된 방식으로 처리해야 하므로 EDA의 좋은 사용 사례입니다. 높은 반응성, 성능, 확장성, 내결함성, 탄력성이 필요한 시스템도 마찬가지입니다.

EDA의 성능과 효율성을 보여 주는 또 다른 좋은 사례는 계속 언급해 온 Going, Going, Gone 경매 시스템입니다. 사용자가 경매 품목에 입찰하고, 마지막 입찰이 유지되면 그 사용자가 품목을 획득하는 구조입니다. 이러한 시스템에서는 입찰자 수를 알 수 없는 경우가 많아 확장성과 탄력성이 모두 필요합니다. 특히 경매가 제한된 시간 동안만 진행되고 마감이 다가오면 입찰이 급증할 수 있기 때문입니다. 또한 높은 반응성이 요구됩니다. 온라인 경매 시스템과 EDA가 잘 맞는 가장 큰 이유는 EDA가 입찰을 *시스템에 대한 요청*이 아니라 이미 발생한 *이벤트*로 간주하기 때문입니다.

[그림](#page-123-0) 15-40에서 보듯이, 사용자가 입찰을 제출하면 시스템에서 많은 작업이 동시에 일어납니다. 이러한 작업은 모두 비동기적으로 이루어질 수 있으며, Bidder Tracker 이벤트 프로세서처럼 백엔드 처리로 나중에 실행할 수도 있습니다. 입찰이 들어오면 Bid Capture 이벤트 프로세서가 트리거 이벤트를 수신하고 이전 입찰보다 높은지 확인한 뒤 bid placed 이벤트를 발행합니다. Auctioneer 이벤트 프로세서는 이 이벤트에 반응해 웹사이트의 품목 가격을 업데이트합니다. 동시에 Bid Streamer 이벤트 프로세서는 이벤트에 반응해 입찰 기록을 웹사이트나 개별 입찰자에게 스트리밍합니다(사용자 인터페이스에 따라 다름). 마지막으로 Bidder Tracker 이벤트 프로세서는 입찰자와 입찰 내용을 저장해 추적 및 감사에 활용합니다.

<span id="page-123-0"></span>![](_page_123_Picture_0.jpeg)

그림 15-40. EDA를 사용하는 온라인 입찰 시스템 예시

이 트리거 이벤트 워크플로에는 다른 많은 이벤트 프로세서와 파생 이벤트도 관여하지만, 이 작은 단면만으로도 EDA 스타일이 어떻게 반응성, 내결함성, 확장성, 탄력성을 구현하는지 잘 보여 줍니다.

이벤트 주도 아키텍처는 매우 복잡하지만 매우 강력한 아키텍처 스타일입니다. 비즈니스 문제에 필요한 워크플로와 처리 과정을 분석해, EDA가 지닌 슈퍼파워를 활용하기 위해 이 복잡성을 감수할 가치가 있는지 판단하세요. 필요한 프로세스의 상당 부분이 요청 기반이라면, 대신 마이크로서비스 아키텍처 스타일([18장](#page--1-0) 참조)을 고려해 볼 수 있습니다.
