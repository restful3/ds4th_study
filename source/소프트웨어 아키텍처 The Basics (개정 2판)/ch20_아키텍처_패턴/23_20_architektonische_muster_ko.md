---
lang: ko
format:
  html:
    toc: true
    embed-resources: true
    theme: cosmo
---
# 20장. 아키텍처 패턴 (Architektonische Muster)

이 문서는 AI를 사용하여 번역되었습니다. 귀하의 피드백과 의견을 환영합니다: [translation-feedback@oreilly.com](mailto:translation-feedback@oreilly.com)

저희는 [9장](#page--1-0)에서 아키텍처 스타일과 아키텍처 패턴을 구분합니다. 다시 말해, *스타일*은 아키텍트가 토폴로지, 물리적 아키텍처, 구현, 통신 스타일 및 데이터 토폴로지의 차이를 통해 구별하는 명명된 토폴로지입니다. *아키텍처 패턴*은 자주 인용되는 책 *Design [Patterns](https://www.oreilly.com/library/view/design-patterns-elements/0201633612)*에서 영감을 받았으며, 상황에 맞는 문제 해결책입니다.

아키텍처 패턴과 "모범 사례(best practices)"를 구분하는 것이 중요합니다 ([21장](#page--1-0)에서 자세히 설명). 어떤 것을 "모범 사례"라고 부르는 것은 아키텍트가 특정 상황이 발생할 때마다 이 방법을 적용할 의무가 있음을 의미합니다. 만약 이를 *더 나은* 방법이라고 부른다면 적어도 논쟁의 여지가 있겠지만, 우리는 이를 아키텍트가 뇌를 끄고 항상 동일한 해결책을 따르도록 허용하는 *모범* 방법이라고 부릅니다.

또한 패턴과 *솔루션*을 구분하는 것도 중요합니다. 많은 도구, 프레임워크, 라이브러리 및 기타 소프트웨어 개발 아티팩트는 하나 이상의 패턴을 캡슐화합니다. 이는 구현 방식에 따라 충실도와 다른 패턴과의 혼합 정도가 다릅니다. 먼저 가장 적절한 패턴을 식별한 다음, 이에 가장 적합한 구현을 선택하는 데 집중하세요.

이 장에서는 이 책의 2부에서 제시한 스타일과 대조하고 맥락화하기 위해 몇 가지 대표적인 패턴을 소개합니다. 첫 번째 예시인 아키텍처 재사용 패턴은 패턴과 구현의 차이를 명확하게 보여줍니다.

# 재사용 (Wiederverwendung)

도메인 결합(domain coupling)과 운영 결합(operational coupling)의 분리는 마이크로서비스(Microservices)와 같은 분산 아키텍처에서 흔히 발생하는 아키텍처 문제입니다.

## **도메인 및 운영 결합의 분리 (Trennung von Bereich und operativer Kopplung)**

마이크로서비스 아키텍처의 설계 목표 중 하나는 높은 수준의 결합 해제(decoupling)이며, 이는 종종 "복제(duplication)가 결합(coupling)보다 낫다"는 조언으로 표현됩니다.

두 서비스가 고객 프로필에 대한 정보를 주고받아야 하지만, 아키텍처의 도메인 기반 바운디드 컨텍스트(Bounded Context)는 구현 세부 사항이 각 서비스에만 국한되어야 한다고 주장한다고 가정해 봅시다. 일반적인 해결책은 각 서비스에 프로필과 같은 엔터티(entity)에 대한 자체 내부 표현을 제공하고, 이 정보를 JSON의 이름-값 쌍(name-value pairs)과 같이 느슨하게 결합된 방식으로 전달하는 것입니다. 이러한 방식으로 각 서비스는 통합을 중단하지 않고 기술 스택을 포함하여 내부 표현을 자유롭게 변경할 수 있습니다. 개발자는 일반적으로 코드 복제에 반대합니다. 이는 동기화 문제, 의미론적 드리프트(semantic drift) 등을 야기할 수 있기 때문입니다. 그러나 복제보다 더 나쁜 것들이 있습니다. 마이크로서비스에서는 결합이 여기에 해당합니다.

마이크로서비스를 설계하는 아키텍트들은 결합 해제를 유지하기 위해 때때로 구현을 복제해야 한다는 사실을 일반적으로 받아들입니다. 그러나 높은 결합으로부터 *이점을 얻는* 기능은 어떨까요? 모든 서비스는 모니터링, 로깅, 인증 및 권한 부여, 회로 차단(circuit breaking)과 같은 특정 공통 운영 기능을 갖추고 있어야 합니다. 그러나 각 팀이 이러한 종속성을 스스로 관리할 수 있다면 종종 혼란이 발생합니다.

어떤 회사가 모든 서비스에 대한 표준 모니터링 솔루션을 선택하여 운영을 용이하게 하려고 한다고 가정해 봅시다. 아키텍트는 각 팀이 서비스의 모니터링 구현을 담당하도록 결정합니다. 예를 들어 결제 서비스 팀, 재고 서비스 팀 등입니다. 그러나 운영 팀은 각 팀이 실제로 이를 수행했는지 어떻게 확신할 수 있을까요? 그리고 통일된 업그레이드와 같은 문제는 어떻습니까? 표준화된 모니터링 도구가 회사 전체에서 업데이트되어야 한다면, 팀들은 이를 어떻게 조율해야 할까요?

## **육각형 아키텍처 (Sechseckige Architektur)**

[그림](#page-4-0) 20-1에 나타난 *육각형(hexagonal)* 아키텍처 패턴에서 도메인 로직은 포트(ports)와 어댑터(adapters)로 둘러싸인 육각형의 중심에 위치하며, 이들은 생태계의 다른 부분과 연결됩니다 (이 패턴은 *포트 및 어댑터(Ports and Adapters)*라고도 불립니다). 이 패턴의 시각적 표현은 그림 20-1에서 볼 수 있습니다.

<span id="page-4-0"></span>![](_page_4_Picture_0.jpeg)

그림 20-1. 육각형 아키텍처 패턴

주의 깊은 독자들은 육각형의 여섯 면 중 네 면만 사용된다는 것을 알 수 있을 것입니다. 이 패턴의 창시자인 Alistair Cockburn은 처음에는 육각형으로 그렸고, 이를 육각형 아키텍처 패턴이라고 불렀습니다. 그는 포트 및 어댑터라는 이름이 훨씬 더 설명적이기 때문에 거의 즉시 후회했지만, 이미 때는 늦었습니다. 너무 많은 아키텍트들이 "육각형"이 멋있게 들린다고 생각했고, 그래서 그 이름이 고착되었습니다.

패턴과 구현의 혼동은 흔히 발생하는 위험이며, 이는 좋은 예시입니다. 육각형 아키텍처는 마이크로서비스를 설명하는 데 사용될 때 잠재적으로 심각한 결함을 가지고 있지만, 이는 패턴의 원래 의도를 이해하는 사람들에게만 해당됩니다. 육각형 아키텍처는 현대 마이크로서비스보다 오래되었지만, 둘 사이에는 많은 유사점이 있습니다. 또한 중요한 차이점이 하나 있는데, 바로 데이터 충실도(data fidelity)입니다. 육각형 아키텍처에서는 데이터베이스를 연결할 수 있는 또 다른 어댑터로만 간주합니다. 데이터베이스가 완전히 별개의 기계라고 잘못 가정했던 육각형이라는 이름이 만들어질 당시에는 데이터 스키마가 비즈니스 로직에 통합되지 않았습니다. Eric Evans는 그의 책 *Domain-Driven Design*에서 데이터베이스 스키마가 저장 위치와 관계없이 시스템의 비즈니스 로직을 반영하도록 변경되어야 함을 인식함으로써 이 오류를 수정했습니다.

이것은 육각형 패턴을 아키텍트들 사이에서 끊임없이 혼란을 야기하는 원천으로 만듭니다. 누군가가 이를 사용할 때, 그들은 운영 및 도메인 관심사의 분리를 설명하는 것일까요, 아니면 데이터를 격리하여 마이크로서비스의 핵심 설계 원칙에 위배되는 문자 그대로의 패턴을 언급하는 것일까요?

"도메인 및 운영 관심사 분리"에 대한 약어로 패턴 이름을 사용하는 것은 컨텍스트에서 오해의 소지가 없다면 괜찮습니다. 그러나 오늘날 아키텍트들은 이러한 구현을 필요로 하지 않습니다. 이제 육각형 패턴을 구현하기 위한 더 적절한 메커니즘인 *서비스 메시 패턴(Service Mesh-Pattern)*이 있습니다.

### **서비스 메시 (Service Mesh)**

이미 ["운영 재사용(Operational Reuse)"](#page--1-1)에서 기술적 관심사(technical concerns)와 도메인 관심사(domain concerns)를 분리하는 일반적인 아키텍처 접근 방식인 사이드카(Sidecar) 및 서비스 메시(Service Mesh) 패턴의 사용에 대해 설명했습니다.

사이드카 패턴은 운영 기능을 도메인에서 분리하는 방법일 뿐만 아니라, 특정 유형의 결합(coupling)을 다루는 직교 재사용 패턴(orthogonal reuse pattern)입니다 (["직교 결합(Orthogonale Kopplung)"](#page-7-0) 참조). 종종 아키텍처 솔루션은 도메인과 운영 간의 결합에 대한 현재 예시와 같이 여러 유형의 결합을 필요로 합니다. *직교 재사용 패턴*은 아키텍처에서 하나 이상의 관심사로 표현되고 선호되는 계층적 조직에 맞지 않는 측면을 재사용하는 방법을 제공합니다. 예를 들어, 마이크로서비스 아키텍처는 도메인을 중심으로 구성되지만, 운영 결합은 이러한 도메인을 가로지르는 절단면을 필요로 합니다. 사이드카는

아키텍트가 이러한 관심사를 아키텍처의 포괄적이지만 일관된 계층에서 격리할 수 있도록 합니다.

#### <span id="page-7-0"></span>**직교 결합 (ORTHOGONALE KOPPLUNG)**

수학에서 두 선은 직각으로 교차할 때 *직교*하며, 이는 독립성을 의미합니다. 소프트웨어 아키텍처에서 아키텍처의 두 부분은 *직교적으로 결합될* 수 있습니다. 즉, 두 가지 다른 목적을 가질 수 있지만, 완전한 솔루션을 형성하기 위해 여전히 서로 겹쳐야 합니다. 이 장의 명확한 예시는 모니터링과 같은 운영상의 관심사로, 카탈로그 체크아웃과 같은 도메인의 동작과는 독립적이지만 필수적입니다. 직교 결합을 인식하면 아키텍트가 관심사 간의 얽힘을 최소화하는 교차점을 찾을 수 있습니다.

사이드카 패턴은 훌륭한 추상화를 제공하지만, 다른 모든 아키텍처 접근 방식과 마찬가지로 [표](#page-8-0) 20-1에 설명된 바와 같이 절충점도 있습니다.

<span id="page-8-0"></span>표 20-1. 사이드카 및 서비스 메시 패턴의 절충점 (Kompromisse für die Muster Sidecar und Service Mesh)

| 장점 (Vorteile)                                                                      | 단점 (Benachteiligungen)                                                |
|:-------------------------------------------------------------------------------------|:------------------------------------------------------------------------|
| 격리된 결합을 생성하는 일관된 방법 제공 (Bietet eine konsistente Möglichkeit, isolierte Kopplungen zu schaffen) | 플랫폼당 하나의 사이드카를 구현해야 함 (Muss einen Beiwagen pro Plattform implementieren) |
| 인프라의 통일된 조율 가능 (Ermöglicht eine einheitliche Koordination der Infrastruktur) | 사이드카 구성 요소가 크거나 복잡해질 수 있음 (Seitenwagen-Komponente kann groß/komplex werden) |
| 팀별 책임, 중앙 집중식 또는 조합 (Eigenverantwortung pro Team, zentral oder eine Kombination) | 독립적인 팀 간 구현 "드리프트" ( "Drift" bei der Umsetzung zwischen unabhängigen Teams) |

육각형 패턴과 서비스 메시 패턴 모두 도메인과 운영 관심사를 분리하기 위해 재사용 패턴을 구현하는 방법을 보여줍니다. 육각형 구현은 범용적으로 적용할 수 있는 반면, 서비스 메시는 마이크로서비스 및 기타 분산 아키텍처에 적합합니다. 아키텍트에게 중요한 것은 먼저 패턴(즉, 분리)을 식별한 다음, 아키텍처에서 이를 가장 잘 구현할 방법을 결정하는 것입니다.

# 통신 (Kommunikation)

통신 패턴을 포함한 많은 아키텍처 패턴은 이벤트 기반 아키텍처(event-driven architecture)에서 파생되었으며, [15장](#page--1-0)과 [18장](#page--1-0)에서 설명된 바와 같이 메시지 및/또는 이벤트를 통해 통신하는 모든 분산 아키텍처에 적용됩니다. 실제로 이들 각 장에서 통신 사례를 보았지만, 아키텍트가 종종 패턴을 인식하지 못한 채 구현하기 때문에 우리는 이를 특별한 패턴으로 식별하지 않았습니다. 결국 패턴은 일반적인 문제에 대한 해결책입니다.

# **오케스트레이션 대 코레오그래피 (Orchestrierung versus Choreografie)**

"매개된 이벤트 기반 아키텍처(Vermittelte ereignisgesteuerte Architektur)" 및 "코레오그래피와 [오케스트레이션(Choreografie und Orchestrierung)](#page--1-3)"에서 이미 접했던 두 가지 통신 패턴인 코레오그래피(Choreografie)와 [오케스트레이션(Orchestration)](#page-10-0)을 [그림](#page-10-0) 20-2에 요약된 대로 살펴보겠습니다.

![](_page_10_Figure_0.jpeg)

![](_page_10_Figure_1.jpeg)

[그림](#page-10-0) 20-2에 묘사된 각 동형 워크플로에서 네 개의 도메인 서비스(서비스 A부터 D)가 워크플로를 형성하기 위해 협력해야 합니다. 오케스트레이션의 경우, 워크플로의 코디네이터 역할을 하는 별도의 서비스, 즉 *오케스트레이터(Orchestrator)*가 있습니다.

우리는 이 통신을 *오케스트레이션*과 *매개(Mediation)*로 모두 설명했지만, 패턴은 동일하게 유지됩니다. 아키텍트가 구현에 숨어 있는 패턴을 인식할 수 있다면 절충점이 더욱 명확해지므로 유리합니다.

매개와 오케스트레이션의 절충점을 설명할 때 우리는 동일한 많은 요점을 언급했습니다. 여기에서 장점을 다시 요약합니다.

### *중앙 집중식 워크플로 (Zentraler Arbeitsablauf)*

복잡성이 증가함에 따라 아키텍트들은 상태, 동작 및 경계 조건에 대한 통일된 구성 요소로부터 이점을 얻습니다.

#### *오류 처리 (Fehlerbehandlung)*

많은 도메인 워크플로의 중요한 부분인 오류 처리는 워크플로의 상태 소유자로부터 지원을 받습니다.

#### *복구 가능성 (Wiederherstellbarkeit)*

오케스트레이터가 워크플로의 상태를 모니터링하므로, 아키텍트는 하나 이상의 도메인 서비스의 단기적인 실패 시 재시도 로직을 추가할 수 있습니다.

### *상태 관리 (Staatliches Management)*

오케스트레이터는 워크플로의 상태를 질의 가능하게 만들고 다른 워크플로 및 기타 임시 상태를 위한 공간을 제공합니다.

오케스트레이션의 일반적인 단점은 다음과 같습니다.

### *응답성 (Reaktionsfähigkeit)*

모든 통신은 오케스트레이터를 통해 이루어져야 하므로, 응답성에 영향을 미치는 처리량 병목 현상이 발생할 수 있습니다.

#### *내결함성 (Fehlertoleranz)*

오케스트레이션은 도메인 서비스의 복구 가능성을 향상시키지만, 워크플로에 대한 잠재적인 단일 실패 지점(Single Point of Failure)을 만듭니다. 이 문제는 중복성(redundancy)을 통해 해결할 수 있지만, 이는 또한 복잡성을 증가시킵니다.

#### *확장성 (Skalierbarkeit)*

이 통신 스타일은 코레오그래피만큼 잘 확장되지 않습니다. 오케스트레이터가 더 많은 조정 지점을 추가하여 잠재적인 병렬성을 제한하기 때문입니다.

#### *서비스 결합 (Dienstleistungskupplung)*

중앙 집중식 오케스트레이터는 오케스트레이터와 도메인 구성 요소 간의 결합을 더 긴밀하게 만듭니다. 이는 때로는 필요하지만, 마이크로서비스 아키텍처에서는 지양됩니다.

마찬가지로, 우리는 마이크로서비스와 이벤트 기반 아키텍처 모두에서 코레오그래피를 논의했습니다. 코레오그래피 워크플로의 절충점은 다음과 같습니다.

#### *응답성 (Reaktionsfähigkeit)*

이러한 유형의 통신은 단일 병목 현상이 적으므로 병렬 처리를 위한 더 많은 기회를 제공합니다.

#### *확장성 (Skalierbarkeit)*

오케스트레이터와 같은 조정 지점이 없기 때문에 더 독립적인 확장이 가능합니다.

#### *내결함성 (Fehlertoleranz)*

단일 오케스트레이터가 없기 때문에 아키텍트는 내결함성을 높이기 위해 여러 인스턴스를 사용할 수 있습니다. 물론 여러 오케스트레이터를 생성할 수도 있지만, 모든 통신이 그들을 통해 이루어져야 하므로 여러 오케스트레이터는 전체 워크플로의 내결함성에 더 민감합니다.

#### *서비스 결합 해제 (Entkopplung von Diensten)*

오케스트레이터가 없다는 것은 결합이 적다는 것을 의미합니다.

코레오그래피 통신 스타일의 단점은 다음과 같습니다.

### *분산 워크플로 (Verteilter Arbeitsablauf)*

워크플로 소유자가 없기 때문에 오류 및 기타 경계 조건 관리가 더 어려워집니다.

### *상태 관리 (Staatliches Management)*

중앙 상태 유지 장치의 부재는 지속적인 상태 관리를 더 어렵게 만듭니다.

#### *오류 처리 (Fehlerbehandlung)*

오케스트레이터 없이는 도메인 서비스가 더 많은 워크플로 지식을 가져야 하므로 오류 처리가 더 어렵습니다.

#### *복구 가능성 (Wiederherstellbarkeit)*

재시도 및 기타 완화 조치를 수행하는 오케스트레이터가 없으면 복구 가능성이 더 어려워집니다.

이 두 패턴은 스타일과 패턴 사이의 구분을 아주 잘 보여줍니다. 모든 분산 아키텍처는 이러한 통신 패턴 중 하나를 사용할 수 있으며, 아키텍트들은 그 절충점을 평가하는 방법을 알아야 합니다. 소프트웨어 아키텍처의 두 번째 법칙을 기억하십시오. *절충점 분석을 한 번만 수행하고 끝낼 수는 없습니다*. 또한 어디에나 공통 패턴이 존재함을 보여주므로, 이는 일반적입니다.