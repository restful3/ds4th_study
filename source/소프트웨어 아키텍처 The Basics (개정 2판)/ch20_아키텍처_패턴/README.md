아키텍처 패턴 브리핑

요약

이 문서는 소프트웨어 아키텍처의 핵심 개념인 '아키텍처 패턴'에 대한 심층 분석을 제공합니다. 아키텍처 패턴은 특정 맥락에서 발생하는 문제에 대한 검증된 해결책으로, 아키텍처 '스타일'(명명된 토폴로지), 무조건적인 적용을 암시하는 '모범 사례', 또는 특정 도구나 프레임워크와 같은 '솔루션'과는 명확히 구분됩니다. 아키텍트의 핵심 역할은 먼저 문제에 가장 적합한 패턴을 식별한 후, 그 패턴을 구현할 최적의 방법을 선택하는 것입니다.

본 문서는 재사용, 통신, 인프라라는 세 가지 핵심 주제를 중심으로 주요 아키텍처 패턴을 분석합니다.

1. 재사용: 마이크로서비스와 같은 분산 아키텍처에서 도메인 관심사와 모니터링, 로깅 같은 운영 관심사를 분리하는 문제를 다룹니다. 이를 위한 구현으로 '육각형 아키텍처'와 현대적인 대안인 '서비스 메시' 패턴을 비교 분석하며, 각 접근법의 장단점을 제시합니다.
2. 통신: 분산 시스템 내 서비스 간의 상호작용 모델을 분석합니다. 중앙 조정자를 사용하는 '오케스트레이션'과 서비스들이 자율적으로 통신하는 '코레오그래피'의 장단점을 상세히 비교합니다. 또한, 읽기/쓰기 작업을 분리하여 시스템 특성을 최적화하는 'CQRS' 패턴을 설명합니다.
3. 인프라: 이벤트 기반 아키텍처에서 인프라 구성 요소의 결합 문제를 다룹니다. 단일 브로커 접근 방식의 위험성을 지적하고, 도메인 경계에 맞춰 브로커를 분리하는 '도메인-브로커' 패턴을 대안으로 제시하며 각 방식의 트레이드오프를 분석합니다.

결론적으로, 아키텍트는 특정 패턴을 맹목적으로 따르는 것이 아니라, 각 패턴이 제공하는 해결책의 본질을 이해하고 시스템의 특정 요구사항과 제약 조건에 맞춰 트레이드오프를 신중하게 평가해야 합니다.


--------------------------------------------------------------------------------


아키텍처 패턴의 이해

패턴, 스타일, 모범 사례, 솔루션의 구분

소프트웨어 아키텍처를 효과적으로 설계하기 위해서는 핵심 용어들을 명확히 구분하는 것이 중요합니다.

* 아키텍처 스타일 (Architecture Styles): 토폴로지, 물리적 아키텍처, 구현, 통신 스타일, 데이터 토폴로지 등의 차이로 구분되는 명명된 토폴로지를 의미합니다.
* 아키텍처 패턴 (Architecture Patterns): 특정 맥락에서 반복적으로 발생하는 문제에 대한 해결책을 의미합니다. 이는 개념적인 해결책으로, 특정 기술이나 구현에 종속되지 않습니다.
* 모범 사례 (Best Practices): 특정 상황이 발생하면 아키텍트가 항상 해당 방법을 적용해야 한다는 의무를 암시하는 용어입니다. 이는 아키텍트가 비판적 사고 없이 특정 솔루션을 따르게 만들 수 있는 위험이 있습니다. 패턴은 '모범'이 아닌, 맥락에 맞는 '적절한' 해결책을 찾는 데 중점을 둡니다.
* 솔루션 (Solutions): 소프트웨어 개발의 도구, 프레임워크, 라이브러리 등은 하나 이상의 패턴을 캡슐화한 구체적인 구현체입니다. 아키텍트의 올바른 접근 방식은 먼저 가장 적합한 패턴을 식별하고, 그 후에 해당 패턴을 가장 잘 구현할 수 있는 솔루션(도구, 프레임워크 등)을 선택하는 것입니다.

핵심 아키텍처 패턴 분석

재사용: 도메인과 운영 관심사의 분리

마이크로서비스와 같은 분산 아키텍처에서는 서비스 간의 결합도를 낮추는 것이 중요한 설계 목표입니다. 이로 인해 "결합보다 중복이 낫다"는 원칙이 자주 언급됩니다. 예를 들어, 두 서비스가 고객 프로필 정보를 교환할 때, 각 서비스는 독립적인 내부 데이터 표현을 유지하고 JSON과 같은 느슨하게 결합된 방식으로 정보를 전달합니다.

하지만 모니터링, 로깅, 인증/인가, 서킷 브레이커와 같은 운영 기능은 모든 서비스에 일관되게 적용되어야 하며, 높은 수준의 결합(표준화)이 오히려 유리합니다. 각 팀이 이러한 기능을 개별적으로 관리하면 표준화된 도구의 일관된 업그레이드나 적용 여부 확인이 어려워지는 등 혼란이 발생할 수 있습니다. 이처럼 도메인 로직의 독립성과 운영 기능의 일관성이라는 상충되는 요구사항을 해결하기 위해 '도메인 관심사와 운영 관심사의 분리'라는 패턴이 필요합니다.

구현 1: 육각형 아키텍처 (포트와 어댑터)

육각형 아키텍처(Hexagonal Architecture) 또는 포트와 어댑터(Ports and Adapters) 패턴은 도메인 로직을 애플리케이션의 핵심(육각형의 중앙)에 위치시키고, 외부 시스템과의 상호작용을 포트와 어댑터를 통해 처리합니다.

* 구조:
  * 애플리케이션 코어 (Application Core): 순수한 도메인 로직을 포함합니다.
  * 포트 (Ports): 비즈니스 이벤트, 관리, 알림, 영속성 등 외부와의 인터페이스를 정의합니다.
  * 어댑터 (Adapters): UI, 데이터베이스, 로깅, 테스트 스크립트, 이메일/SMS 전송 등 특정 기술을 사용하여 포트의 인터페이스를 구현합니다.



이 패턴의 창시자인 알리스터 코번(Alistair Cockburn)은 '육각형 아키텍처'라는 이름이 오해를 살 수 있어 '포트와 어댑터'라는 이름을 선호했지만, '육각형'이라는 이름이 더 널리 알려졌습니다.

* 잠재적 결함: 이 패턴이 처음 고안되었을 때는 데이터베이스를 단순히 교체 가능한 외부 어댑터 중 하나로 취급했습니다. 이는 데이터베이스 스키마가 비즈니스 로직과 밀접하게 연관되어 함께 진화해야 한다는 현대적인 도메인 주도 설계(Domain-Driven Design)의 관점과 상충됩니다. 따라서 마이크로서비스 아키텍처에서 '육각형 아키텍처'라는 용어를 사용할 때, 이것이 '관심사 분리'라는 일반적인 원칙을 의미하는지, 아니면 데이터를 격리하는 구식의 문자 그대로의 구현을 의미하는지 혼란을 야기할 수 있습니다.

구현 2: 서비스 메시와 사이드카 패턴

서비스 메시(Service Mesh)는 도메인과 운영 관심사를 분리하는 패턴을 구현하는 더 현대적이고 적합한 메커니즘을 제공하며, 특히 사이드카(Sidecar) 패턴을 활용합니다.

* 직교 결합 (Orthogonal Coupling): 수학에서 두 선이 직각으로 교차하는 것을 '직교'라고 하며, 이는 독립성을 의미합니다. 소프트웨어 아키텍처에서는 서로 다른 목적을 가지지만 완전한 솔루션을 위해 교차해야 하는 두 부분이 '직교적으로 결합'될 수 있습니다. 예를 들어, 서비스의 도메인 행위(예: 카탈로그 결제)와 운영 관심사(예: 모니터링)는 서로 독립적이지만 함께 작동해야 합니다.
* 사이드카 패턴: 사이드카는 이러한 직교 결합을 관리하는 재사용 패턴입니다. 마이크로서비스가 도메인 중심으로 구성될 때, 운영 관심사는 이 도메인들을 가로지르는 횡단 관심사(cross-cutting concern)가 됩니다. 사이드카는 이러한 운영 기능들을 서비스의 핵심 로직에서 분리하여 일관된 계층으로 격리시킬 수 있게 해줍니다.

사이드카 및 서비스 메시 패턴의 트레이드오프

장점	단점
격리된 결합을 생성하는 일관된 방법 제공	플랫폼별로 사이드카를 구현해야 함
인프라의 통일된 조정 가능	사이드카 컴포넌트가 크고 복잡해질 수 있음
팀별/중앙/혼합형으로 소유권 분산 가능	독립적인 팀 간 구현의 '편차(Drift)' 발생 가능

결론적으로, 아키텍트는 먼저 '도메인과 운영 관심사의 분리'라는 패턴을 식별한 후, 육각형 아키텍처(보편적)나 서비스 메시(마이크로서비스에 적합)와 같은 구현 방식 중 현재 아키텍처에 가장 적합한 것을 선택해야 합니다.

통신: 분산 시스템의 상호작용 모델

많은 통신 패턴은 이벤트 기반 아키텍처(Event-Driven Architecture, EDA)에서 유래했지만, 메시지나 이벤트를 사용하는 모든 분산 아키텍처에 적용될 수 있습니다.

오케스트레이션 대 코레오그래피

이 두 패턴은 여러 도메인 서비스가 협력하여 하나의 워크플로우를 구성하는 방식을 다룹니다.



* 오케스트레이션 (Orchestration): '오케스트레이터'라는 별도의 중앙 조정자 서비스가 워크플로우의 흐름을 명시적으로 제어하고 각 도메인 서비스에 작업을 지시합니다.
  * 장점:
    * 중앙화된 워크플로우: 상태, 행위, 제약 조건 등을 중앙에서 관리하여 복잡성 관리에 용이합니다.
    * 오류 처리: 워크플로우의 상태를 소유하므로 오류 처리가 용이합니다.
    * 복구성: 특정 서비스의 일시적 장애 시 재시도 로직을 쉽게 추가할 수 있습니다.
    * 상태 관리: 워크플로우의 현재 상태를 쿼리할 수 있습니다.
  * 단점:
    * 응답성: 모든 통신이 오케스트레이터를 거치므로 처리량 병목 현상이 발생할 수 있습니다.
    * 내결함성: 오케스트레이터 자체가 단일 실패 지점(Single Point of Failure)이 될 수 있습니다.
    * 확장성: 조정 지점이 추가되어 잠재적 병렬성을 제한하므로 확장성이 떨어집니다.
    * 서비스 결합: 오케스트레이터와 도메인 서비스 간에 강한 결합이 생성됩니다.
* 코레오그래피 (Choreography): 중앙 조정자 없이 각 서비스가 발생하는 이벤트를 구독하고 그에 따라 자율적으로 반응하며 상호작용합니다.
  * 장점:
    * 응답성: 단일 병목 지점이 적어 병렬 처리 기회가 많습니다.
    * 확장성: 조정 지점이 없어 독립적인 확장이 용이합니다.
    * 내결함성: 단일 실패 지점이 없어 내결함성이 높습니다.
    * 서비스 분리: 서비스 간 결합도가 낮습니다.
  * 단점:
    * 분산된 워크플로우: 워크플로우 소유자가 없어 오류 및 예외 조건 관리가 어렵습니다.
    * 상태 관리: 중앙 상태 관리자가 없어 진행 중인 상태 파악이 어렵습니다.
    * 오류 처리: 각 도메인 서비스가 워크플로우에 대한 더 많은 지식을 가져야 하므로 오류 처리가 복잡합니다.
    * 복구성: 재시도와 같은 조치를 수행할 중앙 조정자가 없어 복구성이 떨어집니다.

CQRS (Command-Query Responsibility Segregation)

CQRS는 데이터베이스와의 상호작용을 '명령(Command, 쓰기 작업)'과 '조회(Query, 읽기 작업)'라는 두 가지로 분리하는 데이터 통신 패턴입니다.



* 작동 방식: 쓰기 요청은 하나의 데이터 저장소(Command 모델)로 보내지고, 이 데이터는 일반적으로 비동기적으로 읽기 요청을 처리하는 별도의 데이터 저장소(Query 모델)로 동기화됩니다.
* 장점:
  * 읽기와 쓰기의 부하가 크게 다를 때 각 작업에 최적화된 아키텍처 특성(예: 데이터 모델, 확장성 전략)을 독립적으로 적용할 수 있습니다.
  * 보안 및 기타 이유로 읽기 작업과 쓰기 작업을 물리적으로 분리하는 요구사항을 충족시킬 수 있습니다.

인프라: 브로커-도메인 패턴

이벤트 기반 아키텍처(EDA)에서는 이벤트 브로커(토픽 또는 큐)가 핵심 인프라 요소입니다. 이때 브로커를 어떻게 구성하느냐에 따라 아키텍처 전체의 특성이 달라질 수 있습니다.



단일 브로커 접근 방식

시스템의 모든 서비스가 단 하나의 중앙 브로커를 통해 통신하는 방식입니다.



단일 브로커 패턴의 트레이드오프

장점	단점
중앙화된 검색 (Discovery)	내결함성 저하 (단일 실패 지점)
최소한의 인프라 구성	처리량 한계 (병목 가능성)

도메인-브로커 패턴 (Domain-Broker Pattern)

단일 브로커 방식의 단점을 보완하기 위해, 도메인-브로커 패턴은 인프라를 도메인의 세분성(granularity)에 맞춰 분할합니다. 즉, 서로 관련된 서비스 그룹(도메인)마다 별도의 브로커를 할당하는 방식입니다.



도메인-브로커 패턴의 트레이드오프

장점	단점
더 나은 격리(Isolation) 제공	큐/토픽 검색의 어려움 증가
아키텍처의 도메인 경계와 일치	더 많은 인프라로 인한 비용 증가
더 나은 확장성	유지보수해야 할 구성 요소 증가

결론적으로, 아키텍트는 서비스 검색의 용이성과 도메인 격리를 통한 내결함성 및 확장성 향상 사이에서 균형을 맞추며, 시스템의 요구사항에 가장 적합한 인프라 패턴을 선택해야 합니다.
