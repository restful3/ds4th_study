# 모듈형 모놀리식 아키텍처 스타일에 대한 브리핑

## Executive Summary

**모듈형 모놀리식 아키텍처**는 단일 단위로 배포되는 **모놀리식(monolithic)** 시스템의 단순성과 비용 효율성을 유지하면서, **비즈니스 도메인**에 따라 기능을 분할하여 높은 수준의 **모듈성**을 확보하는 아키텍처 스타일입니다. **도메인 주도 설계(Domain-Driven Design, DDD)** 의 확산과 함께 인기를 얻었으며, 기술 계층이 아닌 비즈니스 기능에 따라 코드를 구성하는 것이 핵심 특징입니다. 예를 들어, 전통적인 계층형 아키텍처의 네임스페이스가 com.app.presentation.customer.profile이라면, 모듈형 모놀리식에서는 com.app.customer.profile과 같이 도메인을 중심으로 구성됩니다.

이 아키텍처는 **모놀리식 구조**와 **모듈식 구조** 두 가지 옵션을 제공합니다. 모놀리식 구조는 단일 코드베이스에서 네임스페이스로 모듈을 구분하여 가장 단순하지만, 엄격한 거버넌스가 없으면 모듈 경계가 무너져 **'빅 볼 오브 머드(Big Ball of Mud)'** 가 될 위험이 있습니다. 반면 모듈식 구조는 각 모듈을 독립적인 **아티팩트**(예: JAR, DLL)로 개발하여 배포 시 결합하므로 경계가 명확하지만, 모듈 간 의존성이 높을 경우 복잡성이 증가합니다.

주요 강점은 **단순성**, **낮은 총비용**, 그리고 **모듈성**입니다. 분산 아키텍처의 복잡성 없이 시스템을 구축하고 유지할 수 있습니다. 그러나 모놀리식 배포의 본질적인 한계로 인해 **확장성**, **탄력성**, **내결함성**과 같은 운영 특성에서는 매우 취약합니다. 예산과 시간이 제한적이거나, 시스템의 아키텍처 방향이 불분명한 신규 프로젝트에 이상적인 출발점이며, 나중에 더 복잡한 분산 아키텍처로 진화할 수 있는 기반을 제공합니다.

![모듈형 모놀리식 아키텍처 개요](unnamed.png)

--------------------------------------------------------------------------------


## 1. 모듈형 모놀리식 아키텍처 개요

### 정의 및 인기

모듈형 모놀리식 아키텍처는 **단일 소프트웨어 단위**(예: WAR, EAR, .NET 어셈블리)로 배포되는 모놀리식 아키텍처입니다. 핵심적인 차별점은 **기술적 기능**(프레젠테이션, 비즈니스, 퍼시스턴스 등)이 아닌, **비즈니스 도메인**을 중심으로 기능을 분할하고 구성한다는 점입니다. 도메인 주도 설계(DDD)의 광범위한 도입으로 인해 이 아키텍처 스타일의 인기가 크게 증가했습니다.

### 토폴로지

이 아키텍처는 **도메인 영역**별로 기능이 그룹화된 **단일 배포 단위**로 정의됩니다. 전통적인 **계층형 아키텍처**가 **기술적 관심사**를 기준으로 컴포넌트를 구성하는 반면, 모듈형 모놀리식은 주로 **도메인**을 기준으로 컴포넌트를 구성합니다.

* 계층형 아키텍처 예시: com.app.presentation.customer.profile (세 번째 노드가 기술 계층인 'presentation'을 나타냄)
* 모듈형 모놀리식 예시: com.app.customer.profile (두 번째 노드가 비즈니스 도메인인 'customer'를 나타냄)

도메인 내에서 복잡성이 증가하면 com.app.customer.profile.presentation과 같이 기술적 관심사에 따라 하위 구분을 할 수 있습니다.

## 2. 구조적 옵션

모듈형 모놀리식 아키텍처는 도메인(또는 하위 도메인)을 나타내는 모듈로 구성되며, 이 모듈을 조직하는 두 가지 주요 구조가 있습니다.

### 모놀리식 구조 (Monolithic Structure)

시스템을 구성하는 모든 모듈이 **단일 소스 코드 저장소**에 포함됩니다. 각 모듈은 고유한 상위 디렉터리나 **네임스페이스**로 구분됩니다.

* **장점**: 전체 소스 코드가 한곳에 있어 유지 관리, 테스트, 배포가 용이하고 구조가 단순합니다.
* **단점**: 엄격한 **거버넌스**가 없으면 개발자들이 모듈 간에 코드를 과도하게 재사용하거나 통신을 허용하여, 잘 설계된 아키텍처가 구조 없는 **'빅 볼 오브 머드(Big Ball of Mud)' 안티패턴**으로 변질될 위험이 큽니다.

### 모듈식 구조 (Modular Structure)

각 모듈이 **독립적인 아티팩트**(예: Java의 JAR 파일, .NET의 DLL 파일)로 표현되며, 배포 시점에 하나의 배포 단위로 통합됩니다.

* **장점**: 각 모듈이 독립적이므로 팀별로 별도의 코드 저장소에서 작업할 수 있습니다. **모듈 간의 경계**가 명확해지고 **관심사 분리**가 잘 이루어집니다. 대규모의 복잡한 시스템에 적합합니다.
* **단점**: 모듈 간 상호 의존성이 높은 경우 효과가 떨어지며, **의존성 관리** 문제로 인해 **'JAR Hell' 또는 'DLL Hell' 안티패턴**이 발생할 수 있습니다.

## 3. 모듈 간 통신

모듈 간 통신은 가급적 피해야 하지만, 많은 경우 필수적입니다. 예를 들어, '주문 접수' 모듈은 '재고 관리' 모듈 및 '결제 처리' 모듈과 통신해야 합니다.

### 피어 투 피어(Peer-to-Peer) 접근 방식

가장 간단한 방법으로, 한 모듈의 클래스가 다른 모듈의 클래스를 **직접 인스턴스화**하고 메서드를 호출합니다.

* **문제점**: 모듈 간 **결합도**가 높아져 '빅 볼 오브 머드'로 이어지기 쉽습니다. 모듈식 구조에서는 컴파일 시점의 의존성 관리가 필요하며, 이로 인해 'JAR/DLL Hell'이 발생할 수 있습니다.

### 중재자(Mediator) 접근 방식

모듈 사이에 **중재자 컴포넌트**를 두어 **추상화 계층**을 만듭니다. 중재자는 요청을 받아 적절한 모듈로 라우팅하는 **오케스트레이터** 역할을 합니다.

* **장점**: 모듈들을 서로 **분리(decouple)** 하여 독립성을 유지하고 아키텍처를 단순화합니다.
* **단점**: 모든 모듈이 중재자에 **결합(couple)** 되므로, 모든 결합이 제거되는 것은 아닙니다.

## 4. 데이터 토폴로지 및 클라우드 고려사항

### 데이터 토폴로지

모듈형 모놀리식은 단일 단위로 배포되므로 일반적으로 **단일 모놀리식 데이터베이스 토폴로지**를 기반으로 합니다. 이는 모듈 간 **데이터 공유**를 통해 통신을 줄이는 데 도움이 됩니다. 그러나 모듈들이 서로 독립적이고 특정 기능을 수행하는 경우, 각 모듈이 자체적인 **컨텍스트 데이터**를 가진 별도의 데이터베이스를 가질 수도 있습니다.

### 클라우드 고려사항

모놀리식 특성으로 인해 클라우드 환경이 제공하는 **주문형(on-demand) 배포**의 이점을 충분히 활용하기 어려워 일반적으로 클라우드에 적합하지 않습니다. 그럼에도 불구하고, 이 스타일로 구현된 소규모 시스템은 파일 스토리지, 데이터베이스, 메시징과 같은 **클라우드 서비스**를 활용할 수 있습니다.

## 5. 주요 리스크 및 거버넌스

### 공통 리스크

* **과도한 크기**: 시스템이 너무 커져서 유지, 테스트, 배포가 어려워지는 것이 가장 큰 위험입니다. 변경에 시간이 오래 걸리거나, 예상치 못한 부분에서 오류가 발생하거나, 팀원 간 작업 충돌이 일어나는 것이 경고 신호입니다.
* **과도한 코드 재사용**: 지나친 코드 재사용은 **모듈 경계**를 모호하게 만들어 구조 없는 모놀리식으로 변질시킬 수 있습니다.
* **과도한 모듈 간 통신**: 모듈 간 통신이 너무 많다는 것은 도메인이 제대로 정의되지 않았다는 신호일 수 있습니다.

### 거버넌스

아키텍트는 **자동화된 거버넌스 도구**(예: ArchUnit, ArchUnitNet, PyTestArch)를 사용하여 아키텍처를 유지할 수 있습니다.

* **모듈 경계 준수**: 모든 소스 코드가 사전에 정의된 모듈의 네임스페이스 내에 있는지 확인합니다.
* **통신 범위 제어**: 모듈 간의 총 **의존성(결합 지점)** 수를 제한합니다.
* **의존성 제약**: 특정 모듈이 다른 특정 모듈과 통신하는 것을 금지하는 규칙을 적용합니다. 예를 들어, OrderPlacement 모듈이 Shipping 모듈에 직접 접근하지 못하도록 막을 수 있습니다.

## 6. 아키텍처 특성 평가

아키텍처 특성	구분	별점 평가
총비용	구조적	$(낮음)
분할 유형	구조적	도메인
아키텍처 퀀텀 수	구조적	1
단순성	구조적	⭐⭐⭐⭐⭐
모듈성	구조적	⭐⭐
유지보수성	엔지니어링	⭐⭐
테스트 용이성	엔지니어링	⭐⭐
배포 용이성	엔지니어링	⭐⭐
진화 가능성	엔지니어링	⭐⭐
응답성	운영	⭐⭐⭐⭐
확장성	운영	⭐
탄력성	운영	⭐
내결함성	운영	⭐

* **강점**: **단순성**(5점)과 **낮은 비용**이 가장 큰 장점입니다. **모듈성**(3점)은 도메인 간 관심사 분리를 통해 달성됩니다.
* **약점**: **확장성**, **탄력성**, **내결함성**은 모놀리식 구현의 한계로 인해 매우 낮습니다(1점). 시스템의 일부에서 메모리 부족이 발생하면 전체 애플리케이션이 중단됩니다.

## 7. 팀 토폴로지와의 정렬

모듈형 모놀리식 아키텍처는 **도메인 중심**이므로, 팀 또한 도메인에 따라 구성될 때 가장 잘 작동합니다 (예: **스트림 정렬 팀**, **복잡한 하위 시스템 팀**). UI 팀, 백엔드 팀 등 **기술적으로 구성된 팀**과는 잘 맞지 않는데, 이는 도메인 기반 변경 사항이 여러 기술 팀 간의 많은 소통과 조정을 요구하기 때문입니다.

## 8. 사용 시나리오

### 사용해야 할 경우

* **예산과 시간이 부족**할 때.
* 아키텍처 방향이 불분명한 **신규 시스템**을 시작할 때 (나중에 **분산 아키텍처**로 전환 가능).
* 팀이 **도메인 중심**으로 조직되어 있을 때.
* 시스템에 대한 대부분의 변경이 **도메인 기반**일 때.
* 팀이 **DDD**를 실천하고 있을 때.

### 사용하지 말아야 할 경우

* 높은 수준의 **확장성**, **탄력성**, **가용성**, **내결함성** 등이 요구될 때.
* UI나 데이터베이스 기술 교체와 같이 **기술 중심의 변경**이 잦을 때 (이 경우 **계층형 아키텍처**가 더 적합).

## 9. 적용 사례: EasyMeals

**EasyMeals**는 바쁜 직장인을 위한 소규모 음식 배달 서비스입니다. 예산이 제한적이고 확장성 요구가 높지 않아 **모듈형 모놀리식 아키텍처**가 적합합니다.

* 시스템 모듈:
  * com.easymeals.placeorder (주문 접수)
  * com.easymeals.payment (결제 처리)
  * com.easymeals.prepareorder (주문 준비)
  * com.easymeals.delivery (배달)
  * com.easymeals.recipes (레시피 관리)
  * com.easymeals.inventory (재료 재고 관리)
* 모듈 구성 예시 (PlaceOrder 모듈):
  * com.easymeals.placeorder.menu (메뉴 보기)
  * com.easymeals.placeorder.shoppingcart (장바구니)
  * com.easymeals.placeorder.customerdata (고객 정보)
  * com.easymeals.placeorder.checkout (주문 완료)

이 사례는 모듈형 모놀리식이 어떻게 비즈니스 도메인을 중심으로 기능을 분할하여 코드 탐색과 유지보수를 용이하게 하는지 보여줍니다. 이는 이 간단하고 직관적인 아키텍처 스타일의 강점을 잘 나타냅니다.
