---
lang: ko
format:
  html:
    toc: true
    toc-location: left
    toc-depth: 3
    theme: cosmo
    embed-resources: true
    code-fold: true
    code-tools: true
    smooth-scroll: true
    css: |
      body {
        margin-top: 0 !important;
        padding-top: 0 !important;
      }
      #quarto-header {
        display: none !important;
      }
      .quarto-title-block {
        display: none !important;
      }
      /* Center content with equal padding */
      body, #quarto-content, .content, #quarto-document-content, main, .main {
        max-width: 100% !important;
        width: 100% !important;
        margin: 0 auto !important;
        padding-left: 1em !important;
        padding-right: 1em !important;
        box-sizing: border-box !important;
      }
      .container, .container-fluid, article {
        max-width: 100% !important;
        width: 100% !important;
        margin: 0 auto !important;
        padding-left: 1em !important;
        padding-right: 1em !important;
        box-sizing: border-box !important;
      }
---

# 27장. 소프트웨어 아키텍처의 법칙, 재검토 (Kapitel 27. Die Gesetze der Software-Architektur, revisited)

이 작업은 AI의 도움으로 번역되었습니다. 피드백과 의견을 환영합니다: [translation-feedback@oreilly.com](mailto:translation-feedback@oreilly.com)

이미 [1장](#page--1-0)에서 우리는 소프트웨어 아키텍처의 세 가지 법칙을 설명했습니다:

- 소프트웨어 아키텍처의 모든 것은 트레이드오프(Kompromiss)입니다.
- *왜(Warum)*가 *어떻게(Wie)*보다 중요합니다.
- 대부분의 아키텍처 결정은 이진법적이지 않고, 극단 사이의 스펙트럼에서 움직입니다.

이 책의 거의 모든 예제가 이러한 법칙을 설명했으며, 이는 그들의 생성 역사를 나타냅니다. 우리가 첫 번째 판을 쓸 때, 소프트웨어 아키텍처와 관련하여 일반적으로 타당해 보이는 많은 것들을 찾아내어 *법칙*으로 정립하기를 희망했습니다. 놀랍게도 우리는 첫 번째 판에서 단 두 개의 법칙만 찾았고, 두 번째 판을 쓰면서 또 다른 법칙을 발견했습니다. 우리의 원래 의도에 충실하게, 이 세 가지 법칙은 매우 보편적인 것으로 보이며 소프트웨어 아키텍트에게 많은 중요한 관점을 제시합니다.

이 짧은 장에서 우리는 보여준 예제들을 통해 이러한 법칙을 다시 한 번 살펴보고, 트레이드오프 분석의 몇 가지 미묘한 차이를 지적할 것입니다.

# 첫 번째 법칙: 소프트웨어 아키텍처의 모든 것은 트레이드오프입니다 (Erstes Gesetz: Alles in der Softwarearchitekturist ein Kompromiss)

우리의 첫 번째 법칙은 소프트웨어 아키텍처의 가장 중요한 특징 중 하나입니다 - 모든 것은 트레이드오프입니다. 많은 사람들은 소프트웨어 아키텍트의 임무가 어려운 문제에 대한 완벽한 솔루션을 찾아내고 영웅이 되는 것이라고 생각하지만, 그런 경우는 드뭅니다. (아키텍트는 좋은 결정에 대해서는 거의 칭찬받지 못하지만, 나쁜 결정에 대해서는 항상 비난받습니다.) 아니요, 소프트웨어 아키텍처의 진정한 임무는 트레이드오프 분석입니다.

우리는 여러 가지 이유로 모든 아키텍트가 특정 접근 방식을 옹호하기보다는 트레이드오프의 객관적인 중재자로서의 명성을 확고히 해야 한다고 생각합니다.

첫째, 아키텍처에서의 전도(Evangelismus)는 장기적으로 위험합니다. 왜냐하면 어제의 검증된 방법이 내일의 안티패턴이 되는 경향이 있기 때문입니다. 아키텍트는 현재의 요인과 상황을 기반으로, 최선을 다해, 불완전한 지식으로 트레이드오프 결정을 내립니다. 그러나 결정 시점에 결정이 좋더라도, 소프트웨어 개발의 생태계는 끊임없이 진화하고 변화하므로, 상황이 점차 변하고 결정이 시간이 지남에 따라 약해지거나 무효화됩니다. 아키텍트가 이 솔루션을 옹호하기 위해 사회적 자본을 투자했다면, 나중에 결정을 변경해야 할 때 그의 명성이 손상될 수 있습니다. 입증되지 않은 결정에 신뢰성을 연결하는 것을 피하기 위해 기술 결정에서 항상 명확하고 객관적으로 유지하십시오.

둘째, 기업의 의사 결정자들은 열정적인 옹호자보다는 차분한 객관성을 더 찾습니다. 트레이드오프의 객관적인 분석을 위한 대화 상대로서의 명성을 쌓은 아키텍트는 기업에게 귀중한 자산입니다. 중요한 결정에 있어서, 의사 결정자들은 판단을 신뢰할 수 있는 사람을 원합니다. 그것이 바로 당신이어야 합니다.

몇 가지 소프트웨어 아키텍처 결정에서 트레이드오프 분석의 예를 살펴본 다음, 이해에 있어 흔한 간극을 논의하겠습니다.

### <span id="page-2-0"></span>**공유 라이브러리 대 공유 서비스 (Gemeinsame Bibliothek versus gemeinsamer Dienst)**

아키텍트들에게 흔한 수수께끼는 마이크로서비스나 EDA와 같은 분산 아키텍처에서의 공통 동작입니다: 빌드 시점에 각 서비스로 컴파일되는 공유 라이브러리를 사용해야 할까요, 아니면 다른 서비스들이 런타임에 호출하는 공유 서비스를 사용해야 할까요? [그림](#page-3-0) 27-1에 표시된 것처럼요.

<span id="page-3-0"></span>![](_page_3_Figure_0.jpeg)

그림 27-1. 솔루션이 공통 기능을 위해 공유 라이브러리를 사용해야 할까요, 아니면 공유 서비스를 사용해야 할까요?

[그림](#page-3-0) 27-1에서 왼쪽의 서비스는 공통 동작을 캡슐화하고, 다른 서비스들이 이에 접근하기 위해 호출합니다. 오른쪽에는 배포 전에 각 서비스로 컴파일되는 공유 라이브러리가 있습니다. 무엇이 더 나을까요?

이제 독자들은 이러한 모든 질문에 대한 답을 알고 있습니다: "상황에 따라 다릅니다!" 하지만 불가피한 후속 질문에도 답해야 합니다: "무엇에 따라 다릅니까?" 소프트웨어 아키텍처의 많은 비자명한 결정과 마찬가지로, 이 질문에 대한 답은 즉시 명백하지 않으므로, 이제 아키텍트로서 트레이드오프 분석을 수행할 때입니다.

먼저 이 솔루션에 중요한 모든 맥락 의존적인 트레이드오프를 결정해야 합니다. 이 목록은 기업과 솔루션에 매우 특정적이므로, 기업, 기술 환경, 팀의 역량, 예산 및 트레이드오프 옵션에 영향을 미치는 모든 다른 요인에 대한 지식에 의존해야 합니다. 이 솔루션을 위해 우리는 다음과 같은 관련 요인 목록을 작성했습니다:

### *이기종 코드 (Heterogener Code)*

솔루션이 여러 플랫폼용으로 작성된 경우, 서비스로 작업하는 것이 더 쉽습니다. 왜냐하면 기술 스택과 관계없이 호출자는 네트워크를 통해 서비스에 접근하므로 구현 플랫폼은 중요하지 않기 때문입니다. 라이브러리의 경우, 팀은 각 기술 스택에 대한 코드 버전이 필요하며 버전을 동기화 상태로 유지해야 하므로, 프로젝트의 전체 복잡성이 크게 증가합니다.

### *높은 코드 변동성 (Hohe Volatilität des Codes)*

코드 변동성(volatility)이 코드가 얼마나 빨리 변경되는지를 측정한다는 것을 기억하십시오 (*churn*이라고도 함). 따라서 라이브러리를 변경해야 하는 경우, 새로운 기능을 사용하기 위해 모든 서비스를 다시 컴파일하고 배포해야 합니다.

### *변경 버전 관리 능력 (Fähigkeit, Änderungen zu versionieren)*

버전 관리는 서비스보다 라이브러리에서 훨씬 쉽습니다. 라이브러리를 업데이트해야 하는 경우, 팀은 컴파일 시점에 버전 차이를 해결하고 필요한 것만 정확히 빌드할 수 있습니다. 서비스의 경우, 버전 정보를 런타임에 결정해야 하므로 서비스와의 상호작용이 복잡해집니다.

### *변경의 전체 위험 (Gesamtrisiko der Veränderung)*

변경 위험은 라이브러리가 더 낫습니다. 라이브러리 코드를 변경하고 서비스에 성공적으로 컴파일하면, 작동한다고 신뢰할 수 있습니다. 반면에 서비스는 컴파일 검사 없이 변경될 수 있어, 호출 시점에 런타임 오류의 가능성이 높아집니다.

#### *성능 (Leistung)*

라이브러리가 명백히 더 성능이 좋습니다. 왜냐하면 공유 기능의 호출이 프로세스 내 호출이기 때문입니다. 서비스에 필요한 네트워크 호출과는 대조적입니다. 이러한 호출은 네트워크 지연 및 기타 요인으로 인해 프로세스 내 호출보다 훨씬 느립니다.

#### *내결함성 (Fehlertoleranz)*

[9장](#page--1-0)에서 논의한 것처럼, 서비스에 대한 런타임 접근에서는 항상 네트워크 문제가 발생할 수 있으며, 여기서 다루는 서비스도 마찬가지입니다. 라이브러리는 더 나은 내결함성을 제공합니다: 서비스를 컴파일, 테스트 및 배포한 후에는 안정적이라고 신뢰할 수 있습니다.

#### *확장성 (Skalierbarkeit)*

성능과 마찬가지로, 서비스 간 호출도 지연으로 인해 어려움을 겪으며, 이는 확장성에 영향을 미칩니다. 따라서 라이브러리는 더 나은 확장성을 제공합니다. 왜냐하면 공통 동작에 대한 접근이 매우 효율적인 프로세스 내 호출이기 때문입니다.

중요한 요인의 목록을 정한 후, 각 기준에 대해 각 요인이 얼마나 적합한지 비교하는 행렬을 만들 수 있습니다 ([표](#page-6-0) 27-1 참조).

<span id="page-6-0"></span>표 27-1. 공유 서비스와 공유 라이브러리 간의 트레이드오프

| 요인                                      | 공유<br>라이브러리 | 공유<br>서비스 |
|---------------------------------------------|--------------------------|---------------------|
| 이기종<br>코드                         | -                        | +                   |
| 높은<br>코드<br>변동성         | -                        | +                   |
| 변경<br>버전 관리<br>능력 | +                        | -                   |
| 변경의<br>전체<br>위험          | +                        | -                   |
| 성능                                    | +                        | -                   |
| 내결함성                              | +                        | -                   |
| 확장성                              | +                        | -                   |

긍정적인 측면의 합계는 공유 라이브러리를 승자로 만듭니다... 적어도 이러한 요인들과 이 맥락에서는요. 이것이 문제의 솔루션일 수도 있고 아닐 수도 있습니다 - 아마도 추가 가중치를 부여해야 할 수도 있습니다 ([두 번째 결론: 한 번만 할 수는 없습니다](#page-15-0) 참조) - 하지만 이제 당신과 팀은 어떤 힘들이 작용하고 있는지에 대한 좋은 아이디어를 갖게 되었습니다.


### **동기 대 비동기 메시징 (Synchrone versus asynchrone Nachrichtenübermittlung)**

다음 트레이드오프 분석을 고려해보십시오: 팀이 거래 정보를 Notification 서비스와 Analytics 서비스 모두에 보내기 위해 분산 아키텍처를 구축하고 있으며, 이 동작을 구현하기 위해 *큐(Warteschlange)*를 사용할지 *토픽(Topic)*을 사용할지 결정하려고 합니다.

첫 번째 옵션은 큐 또는 지점 간 통신 프로토콜입니다. [2장](#page--1-0)에서 배운 것처럼, 발행자는 누가 메시지를 받는지 알고 있습니다. 여러 소비자에게 도달하려면 발행자는 각 소비자에 대한 큐에 메시지를 보내야 합니다. Trading 서비스가 큐를 사용하여 Analytics 서비스와 Reporting 서비스에 거래에 대해 알리고 싶다면, 구현은 [그림](#page-8-0) 27-2와 같습니다.

<span id="page-8-0"></span>![](_page_8_Figure_0.jpeg)

그림 27-2. 큐를 사용하여 Notification과 Analytics에 거래 정보 전달하기

[그림](#page-8-0) 27-2에서 Trading 서비스는 큐를 통해 각 소비자에게 메시지를 발행합니다. 각 소비자는 자신의 큐를 가지고 있으며, 발신자는 각각에 메시지를 보냅니다.

<span id="page-9-0"></span>![](_page_9_Figure_0.jpeg)

그림 27-3. 토픽을 사용하여 Notification과 Analytics에 거래 정보 전달하기

대안 토폴로지는 대신 *토픽*을 사용하며, 이는 지점 간 통신 대신 브로드캐스트 통신을 구현합니다. [그림](#page-9-0) 27-3에서 Trading 서비스는 토픽에 단일 메시지를 게시합니다. 각 소비자는 토픽을 구독하고 메시지가 나타나면 알림을 받습니다. 이 경우 메시지 발행자는 소비자가 누구인지 알지 못하거나 신경 쓰지 않습니다 - 팀은 다른 소비자나 생산자를 변경하지 않고 언제든지 새로운 소비자를 추가할 수 있습니다.

두 옵션 모두 실현 가능합니다. 그렇다면 어떻게 결정해야 할까요? 트레이드오프 분석을 수행함으로써입니다.

큐를 사용하면 Trading 서비스가 알려야 하는 각 서비스에는 자체 큐가 필요합니다. Notification 서비스와 Analytics 서비스가 다른 정보를 필요로 하는 경우 각 큐에 다른 메시지를 보낼 수 있으므로 실용적입니다. Trading 서비스는 통신하는 각 시스템에 대해 알고 있으므로, 다른 (잠재적으로 악의적인) 서비스가 "엿듣기"하기 어렵게 만듭니다. 이는 특히 보안이 우선순위 목록의 맨 위에 있을 때 유리합니다. 각 큐가 독립적이므로 별도로 모니터링할 수 있으며 필요에 따라 독립적으로 확장할 수도 있습니다. Trading 서비스는 클라이언트와 긴밀하게 결합되어 있습니다 - 정확히 몇 개인지 알고 있습니다. 그러나 Compliance 서비스에 메시지를 보내려면 Trading 서비스를 수정하여 세 번째 큐에 메시지를 보내야 합니다.

[표](#page-11-0) 27-2는 이 프로젝트에 큐를 사용할 때의 트레이드오프를 요약합니다.

<span id="page-11-0"></span>표 27-2. 큐 사용 시 트레이드오프

| 장점                                                                                        | 단점                                                                        |
|------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------|
| 서로 다른<br>소비자를 위한<br>이기종<br>메시지<br>지원                 | 높은<br>결합도                                              |
| 큐<br>깊이의<br>독립적인<br>모니터링<br>가능                  | Trading 서비스가<br>여러<br>큐에<br>연결해야<br>함 |
| 더<br>높은<br>보안                                                                             | 추가<br>인프라<br>필요                                       |
| 덜<br>확장 가능함<br>(더 많은<br>소비자를 위해<br>큐를<br>추가해야<br>함) | 확장성과<br>진화성에<br>대한<br>좋은<br>지원       |

토픽에 대해서도 같은 작업을 해봅시다. 한 가지 장점은 명백합니다: 토픽은 극도로 확장 가능합니다. 예를 들어 규정 준수에 관심이 있는 새로운 소비자는 기존 동작을 변경하지 않고 이 주제를 구독할 수 있습니다. 그러나 이 장점에는 단점도 있습니다: 모든 소비자는 토픽에서 동일한 메시지를 소비해야 하므로 *스탬프 결합(Stempelkopplung)*이 발생할 수 있습니다 ([그림](#page--1-1) 9-9 참조). 그리고 모든 소비자가 전체 메시지를 읽을 수 있으므로 보안 문제가 있습니다: 모든 사람이 전체 메시지를 읽을 수 *있어야* 할까요?

이러한 관점을 염두에 두고 트레이드오프 표를 작성할 수 있으며, [표](#page-12-0) 27-3에서 볼 수 있습니다.

<span id="page-12-0"></span>표 27-3. 토픽 사용 시 트레이드오프

| 장점                                              | 단점                                                                              |
|------------------------------------------------------|---------------------------------------------------------------------------------------|
| 낮은<br>결합도                                 | 모든<br>소비자를 위한<br>단일<br>메시지                              |
| Trading 서비스가<br>하나의<br>메시지만<br>생성 | 개별<br>소비자를<br>모니터링하거나<br>확장할<br>수<br>없음 |
| 더<br>높은<br>확장성/진화성             | 덜<br>안전함                                                                     |
|                                                      | 확장성을 위한<br>옵션이<br>적음                                   |

트레이드오프 분석을 수행한 후, 이 솔루션에 대한 조직의 목표를 상기시키고 어떤 옵션이 더 적합한지 파악해야 합니다. 보안이 더 중요하다면 아마도 큐를 선택해야 합니다. 조직이 빠르게 성장하고 있고 다른 서비스들도 거래에 관심이 있다면, 확장성이 우선순위가 될 수 있으며, 이는 토픽 사용으로 이어질 것입니다.

### **첫 번째 결론: 누락된 트레이드오프 (Erste Folgerung: Fehlende Kompromisse)**

우리의 첫 번째 법칙에는 두 가지 결론이 있습니다. 첫 번째는 다음과 같습니다:

*트레이드오프가 아닌 것을 발견했다고 생각한다면, 아마도 트레이드오프를 인식하지 못한 것입니다... 아직은요.*

### —결론 1 (Korollar 1)

소프트웨어 아키텍처 결정의 핵심은 트레이드오프 분석이지만, 트레이드오프가 없어 보이는 결정에 직면하면 어떻게 될까요? 우리의 조언은: 계속 찾으십시오!

코드 재사용을 고려해보십시오. 이것은 확실히 순수하게 유익한 관행이죠? 조직이 더 많은 코드를 재사용할수록 작성해야 할 코드가 줄어들어 시간과 중복 작업이 절약됩니다.

두 가지 요인이 코드 재사용이 얼마나 효과적일지를 결정합니다. 아키텍트들은 종종 첫 번째는 발견하지만 두 번째는 놓칩니다. 첫 번째 요인은 *추상화*입니다: 이 코드를 추상화하고 여러 호출 지점에서 사용할 수 있다면, 재사용에 좋은 후보입니다. 두 번째 요인은 *낮은 변동성*입니다. 팀이 지속적으로 변경되는 코드 모듈을 재사용하면 전체 시스템에 혼란이 발생합니다. 공유 코드가 변경될 때마다 해당 코드를 호출하는 모든 사람이 그 변경에 적응해야 합니다. 파괴적인 변경이 아니더라도 팀은 변경이 아무것도 망가뜨리지 않았는지 확인해야 합니다. 아키텍처가 부적절하게 코드를 재사용하면, 팀은 결국 전체 아키텍처를 변경하는 변경 사항을 찾게 됩니다. 이것은 오케스트레이션 지향 SOA 아키텍처 스타일([17장](#page--1-0) 참조)에서 아키텍트들이 얻은 가장 중요한 교훈 중 하나였습니다. 무엇보다도 가능한 한 많은 코드를 재사용하는 것을 목표로 했습니다. 실제로 이러한 아키텍처로 작업한 팀들은 유사(流砂, quicksand)에 빠졌습니다: 모든 변경은 시스템에서 예측할 수 없는 부작용을 일으킬 가능성이 있었습니다.

이것이 숨겨진 트레이드오프입니다: 효과적인 코드 재사용에는 좋은 추상화 *그리고* 낮은 변동성이 필요합니다. 이것이 아키텍처에서 재사용에 가장 성공적인 대상이 "배관(Klempnerhandwerk)"인 이유입니다: 기술 프레임워크, 라이브러리, 플랫폼 등입니다. 대부분의 애플리케이션에서 가장 빠르게 변경되는 부분은 도메인(소프트웨어를 작성하는 동기)이므로, 도메인 개념은 재사용에 나쁜 후보입니다. (이것이 DDD의 제한된 컨텍스트(bounded context) 원칙의 기초가 된다는 점에 주목하십시오 - 어떤 제한된 컨텍스트도 다른 제한된 컨텍스트의 구현 세부 사항을 재사용할 수 없습니다).

#### **왜 우리는 좋은 것들을 가질 수 없나 - 트레이드오프! (WARUM WIR KEINE SCHÖNEN DINGE HABEN KÖNNEN - KOMPROMISSE!)**

전문 컨설턴트로서 우리 고객들은 종종 다음과 같은 요청을 합니다: "우리는 높은 민첩성과 빠른 배포를 가능하게 하는 높은 수준의 분리를 가진 마이크로서비스와 분산 아키텍처의 아이디어를 좋아합니다. 하지만 팀이 끊임없이 새로운 코드를 작성하지 않아도 되도록 높은 수준의 제도적 재사용도 원합니다."

여기서 나쁜 소식을 전해야 합니다: 둘 다 가질 수는 없습니다. 왜냐하면 시스템의 재사용은 결합을 통해 달성되기 때문입니다. 어떤 조직도 둘 다 가질 수 없습니다: 분리 *그리고* 높은 수준의 재사용. 이 두 가지는 근본적으로 양립할 수 없습니다. 이것은 조직이 중요한 트레이드오프를 오해할 수 있는 전형적인 예입니다.

### <span id="page-15-0"></span>**두 번째 결론: 한 번만 할 수는 없습니다 (Zweite Folgerung: Du kannst es nicht nur einmal tun)**

아키텍트가 단 한 번의 트레이드오프 분석만 수행할 수 있다면 좋을 것입니다 - 단순히 *철저하게* 생각하고 모든 워크플로우에 대해 코레오그래피를 사용하기로 일단 결정하면 됩니다. 그러나 트레이드오프 분석에는 두 가지 문제가 있습니다. 첫째, 결정에 기여하는 (기술적 및 기타) 변수가 수십 개 또는 수백 개인 경우가 많습니다: 복잡성, 팀 경험, 예산, 팀 토폴로지, 일정 압박... 목록은 끝이 없습니다. 이러한 변수의 미묘한 차이가 특정 분석을 한 방향 또는 다른 방향으로 이끌 수 있으므로, 이것은 지속적인 연습입니다. 아키텍트가 이 솔루션의 미래 적용에 더 이상 유효하지 않을 수 있는 가정에 기반한 포괄적이고 반영구적인 결정을 내리는 것은 위험합니다.

이 결과를 아키텍트의 직업 안정성으로 생각하십시오. 우리는 겉보기에 유사한 상황에서도 반복적으로 트레이드오프를 분석해야 합니다. 이것은 실제 작업이 영구적으로 완벽한 결정을 내리는 것이 아니라 트레이드오프를 분석하는 것이라는 생각을 강조합니다.

# 두 번째 법칙: 왜가 어떻게보다 중요합니다 (Zweites Gesetz: Das Warum ist wichtiger als das Wie)

우리의 두 번째 법칙은 *왜*가 *어떻게*보다 중요하다는 것을 강조합니다. 경험 있는 아키텍트로서 우리는 기존 시스템을 보고 누군가에게 *어떻게* 작동하는지 말할 수 있습니다. 그러나 이전 아키텍트가 다른 옵션보다 이 옵션을 선호한 *이유*가 명확하지 않은 결정이 있을 것입니다. 왜냐하면 그가 최종 솔루션과 함께 모든 결정 기준을 기록하지 않았기 때문입니다.

이것이 우리가 아키텍처 다이어그램 *그리고* ADR을 사용하는 것이 얼마나 중요한지 강조하는 이유입니다([21장](#page--1-0) 참조). 모든 트레이드오프 분석은 솔루션에 포함되지 않은 엄청난 양의 정보를 제공합니다. 미래의 아키텍트(그것은 당신일 수 있습니다)가 단지 *이유*를 이해하기 위해 분석을 다시 수행해야 하는 것을 방지하기 위해 이 분석을 (알려진 트레이드오프 및 솔루션의 제약과 함께) 문서화하는 것이 중요합니다.

### **맥락을 벗어난 안티패턴 (Aus dem Kontext gerissenes Antipattern)**

트레이드오프 분석에서 흔한 패턴은 *"맥락 외(Out of Context)"* 패턴입니다. 이 패턴은 아키텍트가 트레이드오프를 알고 있지만 현재 맥락에서 그것들을 어떻게 *가중*해야 하는지 모를 때 발생합니다.

["공유 라이브러리 대 공유 서비스"](#page-2-0)에서 수행한 트레이드오프 분석을 고려해보십시오. 객관적으로 보면, 공유 라이브러리가 긍정적인 평가가 부정적인 평가보다 많기 때문에 선호되는 솔루션처럼 보입니다. 그러나 이 트레이드오프 분석에는 가능한 오류가 있습니다: 모든 기준이 동일한 가중치를 가지고 있습니까?

팀이 여러 플랫폼에 코드를 가지고 있다고 상상해보십시오. 성능이나 확장성에 과도하게 신경 쓰지 않지만, 공통 동작을 관리하는 깔끔한 방법을 원합니다. 이 경우 트레이드오프의 처음 두 기준이 훨씬 높은 우선순위를 가지므로 공유 서비스를 선택해야 합니다. 게다가 팀은 이미 완화해야 할 문제를 파악했습니다.

아키텍트는 트레이드오프 기준을 작성할 때 경험에 의존하지만, 올바른 솔루션을 찾기 위해 이러한 기준에 가중치를 부여해야 합니다. 일반적인 트레이드오프 분석은 그다지 유용하지 않습니다 - 특정 맥락에 적용될 때만 가치가 있습니다.

## 극단 사이의 스펙트럼 (Das Spektrum zwischen den Extremen)

첫 번째 판에서 우리는 단 두 개의 법칙만 식별했습니다. 그러나 점차 우리는 세 번째 법칙이 있다는 것을 깨달았습니다:

*대부분의 아키텍처 결정은 이진법적이지 않고, 극단 사이의 스펙트럼에서 움직입니다.*

—소프트웨어 아키텍처의 세 번째 법칙

아름답고 명확한 이진 결정이 있는 세상에서 사는 것은 좋을 것입니다 - 하지만 그 세상에는 소프트웨어 아키텍처가 없습니다. 소프트웨어 아키텍처의 중요한 개념에 대한 포괄적인 정의를 찾는 것이 얼마나 어려운지 자주 관찰됩니다: 아키텍처 대 디자인, 오케스트레이션 대 코레오그래피, 토픽 대 큐 등등. 그 이유는 결정 기준이 이진법적이지 않고 상당히 혼란스러운 스펙트럼에서 움직이기 때문입니다.

["아키텍처 대 디자인"](#page--1-0)에서 우리는 아키텍처와 디자인 사이의 스펙트럼과 특정 결정이 이 스펙트럼 내에서 어디에 있는지 결정하는 방법에 대해 이야기했습니다. 실제로 이 법칙은 디자인 측면보다 소프트웨어 아키텍처에 더 가까운 결정에 대해 생각하는 유용한 방법을 제공합니다:

*소프트웨어 아키텍처 결정에는 각 옵션에 대해 상당한 트레이드오프가 있습니다.*

소프트웨어 아키텍처의 모든 것이 트레이드오프라면, 아키텍처 결정은 각 옵션에 대한 트레이드오프를 포함해야 합니다.

아키텍트로서 모든 결정을 이진 솔루션으로 축소하려고 시도해서는 안 됩니다 - 우리 세계에는 그런 것이 거의 없습니다. 이것이 소프트웨어 아키텍처의 모든 답이 "상황에 따라 다릅니다"라고 말하는 이유 중 하나입니다 - 가능한 솔루션의 스펙트럼에서 해당 기준이 어디에 있는지에 따라 다릅니다.

아키텍트로서 우리는 불확실성의 늪에서 결정을 내립니다. 이 상황을 고려하는 것은 성가시지만 필요합니다. 불완전한 정보를 기반으로 때때로 중요한 결정을 내려야 할 뿐만 아니라, 모든 것을 알고 있다 하더라도 결정이 명확하지 않을 수 있습니다. 왜냐하면 두 극단 사이의 스펙트럼 어딘가에 있기 때문입니다.

소프트웨어 아키텍처에 오신 것을 환영합니다!

## 마지막 조언 (Ratschläge zum Abschied)

*우리는 어떻게 좋은 디자이너를 얻을까요? 좋은 디자이너는 당연히 디자인합니다.*

—Fred Brooks

*그렇다면 우리는 어떻게 훌륭한 아키텍트를 얻을까요, 그들이 경력에서 반 다스 번도 안 되는 기회만 가질 때?*

#### —Ted Neward

연습은 기술을 개발하고 아키텍처를 포함한 삶의 모든 영역에서 더 나아지기 위한 검증된 방법입니다. 우리는 신규 및 기존 아키텍트들이 아키텍처 디자인의 기술에서 기술을 연마하고 개인의 기술적 스펙트럼을 확장하도록 권장합니다. 이를 위해 우리는 이 책의 예제를 본떠 만든 몇 가지 [아키텍처 카타(Architektur-Katas)](https://oreil.ly/EPop7)를 개발했으며, 관련 웹사이트에서 찾을 수 있습니다. 우리는 여러분이 아키텍처의 기술을 연습하고 확장하기 위해 이것들을 활용하도록 권장합니다.

우리 카타를 사용하는 사람들은 종종 묻습니다: 어딘가에 답변 가이드가 있나요? 안타깝게도 없습니다. Neal의 말을 인용하면:

*아키텍처만 관련된 트레이드오프에는 정답이나 오답이 없습니다.*

저자들이 라이브 교육에서 아키텍처 카타를 사용하기 시작했을 때, 우리는 처음에 답변 모음을 만들기 위해 학생들의 그림을 보관했습니다. 그러나 우리는 이러한 아티팩트가 불완전하다는 것을 깨닫고 곧 포기했습니다. 팀들은 토폴로지 그림으로 솔루션을 *어떻게* 구현할지 기록했습니다. *왜*가 훨씬 더 흥미로웠습니다 - 하지만 수업에서 고려한 트레이드오프를 설명했지만, 아키텍처 결정 문서를 작성할 시간이 없었습니다. *어떻게*만 기록하면 이야기의 절반만 가지고 있는 것입니다.

우리의 마지막 조언: 항상 배우고, 항상 연습하며, *아키텍처에 들어가십시오*!
