# ch04 아키텍처 특성의 정의

## 요약

본 문서는 소프트웨어 아키텍처의 핵심 개념인 **아키텍처 특성**을 정의하고 분석합니다. 아키텍처 특성은 문제 도메인과 독립적이면서 시스템의 성공에 필수적인 운영 및 설계 기준을 의미하며, 시스템의 '행동'이 아닌 '역량'을 규정합니다. 과거에 사용되던 **비기능적 요구사항**이라는 용어는 그 중요성을 약화시키는 부정적 어감 때문에 지양되며, '아키텍처 특성'이라는 용어가 선호됩니다.

하나의 요구사항이 아키텍처 특성으로 인정받기 위해서는 다음 **세 가지 기준**을 모두 충족해야 합니다: 1) 도메인과 무관한 설계 고려사항을 지정하고, 2) 설계의 구조적 측면에 영향을 미치며, 3) 애플리케이션의 성공에 매우 중요해야 합니다. 이러한 특성들은 서로 시너지 효과를 내는 동시에 상충 관계에 있는 경우가 많아, 아키텍트는 필연적으로 **트레이드오프(trade-off)**에 직면하게 됩니다.

결론적으로, 모든 특성을 최적화한 '최고의 아키텍처'를 추구하는 것은 비현실적이며, 오히려 복잡성만 가중시킬 수 있습니다. 따라서 아키텍트의 목표는 여러 상충되는 요소들 사이에서 최적의 균형을 찾는 **최악이 아닌 아키텍처(least worst architecture)**를 설계하는 것이어야 합니다. 이를 위해 변경이 용이한 반복적 아키텍처 설계가 강조됩니다.

![아키텍처 특성의 정의 인포그래픽](unnamed.png)

--------------------------------------------------------------------------------


## 1. 아키텍처 특성의 정의

소프트웨어 아키텍트의 주요 임무 중 하나인 구조적 설계는 주로 **아키텍처 특성 분석**과 **논리적 구성요소 설계**라는 두 가지 활동으로 구성됩니다. 이 두 활동은 시스템의 성공을 좌우하는 중요한 기반이 됩니다.

### 1.1. 문제 도메인과 아키텍처 특성

소프트웨어 시스템은 크게 두 가지 요소로 구성됩니다.

- **문제 도메인 (Problem Domain)**: 시스템이 해결하고자 하는 비즈니스 문제와 관련된 기능적 요구사항을 의미합니다. 이는 시스템이 무엇을 해야 하는지(what), 즉 시스템의 **행동(behavior)**을 정의합니다.
- **아키텍처 특성 (Architectural Characteristics)**: 문제 도메인과 독립적이면서 시스템의 성공에 결정적인 영향을 미치는 요소입니다. 이는 시스템이 요구사항을 어떻게 구현해야 하는지(how), 즉 시스템의 **역량(capabilities)**을 정의합니다.

아키텍트는 기능적 요구사항을 정의하는 데 참여하는 동시에, 성능, 보안, 확장성과 같이 도메인 기능과 직접 관련이 없는 시스템의 역량을 정의하고 분석해야 합니다. 이러한 역할은 소프트웨어 아키텍처를 프로그래밍이나 일반 설계와 구별 짓는 핵심 요소입니다.

### 1.2. 용어의 중요성: '비기능적 요구사항'을 넘어서

아키텍처 특성을 설명하기 위해 여러 용어가 사용되어 왔지만, 각각 한계를 가집니다.

- **비기능적 요구사항 (Non-functional Requirements)**: 가장 널리 사용되지만, '비기능적'이라는 단어가 스스로를 폄하하는 부정적 어감을 주어 팀이 해당 요소에 충분한 주의를 기울이지 않게 만들 수 있습니다. 이 용어는 1970년대 후반 '기능 점수 분석(function point analysis)'에서 파생된 '비기능 점수(non-function points)'라는 개념에서 유래했습니다.
- **품질 속성 (Quality Attributes)**: 사후 품질 평가를 암시하는 경향이 있어 사전 계획의 중요성을 간과하게 만들 수 있습니다.

본 문서의 기반이 되는 소스에서는 **아키텍처 특성(architectural characteristics)**이라는 용어를 선호합니다. 이 용어는 해당 요소들이 아키텍처와 시스템 전체의 성공에 결정적이라는 점을 명확히 전달하며 그 중요성을 훼손하지 않습니다.

## 2. 아키텍처 특성의 세 가지 기준

하나의 요구사항이 아키텍처 특성으로 간주되기 위해서는 다음의 세 가지 기준을 모두 만족해야 합니다. 이 세 기준은 서로를 지지하며 시스템의 전체 설계를 뒷받침하는 삼각형 구조를 이룹니다.

- **도메인과 무관한 설계 고려사항을 지정한다**: 아키텍처 특성은 시스템의 비즈니스 로직(행동)이 아닌 시스템의 역량을 정의합니다. 예를 들어, 특정 수준의 성능 달성이나 '기술 부채 방지'와 같은 설계 고려사항이 여기에 해당합니다. 이러한 특성은 요구사항 문서에 명시적으로 나타날 수도 있고(명시적 특성), 해당 분야의 전문가라면 당연히 고려해야 할 암묵적인 것일 수도 있습니다(암시적 특성).
- **설계의 구조적 측면에 영향을 미친다**: 해당 특성을 만족시키기 위해 특별한 구조적 고려가 필요할 때 아키텍처 특성이 됩니다. 예를 들어, 보안은 모든 시스템의 기본적인 설계 요소지만, 마이크로서비스 아키텍처에서 강화된 별도의 인증 서비스를 구축하는 것과 같이 특별한 구조가 필요하다면 이는 아키텍처 특성이 됩니다. 반면, 확장성(scalability)은 영리한 설계만으로는 한계가 있어 특정 시점부터는 분산 아키텍처로의 구조적 전환이 필수적입니다.
- **애플리케이션의 성공에 중요하거나 결정적이다**: 모든 아키텍처 특성은 설계의 복잡성을 증가시킵니다. 따라서 아키텍트는 가능한 한 많은 특성을 지원하려 하기보다, 시스템 성공에 반드시 필요한 최소한의 특성만을 신중하게 선택해야 합니다.

## 3. 아키텍처 특성의 분류

아키텍처 특성은 매우 광범위하며 명확히 표준화된 목록은 없지만, 일반적으로 다음과 같은 범주로 분류할 수 있습니다. 각 조직은 이러한 용어들을 자체적인 상황에 맞게 해석하여 사용합니다.

### 3.1. 운영 아키텍처 특성

이 특성들은 주로 운영 및 DevOps와 밀접한 관련이 있습니다.

용어	정의
가용성 (Availability)	시스템이 사용 가능해야 하는 시간. 24/7 운영 시 장애 발생 시 빠른 복구를 위한 조치가 필요함.
연속성 (Continuity)	시스템의 재해 복구 능력.
성능 (Performance)	시스템의 응답 시간, 처리량 등 작동 효율성. 스트레스 테스트, 사용 빈도 분석 등으로 측정.
복구성 (Recoverability)	비즈니스 연속성 요구사항. 재해 발생 시 시스템이 얼마나 빨리 온라인 상태로 돌아와야 하는지 정의.
신뢰성/안전성 (Reliability/Security)	시스템이 고장에 안전해야 하거나 생명에 영향을 미치는 등 미션 크리티컬한지 여부.
견고성 (Robustness)	인터넷 연결 실패나 정전과 같은 오류 및 예외 상황을 운영 중에 처리하는 능력.
확장성 (Scalability)	사용자 또는 요청 수가 증가할 때 시스템이 정상적으로 작동하는 능력.

### 3.2. 구조적 아키텍처 특성

코드 품질, 모듈성, 결합도 제어 등 코드 구조와 관련된 특성들입니다.

용어	정의
구성 가능성 (Configurability)	최종 사용자가 인터페이스를 통해 소프트웨어 구성을 얼마나 쉽게 변경할 수 있는지.
확장성 (Extensibility)	기존 기능을 확장하는 변경 사항에 아키텍처가 얼마나 잘 적응하는지.
설치 가능성 (Installability)	필요한 모든 플랫폼에 시스템을 얼마나 쉽게 설치할 수 있는지.
유용성/재사용성 (Usability/Reusability)	시스템의 공통 구성 요소를 여러 제품에서 활용할 수 있는 정도.
지역화 (Localization)	입력/조회 화면 및 데이터 필드에서 여러 언어를 지원하는 능력.
유지보수성 (Maintainability)	시스템을 변경하고 개선하는 작업의 용이성.
이식성 (Portability)	시스템이 여러 플랫폼(예: Oracle, SAP DB)에서 실행될 수 있는 능력.
업그레이드 가능성 (Upgradability)	서버와 클라이언트에서 새 버전으로 얼마나 쉽고 빠르게 업데이트할 수 있는지.

### 3.3. 클라우드 특성

클라우드 컴퓨팅의 보편화에 따라 중요해진 특성들입니다.

용어	정의
온디맨드 확장성	클라우드 제공업체가 필요에 따라 리소스를 동적으로 확장하는 능력.
온디맨드 탄력성	리소스 수요가 증가할 때 유연하게 대처하는 능력. 확장성과 유사.
영역 기반 가용성	데이터 센터 영역별로 리소스를 분리하여 시스템 장애 허용성을 높이는 능력.
지역별 데이터 개인정보 보호 및 보안	여러 국가 및 지역의 데이터를 저장할 수 있는 법적 능력. (예: 데이터 주권 법률 준수)

### 3.4. 교차적 아키텍처 특성

여러 범주에 걸쳐 있거나 특정 범주로 분류하기 어려운 중요한 설계 제약 조건들입니다.

용어	정의
접근성 (Accessibility)	색맹, 청각 장애 등 장애를 가진 사용자를 포함한 모든 사용자가 시스템에 쉽게 접근할 수 있는 정도.
보관성 (Archivability)	특정 기간 이후 데이터를 보관하거나 삭제하는 것에 대한 시스템의 제약 조건.
인증 (Authentication)	사용자가 자신이 주장하는 신원과 일치하는지 확인하기 위한 보안 요구사항.
권한 부여 (Authorization)	사용자가 애플리케이션 내의 특정 기능에만 접근할 수 있도록 보장하는 보안 요구사항.
합법성 (Legality)	시스템이 운영되는 법적 프레임워크 (예: GDPR, 사베인스-옥슬리 법).
개인정보 보호 (Privacy)	트랜잭션을 암호화하고 내부 직원으로부터 숨길 수 있는 시스템의 능력.
보안 (Security)	데이터베이스 암호화, 네트워크 통신 보안, 원격 사용자 인증 등에 대한 규칙 및 제한.
지원 가능성 (Supportability)	애플리케이션에 필요한 기술 지원 수준. 오류 해결을 위한 로깅 및 기타 기능의 필요 정도.
사용성/달성 가능성 (Usability/Achievability)	사용자가 애플리케이션을 사용하여 목표를 달성하는 데 필요한 교육 수준.

## 4. 정의의 모호성과 표준화 과제

아키텍처 특성 용어들은 명확한 업계 표준이 없어 종종 모호하게 사용됩니다. 예를 들어, 상호운용성(Interoperability)은 공개된 API를 통한 손쉬운 통합을 의미하는 반면, 호환성(Compatibility)은 산업 표준 준수에 더 가깝습니다. 이러한 혼란을 피하기 위해 각 조직은 도메인 주도 설계(Domain-Driven Design)의 조언에 따라 자체적인 '보편 언어(ubiquitous language)' 를 수립하고 사용하는 것이 권장됩니다.

국제표준화기구(ISO)는 일부 특성을 정의하고 있으나, 이 역시 완전하지는 않습니다. ISO가 정의한 주요 범주는 다음과 같습니다.

- **성능 효율성 (Performance efficiency)**: 리소스 사용량 대비 성능 수준.
- **호환성 (Compatibility)**: 다른 시스템과 정보 교환 및 동일 환경 공유 능력.
- **사용성 (Usability)**: 사용자가 효과적, 효율적, 만족스럽게 시스템을 사용하는 능력.
- **신뢰성 (Reliability)**: 특정 조건에서 특정 기간 동안 시스템이 명시된 대로 작동하는 정도. (성숙도, 가용성, 내결함성 포함)
- **보안 (Security)**: 인가된 수준에 따라 정보와 데이터를 보호하는 정도. (기밀성, 무결성, 부인 방지 등 포함)
- **유지보수성 (Maintainability)**: 개발자가 소프트웨어를 효과적이고 효율적으로 수정할 수 있는 정도. (모듈성, 재사용성, 분석 가능성 포함)
- **이식성 (Portability)**: 한 환경에서 다른 환경으로 시스템을 이전할 수 있는 정도.

## 5. 핵심 원칙: 트레이드오프와 '최악이 아닌 아키텍처'

아키텍처 설계는 여러 상충하는 목표 사이의 균형을 찾는 과정입니다.

1. **비용과 복잡성**: 모든 아키텍처 특성을 지원하는 데는 설계, 구현, 유지보수 비용이 따르며, 이는 시스템의 복잡성을 증가시킵니다.
2. **특성 간의 상충 관계**: 특성들은 서로 시너지 효과를 내기도 하지만, 종종 상충됩니다. 예를 들어, 보안을 강화하면 암호화 및 추가 검증 과정으로 인해 성능이 저하될 수 있습니다. 이는 마치 헬리콥터 조종과 같이 하나의 제어 변경이 다른 모든 요소에 영향을 미치는 것과 같습니다.
3. **최적화의 불가능성**: 따라서 모든 아키텍처 특성을 최적으로 만족시키는 시스템을 설계하는 것은 거의 불가능합니다. 너무 많은 특성을 지원하려는 시도는 모든 비즈니스 문제를 해결하려는 범용 솔루션으로 이어져, 결국 다루기 힘든 설계가 되어 실패할 확률이 높습니다.

이러한 이유로 아키텍트는 다음과 같은 원칙을 따라야 합니다.

**팁**: 최고의 아키텍처가 아닌, 최악이 아닌 아키텍처를 지향하라.

이는 완벽함이 아닌 실용적인 절충안을 찾는 것이 중요하다는 의미입니다. 또한, 애자일 소프트웨어 개발의 핵심 교훈인 반복(iteration)의 가치는 아키텍처 수준에서도 동일하게 적용됩니다. 아키텍처를 변경하기 쉬울수록, 첫 시도에서 모든 것을 완벽하게 만들려는 부담이 줄어듭니다.
