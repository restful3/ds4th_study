---
lang: ko
format:
  html:
    toc: true
    embed-resources: true
    theme: cosmo
---

## 4장. 아키텍처 특성 정의 (Kapitel 4. Architektonische Merkmale definiert)

이 저작물은 AI의 도움을 받아 번역되었습니다. 여러분의 피드백과 의견을 환영합니다: [translation-feedback@oreilly.com](mailto:translation-feedback@oreilly.com)

이제 우리는 소프트웨어 아키텍트의 가장 중요한 작업 중 하나인 구조적 설계(structural design)의 세부 사항을 다룹니다. 이것은 주로 두 가지 활동으로 구성됩니다: 이 장에서 다루는 *아키텍처 특성 분석(architectural characteristics analysis)*과 [8장](#page--1-0)에서 다루는 *논리적 컴포넌트 설계(logical component design)*입니다. 아키텍트는 이 두 활동을 임의의 순서로(또는 심지어 병렬로) 수행할 수 있지만, 결정적인 지점에서 만나게 됩니다.

기업이 소프트웨어를 사용하여 특정 문제를 해결하기로 결정하면, 시스템에 대한 요구사항 목록을 작성합니다([8장](#page--1-0)에 설명된 대로 이를 도출하는 많은 기법들이 있습니다). 우리는 이 책 전체에서 이러한 요구사항을 *문제 도메인(problem domain)* (또는 간단히 *도메인*)이라고 부를 것입니다. [1장](#page--1-0)에서 배웠듯이, *아키텍처 특성(architectural characteristics)*은 문제 도메인과 독립적이면서 시스템의 성공에 중요한 시스템의 주요 측면입니다. 이 장에서는 "아키텍처(architecture)"라는 용어를 더 정확하게 정의하고 구체적인 아키텍처 특성을 다룰 것입니다.

아키텍트는 종종 도메인 정의 작업에 참여하지만, 도메인의 기능과 직접적인 관련이 없으면서도 소프트웨어가 수행해야 하는 모든 것들, 즉 *아키텍처 특성(architectural characteristics)*을 정의하고 발견하며 분석해야 합니다. 아키텍처 특성을 정의하는 아키텍트의 역할은 소프트웨어 아키텍처를 프로그래밍 및 설계와 구별하는 요소 중 하나입니다. 소프트웨어 솔루션을 설계할 때, 그들은 [그림 4-1](#page-1-0)에 나타난 것처럼 많은 다른 요소들도 고려해야 합니다.

<span id="page-1-0"></span>![](_page_1_Picture_1.jpeg)

그림 4-1. 소프트웨어 솔루션은 비즈니스 요구사항과 아키텍처 특성 모두로 구성됩니다

#### **"비기능적 요구사항"이라는 용어의 지속성 (DIE LANGLEBIGKEIT DES BEGRIFFS "NICHT-FUNKTIONALE ANFORDERUNGEN")**

많은 기업들이 *비기능적 요구사항(non-functional requirements)*을 포함한 다양한 용어로 아키텍처 특성을 설명하는데, 이 용어는 아키텍처 특성을 *기능적 요구사항(functional requirements)*과 구분하기 위해 만들어졌습니다. 우리는 이 용어를 좋아하지 않습니다. 왜냐하면 자기 비하적이고 언어적으로 부정적인 영향을 미치기 때문입니다: "비기능적(non-functional)"인 것에 충분한 주의를 기울이도록 팀을 어떻게 설득할 수 있을까요? 또 다른 인기 있는 용어는 *품질 속성(quality attributes)*인데, 우리는 이것이 계획보다는 사후 품질 평가를 암시하기 때문에 좋아하지 않습니다.

우리는 *아키텍처 특성(architectural characteristics)*이라는 용어를 선호합니다. 왜냐하면 이것이 아키텍처의 성공, 따라서 시스템 전체의 성공에 결정적인 관심사를 설명하면서, 이러한 관심사의 중요성을 폄하하지 않기 때문입니다. *Head First Software Architecture* [\(O'Reilly, 2024\)](https://www.oreilly.com/library/view/head-first-software/9781098134341)에서 우리는 아키텍처 특성을 시스템의 *능력(capabilities)*이라고 부릅니다; 이와 대조적으로 도메인은 시스템의 *행동(behavior)*을 나타냅니다.

때때로 용어들은 "고착되고", *비기능적 요구사항*은 소프트웨어 아키텍트들 사이에서 특히 민감한 주제인 것 같습니다. 많은 기업에서 여전히 일반적입니다. 이 용어는 1970년대 후반에 소프트웨어 개발 문헌에 처음 등장했는데, 이는 시스템 요구사항을 각각 작업 단위를 나타내는 "기능 포인트(function points)"로 분해하는 추정 기법인 *기능 포인트 분석(Function Point Analysis)*과 거의 동시에 나타났습니다. 이론적으로 팀은 분석 프로세스가 끝날 때

모든 기능 포인트를 합산하여 프로젝트에 대한 어느 정도의 통찰력을 얻을 수 있었습니다. 불행하게도 이 방법은 확실성의 외관을 제공했지만, 많은 다른 추정 절차와 마찬가지로 주관성으로 특징지어졌고 따라서 더 이상 사용되지 않습니다.

그러나 이 시기로부터 한 가지 통찰이 남아 있습니다: 시스템 개발 노력의 상당 부분이 요구사항이 아닌 시스템의 *능력(capabilities)*과 관련이 있다는 것입니다. 그들은 이러한 노력을 *"비기능 포인트(non-function points)"*라고 불렀고, 이것이 *"비기능적 요구사항(non-functional requirements)"*이라는 용어가 확립되는 계기가 되었습니다.

## 아키텍처 특성과 시스템 설계 (Architektonische Merkmale und Systemdesign)

아키텍처 특성으로 간주되기 위해서는 요구사항이 세 가지 기준을 충족해야 합니다. 도메인과 무관한 설계 측면을 명시해야 하고, 설계의 구조적 측면에 영향을 미쳐야 하며, *그리고* 애플리케이션의 성공에 중요하거나 결정적이어야 합니다. 우리 정의의 이러한 상호 연결된 부분들은 [그림 4-2](#page-4-0)에 나타나 있으며, 이는 세 가지 구성 요소와 일부 수정자로 구성됩니다.

<span id="page-4-0"></span>![](_page_4_Picture_1.jpeg)

그림 4-2. 아키텍처 특성의 구별 특징

이러한 구성 요소들을 더 자세히 살펴보겠습니다:

*아키텍처 특성은 도메인에 속하지 않는 설계 고려사항을 명시합니다.*

소프트웨어 아키텍처의 구조적 설계는 아키텍트의 두 가지 활동으로 구성됩니다: 문제 도메인을

이해하는 것과 시스템이 성공하기 위해 지원해야 하는 능력의 종류를 파악하는 것입니다. 도메인 설계 고려사항은 시스템의 행동과 관련이 있고, 아키텍처 특성은 능력을 정의합니다.

이 두 활동을 합치면 구조적 설계를 정의하게 됩니다.

설계 요구사항이 애플리케이션이 *무엇을* 해야 하는지 정의하는 반면, 아키텍처 특성은 요구사항이 *어떻게* 구현되어야 하는지와 특정 결정이 *왜* 내려졌는지를 지정합니다: 간단히 말해서, 프로젝트 성공을 위한 운영 및 설계 기준입니다.

예를 들어, 특정 성능 수준은 종종 중요한 아키텍처 특성이지만 요구사항 문서에 자주 언급되지 않습니다. 더 중요한 것은, 어떤 요구사항 문서에도 설계가 "기술 부채를 방지"해야 한다고 명시되어 있지 않지만, 이는 일반적인 설계 측면입니다. 우리는 "도메인 관심사로부터 아키텍처 [특성 추출하기](#page--1-1)(Extracting Architectural Characteristics from Domain Concerns)"에서 명시적 및 암시적 특성 간의 이러한 구별을 상세히 다룹니다.

*아키텍처 특성은 설계의 구조적 측면에 영향을 미칩니다.*

아키텍트가 프로젝트에서 아키텍처 특성을 설명하려는 주된 이유는 중요한 설계 고려사항을 파악하기 위함입니다. 아키텍트가 설계를 통해 이를 구현할 수 있을까요, 아니면 이

아키텍처 특성이 성공하기 위해 특별한 *구조적* 고려사항을 요구할까요?

예를 들어, 보안은 거의 모든 프로젝트에서 문제이며, 모든 시스템은 개발 및 프로그래밍 중에 특정 기본 예방 조치를 취해야 합니다. 그러나 보안은 아키텍트가 아키텍처가 이를 지원하기 위해 특별한 구조가 필요하다고 결정할 때 아키텍처 특성이 됩니다.

두 가지 일반적인 아키텍처 특성인 보안과 확장성을 고려해 보겠습니다. 아키텍트는 암호화, 해싱, 솔팅을 포함한 잘 알려진 기술을 포함하여 좋은 코딩 위생을 통해 모놀리식 시스템에서 보안을 보장할 수 있습니다. (이 용어에도 해당하는 아키텍처 적합성 함수는 [6장](#page--1-0)에서 다룹니다.) 반면 마이크로서비스와 같은 분산 아키텍처에서는 아키텍트가 더 엄격한 접근 프로토콜을 가진 강화된 서비스를 구축할 것입니다 - 이것은 구조적 접근입니다. 따라서 아키텍트는 설계나 구조를 통해 보안을 고려할 수 있습니다. 반면에 확장성을 고려해야 합니다: 모놀리식 아키텍처는 아무리 영리한 설계로도 특정 지점 이상으로 확장할 수 없습니다. 이 지점부터는 시스템을 분산 아키텍처로 전환해야 합니다.

아키텍트는 운영 아키텍처 특성("운영 [아키텍처](#page-8-0) 특성" 참조)에 매우 주의를 기울입니다. 왜냐하면 이러한

특성들이 특별한 구조적 지원을 가장 자주 요구하기 때문입니다.

*아키텍처 특성은 애플리케이션의 성공에 결정적이거나 중요해야 합니다.*

애플리케이션은 다양한 아키텍처 특성을 지원*할 수 있습니다*... 하지만 그래서는 안 됩니다. 시스템이 지원하는 모든 아키텍처 특성은 설계의 복잡성을 증가시킵니다. 따라서 아키텍트는 가능한 한 *많은* 아키텍처 특성을 선택하는 대신 가능한 한 *적은* 아키텍처 특성을 선택하도록 노력해야 합니다.

우리는 아키텍처 특성을 암시적 및 명시적 아키텍처 특성으로 나눕니다. 암시적 특성은 요구사항에 거의 나타나지 않지만 프로젝트의 성공에 필요합니다. 가용성, 신뢰성, 보안은 거의 모든 애플리케이션의 기반이지만 설계 문서에는 거의 언급되지 않습니다. 아키텍트는 분석 단계에서 이러한 아키텍처 특성을 발견하기 위해 문제 도메인에 대한 지식을 활용해야 합니다. 예를 들어, 고빈도 거래(high-frequency trading)에 종사하는 기업은 모든 시스템에서 낮은 지연 시간을 명시할 필요가 없습니다. 왜냐하면 이 문제 영역의 아키텍트는 이미 그것이 얼마나 중요한지 알고 있기 때문입니다. 명시적 아키텍처 특성은 요구사항 문서나 기타 구체적인 지침에 나타납니다.

[그림 4-2](#page-4-0)에서 삼각형의 선택은 의도적입니다: 정의 요소 각각은 다른 요소들을 지원하며, 이들은 차례로

시스템의 전체 설계를 지원합니다. 삼각형으로 만들어진 피벗은 이러한 아키텍처 특성들이 종종 서로 어떻게 상호작용하는지를 명확히 합니다. 이것이 아키텍트가 *트레이드오프(trade-off)*라는 용어를 자주 사용하는 이유입니다.

## 아키텍처 특성 (부분) 목록 (Architektonische Merkmale (Teilweise) Aufgeführt)

아키텍처 속성은 낮은 수준의 코드 특성(모듈성과 같은)에서 복잡한 운영 관심사(확장성 및 탄력성과 같은)에 이르기까지 광범위한 복잡성 스펙트럼에 존재합니다. 비록 시도는 있었지만 진정으로 보편적인 표준은 없습니다. 대신, 각 조직은 이러한 용어를 자체적으로 해석합니다. 소프트웨어 생태계가 너무 빠르게 변화하기 때문에, 아키텍처 특성을 정의하는 새로운 가능성을 제공하는 새로운 개념, 용어, 측정, 검증이 지속적으로 등장합니다.

아키텍처 특성의 순수한 양과 범위 때문에 정량화하기 어렵지만, 아키텍트는 이를 분류합니다. 다음 섹션에서는 이러한 대략적인 범주 중 일부를 설명하고 몇 가지 예를 제시합니다.

#### <span id="page-8-0"></span>**운영 아키텍처 특성 (Operative architektonische Merkmale)**

운영 아키텍처 특성은 성능, [확장성, 탄력성, 가용성](#page-10-0) 및 신뢰성과 같은 능력을 포함합니다. 표 4-1은 일부 운영 아키텍처 속성을 나열합니다.

<span id="page-10-0"></span>표 4-1. 일반적인 운영 아키텍처 특성

| 용어 | 정의 |
|------|------|
| 가용성 (Verfügbarkeit) | 시스템이 얼마나 오랫동안 사용 가능해야 하는가? 24/7 운영의 경우, 장애 발생 시 시스템이 빠르게 다시 작동 가능하도록 조치를 취해야 합니다. |
| 연속성 (Kontinuität) | 시스템의 재해 복구 능력입니다. |
| 성능 (Leistung) | 시스템이 얼마나 잘 작동하는가; 이를 측정하는 방법에는 스트레스 테스트, 피크 분석, 사용되는 기능의 빈도 분석 및 응답 시간이 포함됩니다. |
| 복구 가능성 (Wiederherstellbarkeit) | 비즈니스 연속성 요구사항: 재해 발생 시 시스템이 얼마나 빨리 다시 온라인 상태가 되어야 하는가. 여기에는 백업 전략과 교체 하드웨어에 대한 요구사항이 포함됩니다. |
| 신뢰성/안전성 (Verlässlichkeit/Sicherheit) | 시스템이 페일세이프(failsafe)여야 하는지 또는 생명에 영향을 미치는 방식으로 업무에 중요한지 여부입니다. 실패하면 기업에 많은 비용이 들까요? 이것은 종종 스펙트럼이지 이진수가 아닙니다. |
| 견고성 (Robustheit) | 시스템이 실행 중에 오류 및 경계 조건을 처리하는 능력입니다. 예를 들어 인터넷 연결이나 전원 공급이 실패할 때입니다. |
| 확장성 (Skalierbarkeit) | 사용자나 요청 수가 증가할 때 시스템이 기능하는 능력입니다. |

운영 아키텍처 특성은 운영 및 DevOps의 관심사와 크게 중복됩니다.

#### **구조적 아키텍처 특성 (Strukturelle architektonische Merkmale)**

아키텍트는 올바른 코드 구조에 책임이 있습니다. 많은 경우, 아키텍트는 모듈성, 가독성, 컴포넌트 간 결합도 제어, 코드 가독성 및 다양한 기타 내부 품질 평가를 포함하여 코드 품질에 대해 단독으로 또는 공동으로 책임을 집니다. [표 4-2](#page-13-0)는 일부 구조적 아키텍처 특성을 나열합니다.

<span id="page-13-0"></span>표 4-2. 구조적 아키텍처 특성

| 용어 | 정의 |
|------|------|
| 구성 가능성 (Konfigurierbarkeit) | 최종 사용자가 인터페이스를 통해 소프트웨어 구성의 측면을 얼마나 쉽게 변경할 수 있는가. |
| 확장 가능성 (Erweiterbarkeit) | 아키텍처가 기존 기능을 확장하는 변경사항에 얼마나 잘 적응할 수 있는가. |
| 설치 가능성 (Installierbarkeit) | 모든 필요한 플랫폼에 시스템을 설치하는 것이 얼마나 쉬운가. |
| 활용성/재사용성 (Nutzbarkeit/Wiederverwendung) | 시스템의 공통 컴포넌트가 여러 제품에 걸쳐 활용될 수 있는 정도입니다. |
| 지역화 (Lokalisierung) | 데이터 필드의 입력/쿼리 화면에서 여러 언어에 대한 지원입니다. |
| 유지보수성 (Instandhaltbarkeit) | 변경하고 시스템을 개선하는 것이 얼마나 쉬운가. |
| 이식성 (Tragbarkeit) | 시스템이 하나 이상의 플랫폼에서 실행될 수 있는 능력입니다 (예: Oracle 및 SAP DB). |
| 업그레이드 가능성 (Aufrüstbarkeit) | 서버와 클라이언트에서 최신 버전으로 업데이트하는 것이 얼마나 쉽고 빠른가. |

#### **클라우드 특성 (Merkmale der Wolke)**

소프트웨어 개발 생태계는 지속적으로 변화하고 발전합니다; 가장 최근의 탁월한 예는 클라우드의 도래입니다. 초판이 출판되었을 때 클라우드 컴퓨팅은 이미 존재했지만 아직 널리 보급되지 않았습니다. 오늘날 대부분의 시스템은 적어도 어느 정도 클라우드 기반 시스템과 관련이 있습니다. 이러한 [고려사항](#page-16-0) 중 일부가 표 4-3에 나열되어 있습니다.

<span id="page-16-0"></span>표 4-3. 클라우드 제공업체의 아키텍처 특성

| 용어 | 정의 |
|------|------|
| 온디맨드 확장성 (Skalierbarkeit nach Bedarf) | 클라우드 제공업체가 리소스를 동적으로 필요에 따라 확장할 수 있는 능력입니다. |
| 온디맨드 탄력성 (Elastizität nach Bedarf) | 리소스 수요가 증가할 때 클라우드 제공업체의 유연성; 확장성과 유사합니다. |
| 영역 기반 가용성 (Zonenbasierte Verfügbarkeit) | 클라우드 제공업체가 시스템의 복원력을 높이기 위해 데이터 센터 영역별로 리소스를 분리할 수 있는 능력입니다. |
| 지역 데이터 보호 및 보안 (Regionaler Datenschutz und Sicherheit) | 클라우드 제공업체가 다양한 국가 및 지역의 데이터를 저장할 수 있는 법적 가능성입니다. 많은 국가에서 시민의 데이터가 저장될 수 있는 위치를 규제하는 법률이 있습니다 (그리고 종종 해당 지역 외부에 데이터 저장을 제한합니다). |

이 책의 2판에서 우리는 각 아키텍처 스타일에 대한 각 장에 해당 스타일이 클라우드 고려사항을 어떻게 지원하고 촉진하는지 설명하는 섹션을 추가했습니다.

### **범주 횡단 아키텍처 특성 (Übergreifende architektonische Merkmale)**

많은 아키텍처 특성이 쉽게 인식 가능한 범주로 분류될 수 있지만, 분류를 거부하면서도 여전히 중요한 설계 제약 및 고려사항을 나타내는 다른 특성들이 있습니다. [표 4-4](#page-18-0)는 이러한 특성 중 일부를 설명합니다.

<span id="page-18-0"></span>표 4-4. 범주 횡단 아키텍처 특성

| 용어 | 정의 |
|------|------|
| 접근성 (Zugänglichkeit) | 색맹이나 청력 손실과 같은 장애를 가진 사람들을 포함하여 모든 사용자가 시스템에 얼마나 쉽게 접근할 수 있는가. |
| 보관 가능성 (Archivierbarkeit) | 특정 기간 후 데이터를 보관하거나 삭제하기 위한 시스템의 제약사항입니다. |
| 인증 (Authentifizierung) | 사용자가 그들이 주장하는 사람인지 확인하기 위한 보안 요구사항입니다. |
| 권한 부여 (Autorisierung) | 사용자가 애플리케이션 내 특정 기능에만 접근할 수 있도록 보장하기 위한 보안 요구사항입니다 (사용 사례, 하위 시스템, 웹 페이지, 비즈니스 규칙, 필드 수준 등에 따라). |

# **용어 정의**

법률 (Legal): 시스템이 운영되는 법적 프레임워크입니다. 예를 들어 GDPR과 같은 데이터 보호법이나 미국의 Sarbanes-Oxley와 같은 금융 데이터에 관한 법률, 또는 애플리케이션이 개발되거나 배포되어야 하는 방식에 대한 규정입니다. 여기에는 회사가

필요로 하는 유보 권리도 포함됩니다.

프라이버시 (Datenschutz): 시스템이 트랜잭션을 암호화하고 기업 내부

및 네트워크 아키텍트,

심지어 DBA로부터도

숨길 수 있는 능력입니다.

| 용어 | 정의 |
|------|------|
| 보안 (Sicherheit) | 데이터베이스의 암호화 또는 내부 시스템 간 네트워크 통신에 대한 규칙 및 제약사항; 사용자의 원격 접근을 위한 인증 및 기타 보안 조치입니다. |
| 지원 가능성 (Unterstützbarkeit) | 애플리케이션에 필요한 기술 지원 수준; 시스템의 오류를 해결하기 위해 로깅 및 기타 시설이 얼마나 필요한가. |
| 사용성/도달성 (Benutzerfreundlichkeit/Erreichbarkeit) | 사용자가 애플리케이션/솔루션으로 목표를 달성하기 위해 필요한 교육 수준입니다. |

아키텍처 특성의 모든 목록은 필연적으로 불완전합니다; 모든 소프트웨어 프로젝트는 고유한 요인에 기반하여 아키텍처 특성을 발명할 수 있습니다. 방금 나열한 용어 중 많은 것이 부정확하고 모호하며, 때로는 미묘한 뉘앙스 또는 객관적 정의의 부족 때문입니다. 예를 들어 *상호운용성(Interoperability)*과 *호환성(Compatibility)*은 동의어처럼 보이며, 일부 시스템의 경우 그렇습니다. 그러나 그들은 다릅니다. 왜냐하면 *상호운용성*은 다른 시스템과의 간단한 통합을 전제로 하며, 이는 다시 공개되고 문서화된 API를 전제로 하기 때문입니다. 반면 *호환성*은 산업 및 도메인 표준에 더 관련이 있습니다. 또 다른 예는 *학습 가능성(Lernfähigkeit)*입니다: 한 정의는 "사용자가 소프트웨어 사용을 배우는 것이 얼마나 쉬운가"라고 하고, 다른 정의는 "시스템이 기계 학습 알고리즘을 사용하여 자체적으로 구성하거나 최적화하기 위해 환경에 대해 자동으로 학습할 수 있는 정도"라고 합니다.

많은 정의가 중복됩니다: 예를 들어 *가용성(Verfügbarkeit)*과 *신뢰성(Zuverlässigkeit)*. 그러나 TCP의 기반이 되는 인터넷 프로토콜 IP를 고려해 보십시오. IP는 *사용 가능*하지만 *신뢰할 수 없습니다*: 패킷은 잘못된 순서로 도착할 수 있으며, 수신자는 누락된 패킷을 다시 요청해야 할 수 있습니다.

이러한 범주를 정의하는 완전한 표준 목록은 없습니다. 국제표준화기구(ISO)는 [능력별로](https://oreil.ly/SKc_Y) 정렬된 목록을 발행하는데, 이는 여기의 목록과 중복되지만 주로 불완전한 범주 목록을 생성합니다. 다음은 용어를 업데이트하고 현대적 요구사항을 충족하도록 범주를 추가하기 위해 재구성된 ISO 정의 중 일부입니다:

#### *성능 효율성 (Leistungseffizienz)*

알려진 조건 하에서 사용된 리소스의 양에 대한 성능의 척도입니다. 여기에는 *시간 동작(time behavior)* (응답, 처리 시간 및/또는 처리량 비율의 척도), *리소스 활용(resource utilization)* (사용되는 리소스의 양과 유형) 및 *용량(capacity)* (정해진 최대 한계를 초과하는 정도)가 포함됩니다.

#### *호환성 (Kompatibilität)*

제품, 시스템 또는 컴포넌트가 동일한 하드웨어 또는 소프트웨어 환경을 사용하면서 다른 제품, 시스템 또는 컴포넌트와 정보를 교환하고/하거나 필요한 기능을 수행할 수 있는 정도입니다.

여기에는 *공존(coexistence)* (공통 환경 및 리소스를 다른 제품과 공유하면서 필요한 기능을 효율적으로 수행할 수 있음)과 *상호운용성(interoperability)* (둘 이상의 시스템이 정보를 교환하고 활용할 수 있는 정도)이 포함됩니다.

#### *사용성 (Benutzerfreundlichkeit)*

사용자가 의도한 목적을 위해 시스템을 효과적이고 효율적이며 만족스럽게 사용할 수 있습니다. 여기에는 *적절성의 인식 가능성(recognizability of appropriateness)* (사용자가 소프트웨어가 자신의 요구에 적합한지 인식할 수 있음), *학습 가능성(learnability)* (사용자가 소프트웨어 사용을 얼마나 쉽게 배울 수 있는가), *사용자 오류로부터의 보호* 및 *접근성(accessibility)* (소프트웨어는 가장 다양한 특성과 능력을 가진 사람들이 접근할 수 있어야 함)이 포함됩니다.

#### *신뢰성 (Verlässlichkeit)*

시스템이 특정 조건 하에서 특정 기간 동안 기능하는 정도입니다. 이 특성에는 *성숙도(maturity)* (소프트웨어가 정상 작동 중 신뢰성 요구사항을 충족하는가), *가용성(availability)* (소프트웨어가 운영 가능하고 접근 가능한가), *결함 허용성(fault tolerance)* (하드웨어 또는 소프트웨어 오류에도 불구하고 소프트웨어가 의도한 대로 작동하는가) 및 *복구 가능성(recoverability)* (장애 후 소프트웨어가 영향을 받은 모든 데이터를 복원하고 시스템의 원하는 상태를 복원할 수 있는가)과 같은 하위 범주가 포함됩니다.

#### *보안 (Sicherheit)*

소프트웨어가 정보와 데이터를 사람이나 다른 제품 또는 시스템이 그들의 유형과 권한에 해당하는 수준의 데이터 접근을 갖도록 보호하는 정도입니다. 이 특성 계열에는 *기밀성(confidentiality)* (데이터가 그것에 대한 권한이 있는 사람들만 접근할 수 있음), *무결성(integrity)* (소프트웨어가 소프트웨어 또는 데이터에 대한 무단 접근 또는 변경을 방지함), *부인방지(non-repudiation)* (행동 또는 이벤트가 발생했음을 증명할 수 있음), *추적 가능성(traceability)* (사용자의 행동을 추적할 수 있음) 및 *진정성(authenticity)* (사용자 신원의 증명)이 포함됩니다.

#### *유지보수성 (Instandhaltbarkeit)*

개발자가 소프트웨어를 개선하고, 수정하고, 변경된 환경 및/또는 요구사항에 적응시키기 위해 변경할 수 있는 효과성과 효율성의 정도를 나타냅니다. 이 특성에는 *모듈성(modularity)* (소프트웨어가 개별 컴포넌트로 구성된 정도), *재사용성(reusability)* (개발자가 하나 이상의 시스템에서 또는 다른 자산을 생성할 때 자산을 사용할 수 있는 정도), *분석 가능성(analyzability)* (개발자가 소프트웨어에 대한 구체적인 메트릭을 얼마나 쉽게 수집할 수 있는가), *수정 가능성(modifiability)* (개발자가 오류를 도입하거나 기존 제품 품질을 저하시키지 않고 소프트웨어를 변경할 수 있는 정도) 및 *테스트 가능성(testability)* (개발자 및 다른 사람들이 소프트웨어를 얼마나 쉽게 테스트할 수 있는가)이 포함됩니다.

#### *이식성 (Tragbarkeit)*

개발자가 시스템, 제품 또는 컴포넌트를 한 하드웨어, 소프트웨어 또는 기타 운영 또는 사용 환경에서 다른 환경으로 전송할 수 있는 정도입니다. 이 특성에는 *적응성(adaptability)* (개발자가 소프트웨어를 다양하거나 진화하는 하드웨어, 소프트웨어 또는 기타 운영 또는 사용 환경에 효과적이고 효율적으로 적응시킬 수 있는가), *설치 가능성(installability)* (특정 환경에 소프트웨어를 설치 및/또는 제거할 수 있는가) 및 *대체 가능성(replaceability)* (개발자가 기능을 다른 소프트웨어로 얼마나 쉽게 교체할 수 있는가)와 같은 하위 특성이 포함됩니다.

ISO 목록의 마지막 항목은 소프트웨어의 기능적 측면을 다룹니다:

#### *기능적 적합성 (Funktionale Eignung)*

이 특성은 제품 또는 시스템이 특정 조건 하에서 사용될 때 명시된 및 암시된 요구를 충족하는 기능을 제공하는 정도를 나타냅니다. 이 특성은 다음 하위 특성으로 구성됩니다:

#### *기능적 완전성 (Funktionale Vollständigkeit)*

기능 세트가 모든 지정된 작업 및 사용자 목표를 다루는 정도입니다.

#### *기능적 정확성 (Funktionale Korrektheit)*

제품 또는 시스템이 필요한 정밀도로 올바른 결과를 제공하는 정도입니다.

*기능적 적절성 (Funktionale Angemessenheit)*

기능이 지정된 작업 및 목표를 달성하는 것을 촉진하는 정도입니다.

그러나 우리는 기능적 적합성이 이 목록에 속하지 않는다고 생각합니다. 이것은 아키텍처 특성을 설명하는 것이 아니라 소프트웨어를 생성하기 위한 동기 부여 요구사항을 설명합니다. 이것은 아키텍처 특성과 문제 도메인 간의 관계에 대한 사고가 어떻게 발전했는지를 명확히 합니다. 우리는 [7장](#page--1-0)에서 이러한 발전을 다룹니다.

#### **소프트웨어 아키텍처의 많은 모호성 (DIE VIELEN ZWEIDEUTIGKEITEN IN DER SOFTWAREARCHITEKTUR)**

아키텍트들 사이에서 지속적인 좌절의 원천은 소프트웨어 아키텍처 활동 자체를 포함하여 매우 많은 중요한 것들에 대한 명확한 정의의 부족입니다! 표준의 부재는 기업들이 일상적인 것들에 대해 자체 용어를 정의하게 만듭니다. 이것은 아키텍트가 불투명한 용어를 사용하거나, 더 나쁘게는 완전히 다른 의미에 대해 동일한 용어를 사용하기 때문에 업계 전반에 걸친 혼란으로 이어집니다.

아무리 노력해도 소프트웨어 개발 세계에 표준 명명법을 강요할 수는 없습니다. 그러나 용어학적 오해를 피하기 위해 도메인 주도 설계(Domain-Driven Design)는 기업들에게 직원들 사이에 통일된 *언어(language)*를 도입하고 사용할 것을 권고합니다. 우리는 이 조언을 따르고 권장합니다.

## 트레이드오프와 최소한의 나쁜 아키텍처 (Kompromisse und Least Worst Architecture)

우리는 이미 아키텍트가 시스템의 성공에 중요하거나 결정적인 아키텍처 특성만 지원해야 한다고 말했습니다. 시스템은 다양한 이유로 우리가 나열한 아키텍처 특성 중 일부만 지원할 수 있습니다. 첫째, 아키텍처 특성에 대한 지원은 거의 무료가 아닙니다. 모든

지원되는 특성은 아키텍트의 설계 노력, 개발자가 이를 구현하고 유지 관리하는 노력, 그리고 아마도 구조적 지원도 필요로 합니다.

둘째, 아키텍처 특성은 서로 *그리고 문제 영역과* 시너지 효과가 있습니다. 아무리 우리가 다른 것을 원하더라도, 모든 설계 요소는 다른 모든 것과 상호작용합니다. 예를 들어 *보안*을 개선하면 *성능*에 부정적인 영향을 미칠 가능성이 높습니다: 애플리케이션은 더 많은 비행 중 암호화, 우회(비밀 숨기기) 및 성능에 영향을 줄 수 있는 기타 활동을 수행해야 합니다. 비행기 조종사들은 각 손과 발에 대한 제어가 있는 헬리콥터 조종을 배울 때 종종 어려움을 겪습니다. 한 제어의 변경은 다른 모든 것에 영향을 미칩니다. 왜냐하면 그들은 시너지 효과가 있기 때문입니다. 헬리콥터를 조종하는 것은 아키텍처 특성을 선택할 때의 트레이드오프 프로세스를 잘 설명하는 균형 잡기 운동입니다; 그들은 다른 아키텍처 특성 및 도메인 설계와 유사한 방식으로 시너지 효과를 냅니다: 한 특성의 변경은 종종 다른 것의 변경을 수반합니다. 숙련된 헬리콥터 조종사처럼, 아키텍트는 서로 맞물린 요소들을 다루는 법을 배워야 합니다.

셋째, 아키텍처 특성에 대한 표준 정의의 부재는 이미 언급한 바와 같이 기업들이 모호성과 씨름한다는 것을 의미합니다. 업계는 불변의 아키텍처 특성 목록을 만들 수 없을 것이지만(새로운 것이 지속적으로 등장하기 때문에), 각 기업은 객관적 정의와 함께 자체 목록(또는 보편적 *언어*)을 만들 수 있습니다.

마지막으로, 아키텍처 특성의 수가 지속적으로 증가할 뿐만 아니라 *범주*의 수도 지난 10년 동안 증가했습니다. 예를 들어 몇십 년 전에는 아키텍트가 별도의 "블랙박스"로 간주되는 운영 관심사에 거의 신경 쓰지 않았습니다. 그러나 마이크로서비스와 같은 아키텍처의 증가하는 인기로 인해 아키텍트와 운영은 점점 더 집중적이고 빈번하게 협력해야 합니다. 소프트웨어 아키텍처가 더 복잡해질수록, 기업의 다른 영역과 더 얽히게 됩니다.

따라서 아키텍트가 시스템을 설계하고 모든 단일 아키텍처 특성을 최적화하는 것은 매우 드뭅니다. 대부분의 경우, 여러 경쟁하는 관심사 사이에서 절충안을 찾는 것입니다.

#### **팁 (TIPP)**

*최선의* 아키텍처가 아니라 *최소한의 나쁜* 아키텍처를 추구하십시오.

너무 많은 아키텍처 특성을 지원하려고 시도하면 모든 비즈니스 문제를 해결하려는 일반적인 솔루션으로 이어집니다.

설계는 빠르게 다루기 어려워지므로 그러한 아키텍처는 거의 작동하지 않습니다.

가능한 한 반복 가능한 아키텍처를 설계하도록 노력하십시오. 아키텍처를 변경하기 쉬울수록, 첫 시도에서 정확히 올바르게 만드는 데 모두가 덜 신경 써야 합니다. 애자일 소프트웨어 개발의 가장 중요한 교훈 중 하나는 반복의 가치입니다; 이것은 아키텍처를 포함하여 소프트웨어 개발의 모든 수준에 적용됩니다.
