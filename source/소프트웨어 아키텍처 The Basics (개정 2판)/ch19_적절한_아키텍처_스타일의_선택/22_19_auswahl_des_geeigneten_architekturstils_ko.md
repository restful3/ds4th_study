---
lang: ko
format:
  html:
    toc: true
    embed-resources: true
    theme: cosmo
---

# 19장. 적합한 아키텍처 스타일 선택 (Kapitel 19. Die Wahl des geeigneten Architekturstils)

이 저작물은 AI의 도움으로 번역되었습니다. 여러분의 피드백과 의견을 환영합니다: [translation-feedback@oreilly.com](mailto:translation-feedback@oreilly.com)

모든 것은 맥락에 달려 있습니다! 선택지는 셀 수 없이 많고(게다가 거의 매일 새로운 것이 등장합니다) 우리는 여러분에게 어떤 아키텍처 스타일(Architekturstil)을 써야 한다고 말해 주고 싶지만, 그럴 수 없습니다. 각 기업과 그곳에서 개발되는 소프트웨어 내부의 여러 요인에 따라 결론이 갈리기 때문입니다. 아키텍처 스타일을 고르는 일은 아키텍처 특성(Architekturmerkmale), 도메인 고려 사항, 전략적 목표, 그리고 수많은 다른 요소들 사이에서 절충을 분석하고 숙고하는 긴 과정의 정점입니다. 우리가 [2장](#page--1-0)에서 이미 언급했듯이, 따라서 답은 "상황에 따라 달라집니다"입니다.

결정이 아무리 맥락 의존적이라 하더라도, 이 장은 적절한 아키텍처 스타일을 선택하기 위한 몇 가지 일반적인 조언을 제공합니다.

## 아키텍처에서 변하는 "유행"

소프트웨어 업계가 선호하는 아키텍처 스타일은 여러 요인 때문에 시간이 지나면서 바뀝니다.

## 여기에 포함되는 요소:

## *과거에서 얻은 관찰 (Beobachtungen aus der Vergangenheit)*

새로운 아키텍처 스타일은 대체로 과거 경험, 특히 고통 지점을 관찰한 결과에서 등장합니다. 아키텍트가 시스템을 만들면서 겪는 경험(그 경험 때문에 아키텍트가 되기도 하죠)이 미래 시스템에 대한 생각에 영향을 줍니다. 새로운 아키텍처 설계는 과거 스타일의 특정한 한계를 바로잡는 방향으로 나오는 경우가 많습니다. 예를 들어, 우리는 코드 재사용에 초점을 맞춘 아키텍처를 설계한 뒤, 그에 따른 부정적 트레이드오프를 깨닫고 코드 재사용의 영향에 대해 진지하게 다시 생각하게 되었습니다.

## *생태계 변화 (Veränderungen im Ökosystem)*

소프트웨어 개발 생태계에서는 모든 것이 끊임없이 변합니다. 변화는 워낙 혼란스러워서 다음에 어떤 변화가 올지 예측조차 어렵습니다. 몇 년 전만 해도 아무도 쿠버네티스(Kubernetes)가 무엇인지 몰랐지만 지금은 많은 개발자가 일상적으로 사용합니다. 몇 년 뒤에는 아직 존재하지도 않는 다른 도구가 쿠버네티스를 대체할지도 모릅니다.

## *새로운 역량 (Neue Fähigkeiten)*

아키텍트는 새로운 도구뿐 아니라 새로운 패러다임에도 주의를 기울여야 합니다. 새로운 가능성이 등장하면 단지 도구 하나를 다른 것으로 바꾸는 것을 넘어, 아키텍처 전체가 완전히 새로운 패러다임으로 이동할 수 있습니다. 예컨대 도커(Docker) 같은 컨테이너의 등장으로 인해 소프트웨어 개발 세계에서 일어난 거대한 지각 변동을 예측한 사람은 많지 않았습니다. 진화적 단계처럼 보이지만, 그 영향은 아키텍트, 도구, 기술 절차 등 여러 측면에 놀라울 정도로 컸습니다. 생태계의 지속적 변화는 정기적으로 새로운 도구와 기능을 탄생시킵니다. 이미 갖고 있는 것과 비슷해 보이는 새로운 도구조차 판도를 바꿀 수 있는 미묘한 차이를 담고 있을 수 있습니다. 새로운 기능은 전체 개발 세계를 뒤집을 필요도 없습니다. 아키텍트의 목표에 딱 맞는 작은 변화 하나만으로도 모든 것이 달라질 수 있습니다.

## *가속화 (Beschleunigung)*

생태계는 끊임없이 변할 뿐 아니라 변화의 속도와 범위도 점점 빨라지고 넓어지고 있습니다. 새로운 도구가 새로운 개발 방식을 만들어 내고, 이는 다시 새로운 설계와 기능으로 이어지면서 소프트웨어 아키텍트를 항시 변화 속에 놓이게 합니다. 생성형 AI의 부상과 영향은 이러한 지속적인 진화와 예측 불가능성을 잘 보여 주는 사례입니다.

## *도메인 변화 (Domänenänderungen)*

기업이 진화하거나 다른 회사와 합병하면서 우리가 소프트웨어를 구축하는 도메인 역시 지속적으로 바뀝니다.

## *기술 변화 (Technologieänderungen)*

기업은 특히 수익에 명백한 이점을 주는 기술 변화만큼은 최소한 따라가려고 노력합니다.

## *외부 요인 (Externe Faktoren)*

소프트웨어 개발과는 주변부만 관련된 많은 외부 요인이 기업 내부의 변화를 촉발할 수 있습니다. 예를 들어, 특정 도구에 매우 만족하던 아키텍트와 개발자라도 라이선스 비용이 지나치게 높아지면 회사는 다른 선택지를 강제로 찾아야 할 수도 있습니다.

아키텍트는 최신 업계 동향을 이해해야만 자사 조직이 현재의 아키텍처 유행을 얼마나 따라가느냐와 무관하게 어떤 트렌드를 따를지, 언제 예외를 둘지를 현명하게 결정할 수 있습니다.

## 결정 기준 (Entscheidungskriterien)

아키텍처 스타일을 선택할 때 아키텍트는 도메인 설계를 구성하는 다양한 요인 전부를 고려해야 합니다. 기본적으로 아키텍트는 두 가지를 설계합니다. 하나는 정의된 도메인이고, 다른 하나는 시스템이 성공하기 위해 필요한 구조적 요소(아키텍처 특성이 제공)를 설계합니다.

다음 요소를 충분히 이해할 때까지 스타일을 결정하지 마십시오:

## *도메인 (Die Domäne)*

운영 아키텍처 특성에 영향을 주는 부분을 특히 중심으로, 비즈니스 도메인의 핵심 측면을 가능한 많이 이해하십시오. 아키텍트가 분야 전문가일 필요는 없지만 설계할 도메인의 주요 측면을 잘 이해하고 있어야 합니다. 비즈니스 분석가와 같은 다른 전문가가 있다면 부족한 지식을 채워 줄 수 있습니다.

*구조적 결정을 좌우하는 아키텍처 특성* 도메인과 외부 요인을 지탱하기 위해 필요한 아키텍처 특성이 무엇인지 식별하고 설명해야 합니다. 이를 위해 아키텍처 특성 분석을 수행하는데, 이는 스타일을 고를 때 가장 중요한 활동 중 하나입니다.

일반적인 아키텍처 스타일은 거의 모든 문제 도메인에 구현할 수 있습니다. '일반적'이라는 말이 결국 어디에나 적용할 수 있다는 뜻이니까요. 매우 확장성 높은 경매 사이트처럼 특별한 운영 아키텍처 특성이 필요한 도메인은 예외입니다. 대부분의 경우 아키텍처 스타일 간 차이는 도메인이 아니라, 각 스타일이 다양한 아키텍처 특성을 얼마나 잘 지원하느냐에 관한 것입니다.

이 책 2부에서 각 아키텍처 스타일을 비교할 때 사용한 별 모양 다이어그램이 도메인이 아니라 아키텍처 *특성*에 초점을 맞춘다는 사실을 기억할 것입니다. 이는 스타일을 고를 때 아키텍처 특성을 이해하는 일이 얼마나 중요한지를 보여 줍니다.

## *데이터 아키텍처 (Datenarchitektur)*

아키텍트와 데이터 개발자는 데이터베이스, 스키마, 기타 데이터 관련 주제에서 협업해야 합니다. 데이터 아키텍처는 그 자체로 하나의 전문 분야이므로 이 책에서는 스타일 관점 외에는 간단히만 다룹니다. 하지만 특정 데이터 설계가 아키텍처에 어떤 영향을 주는지, 특히 새로운 시스템이 기존 또는 이미 사용 중인 데이터 아키텍처와 상호작용해야 할 때 어떤 영향을 주는지를 반드시 알아야 합니다.

## *클라우드 배포 (Cloud-Einsätze)*

클라우드를 아키텍처 목표로 삼는 것은 계산과 데이터를 어디에 저장하느냐와 관련된 장기간의 변화 가운데 가장 최근 사례입니다. 온프레미스 운영을 위해 애플리케이션을 개발할 때 감수해야 하는 트레이드오프와 클라우드에서 운영하기 위해 개발할 때 감수해야 하는 트레이드오프는 크게 다릅니다. 애플리케이션이 얼마나 많은 데이터를 저장해야 하는지, 얼마나 많은 데이터를 이동할 수 있는지를 아는 것이 중요하며(데이터 이동에는 막대한 비용이 들 수 있습니다).

클라우드는 고도화된 역량이 시간이 지나며 어떻게 생활 필수품이 되는지를 보여 주는 좋은 예입니다. 10년 전만 해도 고탄력성과 확장성을 갖춘 온프레미스 시스템을 구축하려면 난해한 기술이 필요했고 거의 마법처럼 여겨졌습니다. 이제 아키텍트는 클라우드 공급자의 구성 매개변수만 변경해도 동일한 결과를 얻을 수 있습니다.

## *조직적 요인 (Organisatorische Faktoren)*

많은 외부 요인이 설계에 영향을 줍니다. 예를 들어 특정 클라우드 공급자의 비용이 너무 높으면 기업은 그보다 이상적인 설계를 추구하는 일을 포기할 수도 있습니다. 마찬가지로 회사가 인수합병을 계획하고 있다는 사실을 알게 되면 아키텍트는 개방형 솔루션과 통합 아키텍처를 선택하려 할 것입니다.

*프로세스, 팀, 운영 관련 지식* 프로젝트 특유의 많은 요인이 아키텍트의 설계에 영향을 줍니다. 예를 들어 소프트웨어 개발 프로세스, 아키텍트와 운영팀의 상호작용(혹은 그 부재), 품질 보증 프로세스 등이 그렇습니다. 어떤 회사가 애자일 개발 실무에 대한 성숙도가 부족하다면, 그 실무에 의존해야 성공할 수 있는 아키텍처(예: 마이크로서비스(Microservices))는 어려움을 겪게 됩니다.

## *도메인/아키텍처 동형성 (Bereich/Architektur-Isomorphismus)*

*아키텍처 동형성*은 아키텍처의 일반적인 "형태"를 가리키는 멋진 용어입니다. 다시 말해 전체 토폴로지 안에서 컴포넌트들이 서로 어떻게 의존하는지를 뜻합니다. *동형(Isomorphie)*이라는 단어는 "원소 사이의 집합과 관계를 유지하는 사상"을 의미하며, 그리스어 *isos*(같은)와 *morph*(형태, 모양)에서 파생되었습니다.

아키텍트는 아키텍처가 얼마나 적합한지를 고민할 때 그 일반적인 형태를 떠올립니다. 예를 들어 [그림](#page-7-0) 19-1에 나와 있는 계층형 아키텍처와 모듈형 모놀리식 아키텍처의 동형성 다이어그램을 비교해 보십시오. 두 아키텍처의 내부 형태는 분명합니다. 하나는 계층을 기준으로, 다른 하나는 도메인을 기준으로 분리되어 있습니다.

<span id="page-7-0"></span>![그림 19-1. 계층형과 모듈형 모놀리식 아키텍처 동형성 비교](_page_7_Picture_2.jpeg)

그림 19-1. 계층형 모놀리식과 모듈형 모놀리식의 동형 표현 비교

모놀리식 아키텍처와 분산 아키텍처의 차이 역시 [그림](#page-8-0) 19-2와 같은 동형도에서 쉽게 드러납니다. 여기서는 핵심 컴포넌트가 분산되면서 아키텍처의 거시적 측면이 한눈에 보입니다.

<span id="page-8-0"></span>![그림 19-2. 모놀리식과 분산 아키텍처 동형성 비교](_page_8_Picture_1.jpeg)

그림 19-2. 모놀리식 아키텍처와 분산 아키텍처의 동형 표현 비교

일부 문제 도메인은 특정 아키텍처 토폴로지와 잘 들어맞습니다. 예를 들어 마이크로커널 아키텍처는 맞춤형 기능이 필요한 시스템에 매우 적합합니다. 아키텍트가 맞춤 기능을 플러그인으로 구현할 수 있기 때문입니다. 또 다른 예로, 수많은 이산 연산이 필요한 게놈 분석 시스템은 다수의 이산 프로세서를 제공하는 공간 기반 아키텍처와 잘 맞습니다.

반대로 특정 도메인은 어떤 아키텍처와도 특히 잘 맞지 않습니다. 매우 확장성이 높은 시스템은 커다란 모놀리식 설계에서 애를 먹는데, 강하게 결합된 코드 기반으로는 많은 동시 사용자를 지원하기 어렵기 때문입니다. 높은 수준의 의미적 결합을 요구하는 도메인도 강하게 분리된 분산 아키텍처와는 잘 어울리지 않습니다. 예를 들어 여러 페이지로 이루어진 보험 애플리케이션이고 각 페이지가 이전 페이지의 맥락에 의존한다면 이는 강하게 결합된 문제입니다. 이를 마이크로서비스처럼 느슨하게 결합된 아키텍처로 모델링하기는 어렵습니다. 서비스 기반 아키텍처처럼 의도적으로 결합을 허용하는 아키텍처가 이런 문제에 더 잘 맞습니다.

이 모든 요소를 고려하다 보면 아키텍처 스타일을 선택할 때 다음과 같은 결정을 내려야 합니다.

### *모놀리식인가, 분산형인가? (Monolithisch oder verteilt?)*

설계를 위해 단일한 아키텍처 특성 집합만 있으면 되는가, 아니면 시스템 일부마다 서로 다른 아키텍처 특성이 필요한가요? 요구 특성이 하나의 집합이라면(다른 요소가 분산형 아키텍처를 지지하더라도) 모놀리식이 적합합니다. 서로 다른 특성 집합이 필요하다면 분산 아키텍처가 필요합니다. [7장](#page--1-0)에서 다룬 아키텍처 퀀텀(Architekturquantum) 개념은 이 결정을 내리는 데 도움이 됩니다.

## *데이터는 어디에 위치해야 하는가? (Wo sollen Daten leben?)*

모놀리식 아키텍처에서는 보통 하나의 관계형 데이터베이스(혹은 아주 소수의 데이터베이스)만 사용한다고 가정합니다. 분산 아키텍처에서는 어떤 서비스가 데이터를 보관할지를 결정해야 하며, 이는 데이터를 흐르게 해 워크플로를 구성하는 방식까지 고민해야 함을 의미합니다. 아키텍처를 설계할 때 구조와 동작을 모두 고려하고, 더 나은 조합을 찾을 수 있도록 주저하지 말고 설계를 반복하십시오.

*서비스는 동기식으로 통신해야 할까요, 아니면 비동기식으로 통신해야 할까요?* 데이터가 어디에 저장될지 결정했다면 다음으로 고려할 것은 서비스 간 통신 방식입니다. 동기 통신은 편리한 경우가 많지만 확장성, 안정성 등 원하는 특성을 희생해야 할 수도 있습니다. 비동기 통신은 성능과 확장성 측면에서 독특한 이점을 제공하지만, 데이터 동기화, 데드락, 경쟁 상태, 디버깅 같은 문제를 대거 야기할 수 있습니다. 이러한 문제 가운데 다수를 [15장](#page--1-0)에서 다룹니다.

동기 통신은 설계, 구현, 디버깅 측면에서 문제가 적으므로 가능하면 기본적으로 동기 통신을 사용하고 필요할 때만 비동기 통신을 도입할 것을 권합니다.

#### **팁 (TIPP)**

기본값은 동기 통신, 필요할 때 비동기 통신을 사용하십시오.

이 설계 과정의 결과물은 선택한 아키텍처 스타일(및 필요한 하이브리드화), 가장 큰 노력이 드는 설계 부분을 기록한 아키텍처 결정 기록(ADR), 핵심 원칙과 운영 아키텍처 특성을 보호하기 위한 아키텍처 피트니스 함수 등을 담은 *아키텍처 토폴로지*입니다.

# 모놀리식 사례 연구: 실리콘 샌드위치 (Monolith Fallstudie: Silizium-Sandwiches)

[5장](#page--1-0)의 실리콘 샌드위치(Silicon Sandwiches) 아키텍처 카타에서 우리는 아키텍처 특성을 분석한 결과 단일 퀀텀만으로 시스템을 구현할 수 있다고 결론지었습니다. 큰 예산이 들지 않는 단순한 애플리케이션이었기에 모놀리식의 단순함은 아주 매력적이었습니다.

그러나 우리는 실리콘 샌드위치에 대해 두 가지 서로 다른 컴포넌트 설계를 만들었습니다. 하나는 도메인 분할, 다른 하나는 기술 분할입니다. 복습이 필요하다면 [5장](#page--1-0)으로 돌아가 보십시오. 이 장에서는 이 단순한 솔루션을 다시 살펴 각 옵션을 위한 설계를 만들고 그 트레이드오프를 논의합니다. 먼저 모놀리식 아키텍처부터 시작합니다.

## **모듈형 모놀리식 (Modularer Monolith)**

모듈형 모놀리식은 단일 데이터베이스를 사용하는 도메인 중심 컴포넌트를 구성하며, 하나의 퀀텀으로 배포됩니다. 실리콘 샌드위치의 모듈형 모놀리식 설계는 [그림](#page-13-0) 19-3에 나와 있습니다.

이 설계는 단일 관계형 데이터베이스를 가진 모놀리식이며, 총비용을 낮추기 위해 웹 기반 단일 사용자 인터페이스(모바일을 위한 신중한 설계 고려 포함)로 구현되었습니다. 우리가 식별한 각 영역은 하나의 컴포넌트로 나타납니다. 시간이 있고 자원이 충분하다면 도메인 컴포넌트와 마찬가지로 테이블 및 다른 데이터베이스 구성 요소도 분리하는 것을 고려해야 합니다. 그러면 미래에 요구 사항이 바뀌어도 이 아키텍처를 분산 아키텍처로 마이그레이션하기가 훨씬 쉬워집니다.

![그림 19-3. 실리콘 샌드위치용 모듈형 모놀리식 설계](_page_13_Figure_0.jpeg)

아키텍처 스타일 자체는 맞춤 기능을 허용하지 않으므로, 이 기능은 도메인 설계의 일부가 되어야 합니다. 이 경우 아키텍트는 개발자가 개별 커스터마이징을 업로드할 수 있는 오버라이드 엔드포인트를 설계합니다. 따라서 각 도메인 컴포넌트가 모든 맞춤형 특성에 대해 오버라이드 컴포넌트를 참조하도록 해야 합니다. (이를 검증하는 일은 아키텍처 피트니스 함수에 아주 잘 어울리는 과제입니다.)

## **마이크로커널 (Mikrokernel)**

실리콘 샌드위치에서 식별한 아키텍처 특성 가운데 하나는 맞춤 능력입니다. [그림](#page-15-0) 19-4는 도메인과 아키텍처 간 동형을 활용해 마이크로커널 아키텍처로 이를 구현하는 방법을 보여 줍니다.

![그림 19-4. 실리콘 샌드위치용 마이크로커널 설계](_page_15_Figure_0.jpeg)

[그림](#page-15-0) 19-4에서 코어 시스템은 도메인 컴포넌트와 단일 관계형 데이터베이스로 구성됩니다. 모듈형 모놀리식 설계와 마찬가지로, 도메인과 데이터 설계를 면밀히 동기화하면 미래에 코어를 분산 아키텍처로 옮기기 쉬워집니다. 모든 커스터마이징은 플러그인으로 나타나며, 공용 플러그인은 단일 세트(해당 데이터베이스 포함)에, 지역 플러그인은 각각 고유한 데이터와 함께 나타납니다. 플러그인끼리는 서로 결합할 필요가 없으므로 각 플러그인은 자체 데이터를 유지하면서 분리된 상태를 유지할 수 있습니다.

이 설계의 다른 독특한 요소는 백엔드 포 프런트엔드(Backends for Frontends, BFF) 패턴을 [활용해](https://oreil.ly/i3Hsc) API 계층을 코어 아키텍처에 덧붙는 얇은 마이크로커널 어댑터로 만든다는 점입니다. API 계층은 백엔드에서 제공되는 일반 정보를 BFF 어댑터에 전달하고, 각 어댑터는 이를 프런트엔드 디바이스에 맞는 형식으로 변환합니다. 예를 들어 iOS용 BFF는 일반적인 백엔드 출력을 받아 데이터 형식, 페이지 나누기, 지연 시간 등 요소를 네이티브 iOS 애플리케이션이 기대하는 방식으로 조정합니다. BFF 어댑터를 각각 개발하면 사용자 인터페이스의 다양성을 최대한 확보할 수 있고, 향후 다른 디바이스를 지원하도록 아키텍처를 확장하기가 쉬워집니다. 이는 마이크로커널 스타일의 장점 가운데 하나입니다.

이 두 실리콘 샌드위치 아키텍처 내부의 통신은 동기식으로 이뤄도 됩니다. 이 아키텍처에는 극단적인 성능이나 탄력성 요구 사항이 없고, 어떤 연산도 장시간 실행되지 않기 때문입니다.

# 분산 사례 연구: Going, Going, Going

[8장](#page--1-0)에 등장하는 Going, Going, Gone(GGG) 카타는 또 다른 흥미로운 아키텍처 도전을 제시합니다. "사례 연구: [Going, Going, Gone—컴포넌트 발견하기](#page--1-1)"에서 수행한 컴포넌트 분석 덕분에, 이 아키텍처의 각 부분이 서로 다른 특성을 필요로 한다는 사실을 알고 있습니다. 예를 들어 가용성과 확장성 요구 사항은 역할(경매 진행자와 입찰자)에 따라 서로 다릅니다.

GGG 시스템 요구 사항은 확장성, 탄력성, 성능 등 까다로운 운영 아키텍처 특성에 대해 야심 찬 기대치를 제시합니다. 아키텍처 패턴은 세밀한 수준의 높은 맞춤성을 허용해야 합니다. 후보 분산 아키텍처 가운데에서는 이벤트 기반 저수준 아키텍처와 마이크로서비스가 요구되는 아키텍처 특성 대부분을 가장 잘 충족시킵니다. 그중에서도 마이크로서비스가 운영 아키텍처 특성의 변동을 지원하기에 더 적합합니다(순수한 이벤트 기반 아키텍처에서는 요소를 아키텍처 특성별로 나누기보다 오케스트레이션 통신인지 코레오그래피 통신인지 여부로 나누는 경우가 많습니다).

명시된 성능 목표를 충족하는 일은 마이크로서비스에서도 도전 과제이지만, 아키텍처의 취약점을 해결하는 최선의 방법은 그 취약점을 인지하고 고려하는 것입니다. 마이크로서비스는 본질적으로 높은 수준의 확장성을 제공하지만, 오케스트레이션이 지나치게 많거나 데이터 분리가 너무 공격적인 경우처럼 특정한 성능 문제가 자주 발생합니다.

![그림 19-5. GGG 아키텍처의 서비스 분해](_page_19_Figure_0.jpeg)

[그림](#page-19-0) 19-5에서는 식별한 각 컴포넌트가 아키텍처 내의 하나의 서비스로 표현되며, 컴포넌트의 세분성이 서비스의 세분성과 일치합니다. GGG에는 서로 다른 세 가지 사용자 인터페이스가 있습니다:

*입찰자 (Bieter)*

온라인 경매에 참여하는 수많은 입찰자.

*경매 진행자 (Auktionator)*

경매마다 한 명.

*스트리머 (Streamer)*

입찰자에게 비디오와 입찰 정보를 스트리밍하는 서비스입니다. 업데이트가 필요할 때 수행할 수 없는 최적화를 가능하게 하는 읽기 전용 스트림입니다.

이 GGG 아키텍처 설계에는 다음과 같은 서비스가 등장합니다:

*입찰 캡처 (Bid Capture)*

온라인 입찰자의 입력을 수집해 입찰 추적기(Bid Tracker)에 비동기적으로 보냅니다. 온라인 입찰의 통로 역할만 하므로 이 서비스에는 영속성이 필요 없습니다.

*입찰 스트리머 (Bid Streamer)*

입찰을 고성능 읽기 전용 스트림으로 온라인 참가자에게 전송합니다.

#### *입찰 추적기 (Bid Tracker)*

경매 진행자 캡처(Auctioneer Capture)와 입찰 캡처(Bid Capture) 양쪽에서 온 입찰을 추적하고, 두 정보 흐름을 통합해 가능한 한 실시간에 가깝게 정렬합니다. 이 서비스로 들어오는 두 연결 모두 비동기식이므로, 개발자는 메시지 큐를 버퍼로 사용해 매우 다른 메시지 흐름 속도를 처리할 수 있습니다.

#### *경매 진행자 캡처 (Auctioneer Capture)*

경매 진행자를 위한 입찰을 수집합니다. "사례 연구: Going, Going, Gone—컴포넌트 발견하기" 분석 결과 입찰 캡처와 경매 진행자 캡처가 요구하는 아키텍처 특성이 매우 다르다는 사실을 알게 되었고, 그래서 두 서비스를 분리했습니다.

## *경매 세션 (Auction Session)*

각각의 경매 워크플로를 관리합니다.

#### *결제 (Payment)*

경매 세션이 경매를 종료한 뒤 결제 정보를 처리하는 외부 결제 제공자입니다.

#### *비디오 캡처 (Video Capture)*

라이브 경매의 비디오 스트림을 캡처합니다.

## *비디오 스트리머 (Video Streamer)*

경매 비디오를 온라인 입찰자에게 스트리밍합니다.

이 아키텍처에서는 동기 통신과 비동기 통신을 모두 사용하도록 주의했습니다. 비동기 통신을 선택한 이유는 주로 각 서비스가 요구하는 운영 아키텍처 특성이 서로 다르기 때문입니다. 예를 들어 Payment 서비스가 500ms마다 결제 하나만 처리할 수 있고 동시에 많은 경매가 종료된다면, 서비스 간 동기 통신은 타임아웃과 기타 신뢰성 문제를 일으킬 것입니다. 메시지 큐를 사용하면 취약하지만 중요한 아키텍처 부분의 신뢰성을 높일 수 있습니다.

![그림 19-6. GGG 아키텍처의 퀀텀 분해](_page_23_Figure_0.jpeg)

결국 이 설계는 [그림](#page-23-0) 19-6과 같이 대략 서비스에 해당하는 다섯 개의 퀀텀(Quanten)으로 분해되었습니다. Payment, Auctioneer, Bidder, Bidder Streams, Bid Tracker가 그것입니다. 도식에서 여러 인스턴스는 컨테이너 스택으로 표시됩니다. 컴포넌트 설계 단계에서 퀀텀 분석을 적용하면 서비스, 데이터, 통신 사이의 경계를 식별하기가 쉬워집니다.

이것이 GGG에 대한 "정답" 설계라고 주장하는 것은 아니며, 유일한 설계도 아닙니다. 최선의 설계라고 말할 수도 없지만, 가장 "덜 나쁜" 절충안을 제공하는 것으로 보입니다. 마이크로서비스를 선택하고 이벤트와 메시지를 현명하게 활용하면, 이 아키텍처는 범용 아키텍처 패턴의 장점을 극대화하면서 동시에 향후 진화와 확장을 위한 기반을 마련할 수 있습니다.
