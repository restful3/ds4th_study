적절한 아키텍처 스타일 선택

요약

소프트웨어 아키텍처 스타일의 선택은 단 하나의 정답이 없는 고도로 상황 의존적인 과정입니다. 최적의 아키텍처는 비즈니스 도메인, 필요한 아키텍처 특성, 조직의 목표 및 제약 조건 등 다양한 요소를 종합적으로 분석하고 절충안을 찾는 과정의 정점입니다.

아키텍처 트렌드는 과거 스타일의 문제점을 해결하려는 시도, 소프트웨어 생태계의 지속적인 변화, Docker나 생성형 AI와 같은 새로운 기술 패러다임의 등장 등 여러 동인에 의해 끊임없이 진화합니다. 따라서 아키텍트는 현재 업계 동향을 명확히 이해하고, 이를 바탕으로 정보에 입각한 결정을 내릴 수 있어야 합니다.

아키텍처 스타일을 선택할 때는 다음의 핵심 기준들을 반드시 고려해야 합니다.

* 도메인 및 아키텍처 특성: 비즈니스 도메인에 대한 충분한 이해를 바탕으로 시스템 성공에 필수적인 아키텍처 특성(예: 확장성, 탄력성, 맞춤성)을 식별해야 합니다. 스타일 선택은 도메인 자체보다 이러한 특성을 얼마나 잘 지원하는지에 더 크게 좌우됩니다.
* 기술 및 조직적 요인: 데이터 아키텍처, 클라우드 도입 여부, 라이선스 비용, 팀의 Agile 성숙도와 같은 조직 및 기술적 제약 조건들이 설계에 큰 영향을 미칩니다.
* 구조적 동형성(Isomorphism): 아키텍처의 전체적인 "모양"이나 토폴로지가 문제 도메인의 구조와 잘 들어맞는지 평가해야 합니다. 예를 들어, 맞춤화가 중요한 시스템은 마이크로커널 아키텍처에, 의미론적으로 강하게 결합된 워크플로는 마이크로서비스보다 서비스 기반 아키텍처에 더 적합할 수 있습니다.

이러한 분석을 바탕으로 아키텍트는 모놀리식 또는 분산형 구조, 데이터 저장 및 흐름 방식, 서비스 간 동기 또는 비동기 통신 방식과 같은 주요 설계 결정을 내리게 됩니다. 일반적으로, 설계 및 디버깅이 용이한 동기 통신을 기본으로 하되, 성능 및 안정성 요구사항을 충족하기 위해 필요할 때만 비동기 통신을 사용하는 것이 권장됩니다.


--------------------------------------------------------------------------------


아키텍처 "유행"의 변화와 그 동인

소프트웨어 산업에서 선호되는 아키텍처 스타일은 시간이 지남에 따라 변화합니다. 아키텍트는 이러한 변화의 흐름과 그 원인을 이해하여, 현재 유행을 무조건 따르기보다 지능적인 결정을 내릴 수 있어야 합니다. 아키텍처 트렌드를 변화시키는 주요 요인은 다음과 같습니다.

* 과거 경험으로부터의 관찰: 새로운 아키텍처 스타일은 주로 과거의 경험, 특히 이전 스타일의 문제점에서 비롯됩니다. 예를 들어, 과거 코드 재사용에 지나치게 집중했던 아키텍처의 부정적인 절충안을 경험한 아키텍트들은 코드 재사용의 영향을 재고하게 되었습니다.
* 소프트웨어 생태계의 변화: 소프트웨어 개발 생태계는 예측 불가능할 정도로 혼란스럽고 끊임없이 변화합니다. 몇 년 전에는 생소했던 Kubernetes가 이제 많은 개발자의 일상이 되었고, 몇 년 후에는 아직 존재하지 않는 다른 도구로 대체될 수 있습니다.
* 새로운 기능의 출현: Docker와 같은 컨테이너 기술의 등장은 아키텍처, 도구, 기술 관행 전반에 걸쳐 지각 변동을 일으켰습니다. 이처럼 새로운 기능이나 패러다임은 단순히 도구를 대체하는 것을 넘어 완전히 새로운 아키텍처 접근법을 가능하게 합니다.
* 변화의 가속화: 생태계의 변화는 지속적일 뿐만 아니라 그 속도 또한 점점 빨라지고 있습니다. 새로운 도구는 새로운 개발 방식을 창출하고, 이는 다시 새로운 설계와 기능으로 이어지며 아키텍트를 끊임없는 변화 속에 놓이게 합니다. 생성형 AI의 부상과 영향력은 이러한 지속적인 진화와 예측 불가능성의 대표적인 예입니다.
* 도메인 및 기술 변화: 기업이 발전하거나 다른 기업과 합병함에 따라 소프트웨어가 다루는 비즈니스 도메인도 계속해서 변화합니다. 또한, 기업은 수익에 직접적인 이점을 주는 기술 변화에 발맞추려 노력합니다.
* 외부 요인: 소프트웨어 개발과 직접적인 관련이 적은 외부 요인도 변화를 유발할 수 있습니다. 예를 들어, 특정 도구의 라이선스 비용이 과도하게 상승하면 기업은 다른 대안으로 전환할 수밖에 없습니다.

아키텍처 스타일 선택을 위한 핵심 결정 기준

아키텍처 스타일을 성급하게 결정하기 전에, 도메인 설계 구조에 기여하는 다양한 요인들을 충분히 파악하고 고려해야 합니다.

* 도메인에 대한 이해: 비즈니스 도메인의 핵심적인 측면, 특히 운영 아키텍처 특성에 영향을 미치는 부분들을 최대한 이해해야 합니다. 아키텍트가 도메인 전문가일 필요는 없지만, 설계할 도메인의 주요 측면에 대한 충분한 일반 지식은 갖추어야 합니다.
* 아키텍처 특성 분석: 스타일 선택에서 가장 중요한 활동 중 하나는 아키텍처 특성 분석입니다. 도메인과 기타 외부 요인을 지원하는 데 필요한 아키텍처 특성이 무엇인지 명확히 식별하고 정의해야 합니다. 대부분의 범용 아키텍처 스타일은 거의 모든 문제 도메인에 구현 가능하므로, 스타일 간의 차이는 특정 도메인 지원 여부보다 다양한 아키텍처 특성을 얼마나 잘 지원하는지에 따라 결정됩니다.
* 데이터 아키텍처 고려사항: 아키텍트는 데이터 개발자와 협력하여 데이터베이스, 스키마 및 기타 데이터 관련 문제를 논의해야 합니다. 특히 새로운 시스템이 기존 데이터 아키텍처와 상호작용해야 할 경우, 특정 데이터 설계가 아키텍처에 미치는 영향을 파악하는 것이 중요합니다.
* 클라우드 배포: 클라우드 환경을 위한 애플리케이션 설계는 온프레미스 환경 설계와는 전혀 다른 절충안을 요구합니다. 클라우드는 과거에 고도의 전문 기술이 필요했던 높은 탄력성 및 확장성과 같은 기능을 클라우드 제공업체의 구성 매개변수 변경만으로 달성할 수 있게 해주는 대표적인 예입니다.
* 조직적 요인: 특정 클라우드 제공업체의 비용 정책이나 회사의 인수합병 계획과 같은 외부 요인은 아키텍트가 개방형 솔루션이나 통합 아키텍처를 선택하도록 유도할 수 있습니다.
* 프로세스, 팀, 운영 관련 지식: 소프트웨어 개발 프로세스, 팀의 Agile 성숙도, 운영팀과의 상호작용 방식 등 프로젝트별 요인도 설계에 영향을 미칩니다. 예를 들어, Agile 개발 방식에 대한 조직의 성숙도가 낮다면 마이크로서비스와 같이 해당 방식에 크게 의존하는 아키텍처는 성공하기 어렵습니다.
* 도메인/아키텍처 동형성(Isomorphism): 아키텍처의 전반적인 "형태", 즉 전체 토폴로지 내에서 컴포넌트들이 서로 의존하는 방식을 의미합니다.
  * 구조적 차이: 계층형 아키텍처(기술 계층별 분리)와 모듈러 모놀리스(도메인별 분리)의 구조는 명확히 다릅니다. 또한, 모놀리식 아키텍처와 분산 아키텍처는 핵심 컴포넌트의 분포에서 거시적인 차이를 보입니다.
  * 토폴로지 적합성: 특정 문제 도메인은 특정 아키텍처 토폴로지에 자연스럽게 부합합니다. 예를 들어, 시스템 맞춤화가 중요하다면 플러그인 개발을 지원하는 마이크로커널 아키텍처가 적합합니다. 반면, 높은 확장성이 필요한 시스템은 대규모 모놀리식 설계에 어려움을 겪으며, 여러 페이지의 이전 컨텍스트에 의존하는 보험 신청서와 같이 의미론적으로 강하게 결합된 문제 도메인은 마이크로서비스처럼 고도로 분리된 아키텍처에 적합하지 않습니다.

계층형 아키텍처 (Layered architecture)	모듈러 모놀리스 (Modular monolith)
	
기술 계층에 따른 분리	비즈니스 도메인에 따른 분리

모놀리식 아키텍처 (Monolithic architectures)	분산 아키텍처 (Distributed architectures)
	
단일 배포 단위 내의 컴포넌트	네트워크로 연결된 독립적인 컴포넌트

주요 설계 결정 사항

앞서 논의된 기준들을 모두 고려한 후, 아키텍트는 아키텍처 스타일 선택 과정에서 다음과 같은 구체적인 결정을 내려야 합니다.

* 모놀리식 vs. 분산: 시스템 전체에 단일한 아키텍처 특성 집합이 충분한가, 아니면 각 부분마다 서로 다른 특성이 필요한가? 전자는 모놀리식, 후자는 분산 아키텍처가 적합함을 시사합니다. 이 결정에는 아키텍처 퀀텀(Architectural Quantum) 개념이 도움이 됩니다.
* 데이터의 위치: 모놀리식 아키텍처는 보통 단일 관계형 데이터베이스를 가정합니다. 분산 아키텍처에서는 어떤 서비스가 데이터를 소유할지, 그리고 워크플로를 위해 데이터가 아키텍처 내에서 어떻게 흘러갈지를 결정해야 합니다.
* 동기 vs. 비동기 통신: 서비스 간 통신을 동기식으로 할지, 비동기식으로 할지 결정해야 합니다.
  * 동기 통신: 구현이 편리하지만 확장성, 신뢰성 등에서 절충이 필요할 수 있습니다.
  * 비동기 통신: 성능과 확장성 면에서 독특한 이점을 제공하지만, 데이터 동기화, 교착 상태, 경쟁 조건, 디버깅 등에서 복잡성을 야기합니다.
  * 권장 사항: 기본적으로 동기 통신을 사용하고, 필요할 때만 비동기 통신을 사용하십시오.
* 설계 프로세스의 결과물: 이 설계 과정의 최종 산출물은 선택된 아키텍처 스타일(및 하이브리드 형태), 주요 결정에 대한 아키텍처 결정 기록(ADR), 그리고 중요한 원칙과 운영 특성을 보호하기 위한 아키텍처 피트니스 함수를 포함하는 아키텍처 토폴로지입니다.

사례 연구: 이론의 실제 적용

모놀리식 사례: 실리콘 샌드위치 (Silicon Sandwiches)

이 사례는 단순한 애플리케이션과 제한된 예산을 가진 시나리오로, 단일 아키텍처 퀀텀으로 충분하다고 분석되었습니다. 따라서 모놀리식 아키텍처의 단순성이 매력적인 선택지였습니다.

설계 옵션 1: 모듈러 모놀리스

도메인 중심 컴포넌트와 단일 데이터베이스를 기반으로 구축되며, 단일 퀀텀으로 배포됩니다. 각 비즈니스 도메인은 별도의 컴포넌트로 표현됩니다. 향후 분산 아키텍처로의 마이그레이션을 용이하게 하려면, 도메인 컴포넌트와 마찬가지로 데이터베이스 테이블도 도메인별로 분리하는 것이 좋습니다. '맞춤성'이라는 아키텍처 특성을 지원하기 위해, 개발자가 개별 맞춤 기능을 업로드할 수 있는 Override 엔드포인트를 설계하고, 모든 도메인 컴포넌트가 이 Override 컴포넌트를 참조하도록 합니다.



설계 옵션 2: 마이크로커널

이 설계는 '맞춤성' 특성을 아키텍처 스타일 자체로 해결합니다. 핵심 시스템은 도메인 컴포넌트들과 단일 관계형 데이터베이스로 구성됩니다. 각 맞춤 기능은 플러그인으로 구현되며, 공통 플러그인과 각 지역별 로컬 플러그인으로 나뉩니다. 플러그인들은 서로 분리되어 각자의 데이터를 가질 수 있습니다. 또한, 이 설계는 BFF(Backends for Frontends) 패턴을 사용하여 API 계층을 iOS, Android, Web 등 다양한 프론트엔드를 위한 얇은 어댑터로 만듭니다.



두 설계 모두 극단적인 성능이나 탄력성 요구사항이 없으므로, 내부 통신은 동기식으로 충분합니다.

분산 아키텍처 사례: 고잉, 고잉, 곤 (Going, Going, Gone - GGG)

온라인 경매 사이트인 GGG는 확장성, 탄력성, 성능 등 까다로운 운영 아키텍처 특성을 요구합니다. 또한 경매인과 입찰자 등 역할에 따라 필요한 특성이 다르므로, 분산 아키텍처가 적합합니다.

선택된 스타일: 마이크로서비스

다양한 운영 아키텍처 특성 변형을 가장 잘 지원할 수 있는 마이크로서비스가 선택되었습니다. 성능 목표 달성이 도전 과제일 수 있지만, 이는 설계를 통해 해결해야 할 문제입니다.

설계 상세

식별된 각 컴포넌트는 개별 서비스가 됩니다. 주요 서비스는 다음과 같습니다.

* Bid Capture: 온라인 입찰자의 입찰을 받아 비동기적으로 Bid Tracker로 전송합니다.
* Bid Streamer: 입찰 내용을 온라인 참가자에게 스트리밍하는 고성능 읽기 전용 서비스입니다.
* Bid Tracker: 경매인과 온라인 입찰자 양쪽의 입찰 정보를 통합하고 순서를 정합니다.
* Auctioneer Capture: 경매인의 입찰을 받습니다. Bid Capture와는 운영 특성이 매우 달라 별도 서비스로 분리되었습니다.
* Auction Session: 개별 경매의 워크플로를 관리합니다.
* Payment: 경매 종료 후 결제를 처리하는 제3자 제공업체 서비스입니다.
* Video Capture/Streamer: 실시간 경매 비디오를 캡처하고 스트리밍합니다.



이 아키텍처는 동기 및 비동기 통신을 혼합하여 사용합니다. 특히 각 서비스의 서로 다른 운영 특성을 수용하기 위해 비동기 통신이 전략적으로 사용되었습니다. 예를 들어, Payment 서비스의 처리 속도가 느릴 경우를 대비해 메시지 큐를 버퍼로 사용하여 시스템 전체의 신뢰성을 높입니다.

아키텍처 퀀텀 분석

이 설계는 최종적으로 Payment, Auctioneer, Bidder, Bidder Streams, Bid Tracker의 5개 퀀텀으로 분해되었습니다. 컴포넌트 설계 단계에서 퀀텀 분석을 적용함으로써 서비스, 데이터, 통신 간의 경계를 명확히 할 수 있었습니다.



결론: 이 설계는 유일하거나 "올바른" 설계가 아니며, 심지어 "최고의" 설계라고 주장할 수도 없습니다. 하지만 주어진 요구사항과 제약 조건 하에서 "가장 나쁘지 않은" 절충안을 제시합니다. 마이크로서비스를 선택하고 이벤트와 메시징을 지능적으로 활용함으로써, 이 아키텍처는 미래의 발전과 확장을 위한 견고한 기반을 마련합니다.
