---
lang: ko
format:
  html:
    toc: true
    embed-resources: true
    theme: cosmo
---

# 3장. 모듈성

이 문서는 AI를 사용하여 번역되었습니다. 여러분의 피드백과 의견을 환영합니다: [translation-feedback@oreilly.com](mailto:translation-feedback@oreilly.com)

건축가(아키텍트)와 개발자들은 오랫동안 모듈성(Modularität) 개념을 다루어 왔으며, 이는 *Composite/Structured Design*에 인용된 다음 문구에서 잘 나타납니다:

*소프트웨어 아키텍처에 대한 텍스트 중 95%가 "모듈성"의 이점을 찬양하지만, 이를 달성하는 방법에 대해서는 거의 언급하지 않습니다.*

### —글렌포드 J. 마이어스

다양한 플랫폼은 코드 재사용을 위한 여러 메커니즘을 제공하지만, 모두 응집성 있는 코드(zusammenhängenden Code)를 *모듈*로 묶는 방법을 지원합니다. 이 개념은 소프트웨어 아키텍처에서 보편적이지만, 정의하기는 어려운 것으로 판명되었습니다. 간단한 인터넷 검색만으로도 통일되지 않고 (부분적으로는 상충되는) 수십 가지 정의가 나옵니다. 이는 새로운 문제는 아닙니다. 그러나 인정된 정의가 없기 때문에, 우리는 책 전체의 일관성을 보장하기 위해 우리만의 정의를 제시해야 합니다.

건축가(아키텍트)에게는 자신이 선택한 개발 플랫폼에서 모듈성과 그 다양한 형태를 이해하는 것이 중요합니다. 아키텍처 분석에 사용할 수 있는 많은 도구(예: 메트릭, 적합성 함수, 시각화)는 모듈성과 관련 개념을 기반으로 합니다. *모듈성*은 정리 원칙입니다. 아키텍트가 개별 부분이 어떻게 상호 연결되는지에 주의를 기울이지 않고 시스템을 설계한다면, 그 시스템은 수많은 어려움을 겪을 것입니다. 물리학의 비유를 사용하자면, 소프트웨어 시스템은 엔트로피(무질서) 경향이 있는 복잡한 시스템을 형성합니다. 물리적 시스템에서는 질서를 유지하기 위해 에너지를 공급해야 합니다. 소프트웨어 시스템도 마찬가지입니다. 아키텍트들은 구조적 안정성을 보장하기 위해 끊임없이 에너지를 투입해야 하며, 이는 우연히 발생하지 않습니다.

좋은 모듈성을 유지하는 것은 *암묵적* 아키텍처 특성에 대한 우리의 정의의 한 예입니다. 사실상 어떤 프로젝트 요구사항도 아키텍트에게 좋은 모듈식 구분과 통신을 명시적으로 요구하지 않지만, 지속 가능한 코드베이스는 이를 통해 가져오는 질서와 일관성을 필요로 합니다.

# 모듈성 대(對) 세분성

개발자와 아키텍트는 종종 *모듈성*(Modularität)과 *세분성*(Granularität)이라는 용어를 동의어처럼 사용하지만, 이들은 매우 다른 의미를 가집니다. 모듈성은 시스템을 더 작은 부분으로 분해하는 것에 관한 것입니다. 예를 들어, 모놀리식 아키텍처(전통적인 N계층 아키텍처와 같은)에서 마이크로서비스와 같은 고도로 분산된 아키텍처로 전환하는 것이 여기에 해당합니다. 반면, 세분성은 이러한 부분들의 *크기*, 즉 시스템(또는 서비스)의 특정 부분이 얼마나 커야 하는지에 관한 것입니다. 다음 인용문에서 저자 중 한 명이 말했듯이, 아키텍트와 개발자를 곤경에 빠뜨리는 것은 바로 *세분성*입니다:

*모듈성을 받아들이되, 세분성은 경계하라.*

## —마크 리처즈

세분성은 서비스나 구성 요소가 서로 결합되게 하여, *스파게티 아키텍처*, *분산형 모놀리스*, 그리고 악명 높은 *빅 볼 오브 분산 머드(Big Ball of Distributed Mud)*와 같은 복잡하고 유지보수하기 어려운 아키텍처 패턴으로 이어집니다. 이러한 아키텍처 패턴을 피하는 비결은 세분성과 서비스 및 구성 요소 간의 전체 결합도에 주의를 기울이는 것입니다.

# 모듈성 정의

메리엄-웹스터(Merriam-Webster) 사전은 *모듈*(Modul)을 "더 복잡한 구조를 만드는 데 사용될 수 있는 일련의 표준화된 부분 또는 독립적인 단위 중 하나"라고 정의합니다. 반면, 이 책에서는 *모듈성*(Modularität)이라는 용어를 객체 지향 언어의 클래스 그룹이나 구조적 또는 함수형 언어의 함수 그룹과 같이 관련된 코드의 논리적 그룹화를 설명하는 데 사용합니다. 일반적으로 개발자들은 모듈을 사용하여 응집성 있는 코드를 그룹화합니다. 예를 들어, Java의 `com.mycompany.customer` 패키지는 고객과 관련된 모든 것을 포함해야 합니다. 대부분의 언어는 모듈성을 위한 메커니즘을 제공합니다(Java의 `package`, .NET의 `namespace` 등).

최신 프로그래밍 언어에는 다양한 패키징 메커니즘이 있으며, 많은 개발자들은 이들 중에서 무엇을 선택해야 할지 어려워합니다. 예를 들어, 많은 최신 언어에서 개발자는 함수/메서드, 클래스 또는 패키지/네임스페이스 내에 동작을 정의할 수 있으며, 이들은 각각 다른 가시성과 스코핑 규칙을 가집니다. 일부 언어는 [메타객체 프로토콜](https://oreil.ly/9Zw-J)과 같은 프로그래밍 구문을 추가하여 더 많은 확장 메커니즘을 제공함으로써 이를 더욱 복잡하게 만듭니다.

아키텍트는 개발자가 어떻게 작업을 패키징하는지 인지해야 합니다. 왜냐하면 패키징이 아키텍처에 중요한 영향을 미치기 때문입니다. 예를 들어, 여러 패키지가 긴밀하게 결합되어 있다면, 그 중 하나를 관련 작업에 재사용하기가 더 어려워집니다.

#### **강의 전 모듈식 재사용**

객체 지향 언어 시대 이전에 교육을 받은 개발자들은 왜 그렇게 다양한 분리 체계가 있는지 궁금해할 것입니다. 그 주된 이유는 코드의 하위 호환성이 아니라 개발자들의 사고방식 때문입니다.

1968년 3월, 컴퓨터 과학자 에츠허르 데이크스트라(Edsger Dijkstra)는 *Communications of the Association for Computing Machinery (ACM)* 저널에 "Go To Statement Considered Harmful(Go To 문은 해롭다)"이라는 제목의 기사를 발표했습니다. 그는 당시 프로그래밍 언어에서 흔히 사용되던 GOTO 문이 코드 내에서 비선형적인 점프를 허용하여 추론과 디버깅을 어렵게 만든다고 비판했습니다.

데이크스트라의 논문은 1970년대 중반 *구조적(structured)* 프로그래밍 언어 시대를 열었습니다. 파스칼(Pascal)과 C가 그 대표적인 예이며, 이들은 요소들이 어떻게 조화를 이루는지에 대한 더 깊은 사고를 장려했습니다. 개발자들은 대부분의 프로그래밍 언어가 유사한 것들을 논리적으로 그룹화하는 좋은 방법을 제공하지 않는다는 것을 빠르게 깨달았습니다. 그리하여 1980년대 중반에는 모듈라(Pascal의 창시자 니클라우스 비르트(Niklaus Wirth)의 다음 언어)와 에이다(Ada)와 같은 *모듈형(modular)* 언어의 짧은 시대가 시작되었습니다. 이 언어들은 오늘날 우리가 패키지나 네임스페이스를 생각하는 방식과 유사한 *모듈*이라는 프로그래밍 구문을 사용했습니다(단, 클래스는 없었습니다).

그러나 1980년대 중반의 모듈형 프로그래밍 시대는 객체 지향 언어가 인기를 얻고 코드 캡슐화 및 재사용을 위한 새로운 방법을 제공하면서 단명했습니다. 그럼에도 불구하고 언어 개발자들은 모듈의 유용성을 인식하고 패키지 및 네임스페이스 형태로 이를 유지했습니다. 많은 언어는 오늘날에는 이상하게 보이지만, 이러한 다양한 패러다임을 지원하기 위해 도입된 호환성 기능을 여전히 포함하고 있습니다. Java 예를 들어, Java는 모듈형 패러다임(패키지 및 정적 초기화자를 통한 패키지 수준 초기화)뿐만 아니라 객체 지향 및 함수형 패러다임을 지원하며, 각각 자체적인 스코핑 규칙과 특성을 가집니다.

이 책의 아키텍처 논의에서 우리는 *모듈성*(Modularität)을 코드의 응집성 있는 그룹화(클래스, 함수 또는 기타 그룹화)를 나타내는 일반적인 용어로 사용합니다. 이는 물리적 분리를 의미하는 것이 아니라 논리적 분리만을 의미합니다. (이 차이는 때때로 중요합니다.) 예를 들어, 모놀리식 애플리케이션에서 많은 수의 클래스를 그룹화하는 것이 실용적일 수 있습니다. 그러나 아키텍처를 재구성해야 할 때가 오면, 느슨한 분할로 인해 발생하는 결합이 모놀리스를 분해하려는 노력을 방해할 수 있습니다. 따라서 특정 플랫폼이 강제하거나 암시하는 물리적 분리와는 별개로, 개념으로서의 모듈성에 대해 이야기하는 것이 타당합니다.

.NET 플랫폼의 기술적 구현과 구별되는 *네임스페이스*(Namensraum)의 일반적인 개념을 논의하는 것이 중요합니다. .NET 플랫폼에서는 이 또한 네임스페이스라고 불립니다. 개발자들은 다양한 소프트웨어 구성 요소(구성 요소, 클래스 등)를 서로 구별하기 위해 종종 정확하고 완전한 정규화된 이름이 필요합니다. 사람들이 매일 사용하는 가장 분명한 예는 IP 주소에 묶인 고유하고 전역적인 식별자에 의존하는 인터넷입니다.

대부분의 언어는 변수, 함수 또는 메서드와 같은 것들을 조직화하는 네임스페이스 역할을 하는 모듈식 메커니즘을 가지고 있습니다. 때때로 모듈 구조는 물리적으로도 매핑됩니다. 예를 들어, Java 패키지 구조는 물리적 클래스 파일의 디렉토리 구조를 반영해야 합니다.

#### **이름 충돌이 없는 언어: JAVA 1.0**

Java의 초기 개발자들은 당시 프로그래밍 플랫폼에서 흔히 발생하던 이름 충돌과 중복을 다루는 데 많은 경험을 가지고 있었습니다. Java 1.0은 두 클래스가 동일한 이름을 가질 때 발생하는 모호성을 피하기 위한 영리한 해킹 방법을 사용했습니다. 예를 들어, 문제 도메인에 *카탈로그 주문*(Katalogbestellung)과 *설치 주문*(Installationsbestellung)이 모두 *Order*라고 불리지만 매우 다른 의미(및 클래스)를 가질 때였습니다. Java 개발자들의 해결책은 `package` 네임스페이스 메커니즘을 생성하고, 물리적 디렉토리 구조가 패키지 이름과 일치해야 한다는 요구사항을 함께 두는 것이었습니다. 파일 시스템은 동일한 디렉토리에 동일한 이름을 가진 두 개의 파일이 존재하도록 허용하지 않으므로, 이는 운영 체제에 내재된 기능을 활용하여 모호성과 이름 충돌을 방지했습니다. 따라서 Java의 초기 `classpath`에는 디렉토리만 포함되었습니다.

그러나 언어 설계자들이 깨달았듯이, 특히 프로젝트가 커지면서 각 프로젝트에 대해 완전한 디렉토리 구조를 만드는 것은 번거로운 일이었습니다. 또한 재사용 가능한 자산을 만드는 것도 어려웠습니다. 프레임워크와 라이브러리는 디렉토리 구조로 "해결"되어야 했습니다. Java의 두 번째 주요 버전(1.2이지만 Java 2로 불림)에서 개발자들은 `jar` 메커니즘을 추가하여 아카이브 파일이 클래스 경로에서 디렉토리 구조 역할을 할 수 있도록 했습니다. 이후 10년 동안 Java 개발자들은 디렉토리와 JAR 파일의 조합으로 클래스 경로를 정확히 구성하는 데 어려움을 겪었습니다.

그들의 원래 의도는 깨졌습니다. 이제 두 개의 JAR 파일이 클래스 경로에서 충돌하는 이름을 생성할 수 있었기 때문입니다. 그래서 이 시기의 Java 개발자들 사이에서는 클래스 로더 디버깅에 대한 수많은 전쟁 이야기가 전해집니다.

# 모듈성 측정

모듈성이 매우 중요하므로, 아키텍트는 이를 더 잘 이해하는 데 도움이 되는 도구가 필요합니다. 다행히 연구자들은 이러한 목적을 위해 언어에 독립적인 여러 메트릭을 개발했습니다. 우리는 여기에서 세 가지 핵심 개념인 *응집도*(Kohäsion), *결합도*(Kopplung), 그리고 *코내선스*(Konnaszenz)에 중점을 둘 것입니다.

# **응집도**

*응집도*(Der Zusammenhalt)는 모듈의 각 부분이 동일한 모듈 내에 포함되어야 하는 정도를 나타냅니다. 즉, 각 부분이 얼마나 밀접하게 연결되어 있는지를 측정합니다. 이상적인 응집성 모듈은 모든 부분이 함께 패키징된 모듈입니다. 만약 이들을 더 작은 부분으로 분해한다면, 의미 있는 결과를 얻기 위해 모듈 간 호출을 통해 연결되어야 할 것입니다. *Structured Design*에 인용된 다음 문구는 응집도에 대한 모듈성의 중요성을 보여줍니다.

*응집성 있는 모듈을 분할하려는 시도는 더 강한 결합과 낮은 가독성만 초래할 뿐이다.*

#### —래리 콘스탄틴

컴퓨터 과학자들은 최상부터 최하까지 측정되는 응집도 영역을 정의했습니다:

#### *기능적 응집도*(Funktionaler Zusammenhalt)

모듈의 모든 부분이 서로 연결되어 있으며, 모듈은 기능하는 데 필요한 모든 것을 포함합니다.

#### *순차적 응집도*(Sequentielle Kohäsion)

두 모듈이 상호 작용합니다. 하나는 다른 모듈의 입력이 되는 데이터를 출력합니다.

# *통신적 응집도*(Kommunikativer Zusammenhalt)

두 모듈이 통신 체인을 형성하여 각 모듈이 정보를 처리하고 특정 출력에 기여합니다. 예를 들어, 한 모듈은 데이터베이스에 레코드를 추가하고 다른 모듈은 이 정보를 기반으로 이메일을 생성합니다.

#### *절차적 응집도*(Verfahrenstechnischer Zusammenhalt)

두 모듈이 특정 순서로 코드를 실행해야 합니다.

#### *시간적 응집도*(Zeitliche Kohäsion)

모듈이 시간적 의존성으로 연결됩니다. 예를 들어, 많은 시스템에는 시스템 시작 시 초기화되어야 하는 겉보기에 관련 없는 항목 목록이 있습니다. 이러한 다양한 작업은 *시간적으로 응집되어 있습니다*.

### *논리적 응집도*(Logischer Zusammenhalt)

모듈 내 데이터는 논리적으로 연결되어 있지만 기능적으로는 연결되어 있지 않습니다. 예를 들어, 텍스트, 직렬화된 객체 또는 스트림의 정보를 다른 형식으로 변환하는 모듈을 고려해 보세요. 작업은 서로 연결되어 있지만 기능은 완전히 다릅니다. 이 종류의 응집도의 일반적인 예는 거의 모든 Java 프로젝트에서 StringUtils 패키지 형태로 발견됩니다. 이는 String과 작동하지만 그 외에는 서로 연결되어 있지 않은 정적 메서드 그룹입니다.

## *우발적 응집도*(Zufälliger Zusammenhalt)

모듈의 요소가 동일한 소스 파일에 있다는 점을 제외하고는 서로 연결되어 있지 않습니다. 이는 응집도의 가장 부정적인 형태입니다.

다양한 형태에도 불구하고, *응집도*는 *결합도*보다 덜 정밀한 메트릭입니다. 종종 특정 모듈의 응집도 수준은 특정 아키텍트의 재량에 따라 결정됩니다. 다음 모듈 정의를 고려해 보세요:

*고객 유지보수*(Customer Maintenance)

- 고객 추가(add customer)
- 고객 업데이트(update customer)
- 고객 가져오기(get customer)
- 고객에게 알림(notify customer)
- 고객 주문 가져오기(get customer orders)
- 고객 주문 취소(cancel customer orders)

마지막 두 항목이 이 모듈에 포함되어야 할까요? 아니면 개발자가 두 개의 별도 모듈을 생성해야 할까요? 다음과 같이 보일 것입니다:

#### *고객 유지보수*(Customer Maintenance)

- 고객 추가(add customer)
- 고객 업데이트(update customer)
- 고객 가져오기(get customer)
- 고객에게 알림(notify customer)

#### *주문 유지보수*(Order Maintenance)

- 고객 주문 가져오기(get customer orders)
- 고객 주문 취소(cancel customer orders)

어떤 것이 올바른 구조일까요? 항상 그렇듯이, 상황에 따라 다릅니다:

- 이들이 주문 유지보수(Order Maintenance)를 위한 유일한 두 가지 작업인가요? 그렇다면 이 작업들을 고객 유지보수(Customer Maintenance)로 다시 그룹화하는 것이 합리적일 수 있습니다.
- 고객 유지보수(Customer Maintenance)가 훨씬 더 커질 것으로 예상되나요? 그렇다면 개발자들은 동작을 다른(또는 새로운) 모듈로 옮길 방법을 찾아야 할 것입니다.
- 주문 유지보수(Order Maintenance)가 고객(Customer)에 대해 너무 많은 지식을 필요로 하여 두 모듈을 분리하면 작동하기 위해 높은 수준의 결합이 필요할까요? (이는 래리 콘스탄틴의 이전 인용문과 관련이 있습니다.)

이러한 질문들은 소프트웨어 아키텍트 작업의 핵심인 절충 분석(Kompromissanalyse)의 유형을 나타냅니다.

컴퓨터 과학자들은 응집도, 더 정확히 말하면 *응집도 부족*(Mangel an Zusammenhalt)을 결정하기 위한 좋은 구조적 메트릭을 개발했습니다(이 특성이 얼마나 주관적인지를 고려하면 다소 놀랍습니다). 잘 알려진 Chidamber와 Kemerer의 [객체 지향](https://oreil.ly/-1lMh) 메트릭 스위트(Object-Oriented Metrics Suite)는 객체 지향 소프트웨어 시스템의 특정 측면을 측정합니다. 여기에는 순환 복잡도(cyclomatic complexity)와 "결합도"에서 논의될 여러 중요한 결합도 메트릭이 포함됩니다.

Chidamber와 Kemerer는 또한 모듈의 구조적 응집도를 측정하는 LCOM(Lack of Cohesion in Methods) 메트릭을 개발했습니다. 첫 번째 버전은 식 3-1에 제시되어 있습니다.

#### 식 3-1. LCOM, 버전 1

$$LCOM = egin{cases} |P| - |Q|, & ext{wenn} \ |P| > |Q| \ 0, & ext{sonst}$$

이 식에서 *P*는 특정 공통 필드에 접근하지 않는 각 메서드에 대해 1씩 증가하고, *Q*는 특정 공통 필드를 사용하는 메서드에 대해 1씩 감소합니다. 이 공식이 혼란스럽다면 이해합니다. 그리고 이는 점차 더 정교해졌습니다. 1996년에 도입된 두 번째 변형(따라서 *LCOM96B*라는 이름)은 식 3-2에서 찾을 수 있습니다.

#### 식 3-2. LCOM96B

$$LCOM96b = rac{1}{a} \sum_{j=1}^{a} rac{m - \mu(Aj)}{m}$$

우리는 식 3-2의 변수와 연산자를 풀이하는 데 시간을 낭비하지 않을 것입니다. 왜냐하면 다음의 서면 설명이 더 명확하기 때문입니다. 기본적으로 LCOM 메트릭은 클래스 내의 우발적 결합을 드러냅니다. LCOM의 더 나은 정의는 "공통 필드를 통해 공유되지 않는 메서드 집합의 합계"일 것입니다.

개인 필드 a와 b를 가진 클래스를 고려해 보세요. 많은 메서드는 a에만 접근하고, 다른 많은 메서드는 b에만 접근합니다. 공통 필드(a와 b)를 통해 공유되지 않는 메서드 집합의 *합계*가 높습니다. 따라서 이 클래스는 높은 LCOM 점수를 받으며, 이는 *메서드의 응집도 부족*이 상당함을 나타냅니다.

식 3-1에 제시된 세 가지 클래스를 고려해 보세요. 여기에서 필드는 팔각형 내의 단일 문자로, 메서드는 블록으로 나타납니다. 클래스 X에서는 LCOM 값이 낮아 좋은 구조적 응집도를 나타냅니다. 그러나 클래스 Y는 응집도가 부족합니다. 클래스 Y의 각 필드/메서드 쌍은 시스템 동작에 영향을 주지 않고 자체 클래스에 나타날 수 있습니다. 클래스 Z는 혼합된 응집도를 보입니다. 마지막 필드/메서드 조합은 자체 클래스로 재구성될 수 있습니다.

식 3-1. 필드는 팔각형, 메서드는 사각형인 LCOM 메트릭

LCOM 메트릭은 아키텍트가 코드베이스를 분석하여 재구성, 마이그레이션 또는 코드베이스 이해에 도움이 될 때 유용합니다. 공유 유틸리티 클래스는 아키텍처 전환 시 종종 골칫거리를 유발합니다. LCOM 메트릭은 아키텍트가 우발적으로 결합되어 처음부터 단일 클래스여서는 안 되었을 클래스를 찾는 데 도움이 될 수 있습니다.

많은 소프트웨어 메트릭에는 심각한 결함이 있으며, LCOM도 예외는 아닙니다. 이 메트릭이 확인할 수 있는 것은 *구조적* 응집도 부족뿐입니다. 특정 부분이 논리적으로 일치하는지 여부를 판단할 방법이 없습니다. 이는 소프트웨어 아키텍처의 두 번째 법칙인 *왜(Why)*가 *어떻게(How)*보다 중요하다는 점으로 이어집니다.

# 결합도

다행히 우리는 코드베이스의 결합도를 분석하기 위한 더 나은 도구를 가지고 있습니다. 이는 부분적으로 그래프 이론에 기반을 둡니다. 메서드 호출과 반환이 호출 그래프를 형성하기 때문에 수학적으로 분석될 수 있습니다. 에드워드 요르돈(Edward Yourdon)과 래리 콘스탄틴(Larry Constantine)의 저서 *Structured Design*: Fundamentals of a Discipline of Computer Program and Systems Design에서는 *afferent coupling*(구심성 결합)과 *efferent coupling*(원심성 결합) 메트릭을 포함한 많은 핵심 개념을 정의합니다. *구심성 결합*은 코드 아티팩트(구성 요소, 클래스, 함수 등)에 대한 *들어오는*(eingehenden) 연결 수를 측정합니다. *원심성 결합*은 다른 코드 아티팩트로의 *나가는*(ausgehenden) 연결을 측정합니다. 사실상 모든 플랫폼에는 아키텍트가 코드의 결합도 특성을 분석하는 데 사용할 수 있는 도구가 있습니다.

#### **왜 결합도 메트릭 이름이 그렇게 비슷한가요?**

서로 *반대되는 개념*을 나타내는 아키텍처 세계의 두 가지 중요한 측정 기준이, 가장 유사하게 들리는 모음만 다를 뿐, 왜 거의 동일한 이름을 가지고 있을까요? 이 용어들은 *Structured Design*이라는 책에서 유래했습니다. 수학의 개념을 빌려 요르돈과 콘스탄틴은 오늘날 흔히 사용되는 *afferent*(구심성) 및 *efferent*(원심성) 결합이라는 용어를 만들었습니다. 사실 이들은 *들어오는*(eingehende) 결합과 *나가는*(ausgehende) 결합이라고 불렸어야 하지만, 저자들은 명확성보다는 수학적 대칭성에 더 중점을 두었습니다. 개발자들은 이를 단순화하기 위해 다양한 기억 방법을 고안했습니다. 예를 들어, 영어 알파벳에서 *a*가 *e*보다 먼저 나오듯이, *incoming*(들어오는)이 *outgoing*(나가는)보다 먼저 옵니다. *efferent*의 *e*는 *exit*(나가다)의 첫 글자와 일치하여, 나가는 연결을 의미한다는 것을 기억하는 데 도움이 됩니다.

# **핵심 메트릭**

구성 요소 결합도는 아키텍트에게 즉각적인 가치가 있지만, 몇 가지 다른 파생 메트릭은 더 심층적인 평가를 가능하게 합니다. 이 섹션에서 제시된 측정 기준은 [소프트웨어 개발자](https://oreil.ly/QxmzC) 로버트 C. 마틴(Robert C. Martin)이 개발했으며 대부분의 객체 지향 언어에 적용될 수 있습니다.

*추상성*(Abstraktheit)은 추상 아티팩트(추상 클래스, 인터페이스 등)와 구체 아티팩트(구현)의 비율입니다. 추상성 측정은 구현과 비교하여 코드베이스의 추상성 정도를 측정합니다. 예를 들어, 스케일의 한쪽 끝에는 추상화가 전혀 없고 하나의 큰 함수(예: `main()` 메서드 하나)만 포함하는 코드베이스가 있습니다. 스케일의 다른 쪽 끝에는 너무 많은 추상화가 있어 개발자가 요소들의 관계를 이해하기 어렵게 만드는 코드베이스가 있을 것입니다. (예를 들어, 개발자는 `AbstractSingletonProxyFactoryBean`이라는 추상 클래스가 많은 추상화 계층과 모호한 이름을 가지고 있기 때문에, 이 클래스를 가지고 무엇을 해야 할지 알아내는 데 시간이 걸립니다.)

추상성 공식은 식 3-3에서 찾을 수 있습니다.

### 식 3-3. 추상성

$$A = rac{\sum m^a}{\sum m^c + \sum m^a}$$

아키텍트는 추상 아티팩트의 합계와 구체 아티팩트 및 추상 아티팩트의 합계 비율을 계산하여 추상성을 계산합니다. 식에서 $m^a$는 모듈의 *추상* 요소(인터페이스 또는 추상 클래스)를, $m^c$는 *구체* 요소(비추상 클래스)를 나타냅니다. 이 메트릭은 동일한 기준을 찾습니다. 이 메트릭을 가장 쉽게 설명하는 방법은 `main()` 메서드에 모두 포함된 5,000줄의 코드 애플리케이션을 상상하는 것입니다.

추상성의 분자는 1이 되고 분모는 5,000이 되어 추상성 값이 거의 0이 됩니다. 이 측정 기준은 코드에서 추상화의 비율을 측정합니다.

또 다른 파생 메트릭인 *불안정성*(Instabilität)은 식 3-4에 제시된 바와 같이 원심성 결합(efferent coupling)과 원심성 결합 및 구심성 결합(afferent coupling)의 합계의 비율로 정의됩니다.

## 식 3-4. 불안정성

$$I = \frac{C^e}{C^e + C^a}$$

식에서 $C^e$는 원심성(또는 나가는) 결합을, $C^a$는 구심성(또는 들어오는) 결합을 나타냅니다.

"불안정성" 메트릭은 코드베이스의 *변동성*(Volatilität)을 결정합니다. 불안정성 정도가 높은 코드베이스는 강력한 결합으로 인해 변경될 경우 더 쉽게 붕괴됩니다. 예를 들어, 작업을 위임하기 위해 너무 많은 다른 클래스를 호출하는 클래스는 호출된 메서드 중 하나 이상이 변경될 경우 붕괴되기 매우 쉽습니다.

# 주 계열로부터의 거리

아키텍트가 아키텍처 구조를 위해 사용할 수 있는 몇 안 되는 전체론적 메트릭 중 하나는 *주 계열로부터의 거리*(Distanz zur Hauptreihenfolge)입니다. 이는 불안정성과 추상성에 기반한 파생 메트릭이며, 식 3-5에 제시되어 있습니다.

#### 식 3-5. 주 계열로부터의 거리

$$D = |A + I - 1|$$

식에서 A = 추상성(Abstraktheit) 및 I = 불안정성(Instabilität)입니다.

추상성과 불안정성 모두 0과 1 사이의 결과를 가지는 분수라는 점에 유의하세요(일부 극단적인 경우 제외). 관계를 그래프로 표현하면 식 3-2의 다이어그램을 얻을 수 있습니다.

식 3-2. 주 계열은 추상성과 불안정성 사이의 이상적인 관계를 정의합니다.

*거리 메트릭*(Abstandsmetrik)은 추상성과 불안정성 사이의 이상적인 관계를 상정합니다. 이 이상적인 선 근처에 있는 클래스는 이 두 가지 상반되는 관심사의 건전한 혼합을 보여줍니다. 예를 들어, 특정 클래스를 그래프로 표현하면 *주 계열로부터의 거리*를 계산할 수 있습니다(식 3-3 참조).

식 3-3. 특정 클래스에 대한 주 계열로부터의 정규화된 거리

식 3-3의 메트릭은 후보 클래스를 그래픽으로 나타낸 다음 이상화된 선으로부터의 거리를 측정합니다. 선에 가까울수록 클래스가 더 균형 잡혀 있습니다. 너무 오른쪽 상단 모서리에 치우친 클래스는 아키텍트가 " *무용지대*(Zone der Nutzlosigkeit)"라고 부르는 곳에 빠집니다. 즉, 너무 추상적인 코드는 사용하기 어렵습니다. 반대로, 식 3-4에 제시된 바와 같이 왼쪽 하단 모서리에 치우친 코드는 *고통 지대*(Zone des Schmerzes)에 빠집니다. 즉, 구현이 너무 많고 추상화가 너무 적은 코드는 취약하고 유지보수하기 어렵습니다.

식 3-4. 무용지대와 고통 지대

많은 플랫폼은 이러한 측정값을 계산하는 도구를 제공하며, 이는 아키텍트가 코드베이스를 분석하여 익숙해지거나, 마이그레이션을 준비하거나, 기술 부채를 평가하는 데 도움이 됩니다.

#### **메트릭의 한계**

업계에는 귀중한 통찰력을 제공하는 일부 코드 수준 메트릭이 있지만, 다른 기술 분야의 분석 도구에 비하면 우리의 도구는 극도로 무딥니다. 코드 구조에서 직접 파생된 메트릭조차도 해석이 필요합니다. 예를 들어, 순환 복잡도(cyclomatic complexity)는 코드베이스의 복잡도를 측정하지만, 이 메트릭은 *필수적* 복잡도(코드가 기본 문제가 복잡하기 때문에 복잡함)와 *우발적 복잡도*(코드가 실제보다 더 복잡함)를 구별할 수 없습니다. 사실상 모든 코드 수준 메트릭은 해석이 필요하지만, 아키텍트가 코드베이스의 유형을 평가할 수 있도록 순환 복잡도와 같은 중요 메트릭에 대한 기준값을 설정하는 것은 여전히 유용합니다. 우리는 "거버넌스 및 적합성 함수"에서 이러한 테스트 설정에 대해 논의합니다.

1979년에 출판된 요르돈과 콘스탄틴의 저서 *Structured Design*은 객체 지향 언어가 인기를 얻기 전의 것입니다. 이 책은 대신 함수(메서드가 아님)와 같은 구조화된 프로그래밍 구문에 초점을 맞춥니다. 또한 현대 프로그래밍 언어의 설계로 인해 구식화된 다른 유형의 결합도를 정의합니다. 객체 지향 프로그래밍과 함께, 구심성 및 원심성 결합에 더해 결합도를 설명하기 위한 세련된 어휘인 *코내선스*(Konnaskenz)를 포함한 추가 개념이 도입되었습니다.

# **코내선스**

메일리르 페이지-존스(Meilir Page-Jones)의 저서 *What Every Programmer Should Know about Object-Oriented Design*은 객체 지향 언어에서 다양한 유형의 결합도를 설명하기 위한 보다 정밀한 *언어*를 개발했습니다. 코내선스는 구심성 및 원심성 결합과 같은 결합도 메트릭이 아니라, 아키텍트가 다양한 유형의 결합도를 더 정확하게 설명하고(또한 결합 유형의 몇 가지 일반적인 결과를 이해하는 데) 도움이 되는 언어입니다.

두 구성 요소는 한 구성 요소의 변경이 시스템의 전체적인 정확성을 보장하기 위해 다른 구성 요소의 변경을 필요로 할 때 *상호 연결*(miteinander verbunden)됩니다. 페이지-존스는 두 가지 유형의 코내선스를 구별합니다: *정적*(statisch) 코내선스와 *동적*(dynamisch) 코내선스.

## **정적 코내선스**

*정적 결합*(Statische Kopplung)은 소스 코드 수준의 결합을 의미합니다(런타임 시 결합과는 대조적이며, 이는 "동적 결합"에서 다룹니다). 아키텍트는 정적 결합을 구심성 또는 원심성 결합을 통해 어떤 것이 결합되는 *정도*(Grad)로 간주합니다. 정적 결합에는 여러 유형이 있습니다:

### *이름 일치*(Namensgleichheit)

여러 구성 요소가 엔티티의 이름에 대해 동의해야 합니다.

메서드 이름과 메서드 매개변수는 코드베이스가 결합되는 가장 흔한 방식이며, 현대적인 리팩토링 도구를 통해 시스템 전반의 이름 변경을 사소하게 구현할 수 있다는 점을 고려할 때 가장 바람직한 방식입니다. 예를 들어, 개발자는 더 이상 활성 코드베이스에서 메서드 이름을 변경하지 않고, 현대적인 도구를 사용하여 메서드 이름을 *리팩토링*하여 코드베이스 전체에 변경 사항이 적용되도록 합니다.

# *유형 일치*(Übereinstimmung der Typen)

여러 구성 요소가 엔티티의 유형에 대해 동의해야 합니다.

이러한 유형의 연결은 많은 정적 타입 언어에서 흔히 볼 수 있는 변수와 매개변수를 특정 유형으로 제한하는 경향과 관련이 있습니다. 그러나 이러한 가능성은 정적 타입 언어에만 있는 것이 아닙니다. 일부 동적 타입 언어도 선택적 타입 지정을 제공합니다. 특히 [Clojure](https://clojure.org/)와 [Clojure Spec](https://clojure.org/about/spec)가 그러합니다.

#### *의미의 코내선스*(Connascence of Meaning)

여러 구성 요소가 특정 값의 의미에 대해 동의해야 합니다. 이는 *관습의 코내선스*(Connascence of Convention)라고도 불립니다.

코드베이스에서 이러한 유형의 코내선스가 가장 분명하게 나타나는 일반적인 경우는 상수 대신 하드코딩된 숫자입니다. 예를 들어, 일부 언어에서는 `int TRUE = 1; int FALSE = 0;`과 같이 어딘가에 정의하는 것이 일반적입니다. 누군가 이 값들을 뒤집으면 발생할 문제들을 상상해 보세요.

#### *위치 일치*(Zusammenführung der Positionen)

여러 구성 요소가 값의 순서에 대해 동의해야 합니다.

이는 정적 타입 언어에서도 메서드 및 함수 호출의 매개변수 값에서 발생하는 문제입니다. 예를 들어, 개발자가 `void updateSeat(String name, String seatLocation)` 메서드를 생성하고 `updateSeat("14D", "Ford, N")` 값으로 호출하면, 유형은 올바르지만 의미론적으로는 올바르지 않습니다.

#### *알고리즘의 코내선스*(Konkaskade des Algorithmus)

여러 구성 요소가 특정 알고리즘에 대해 동의해야 합니다.

*알고리즘의 결합*(Kopplung von Algorithmen)에 대한 흔한 경우는 개발자가 보안 해시 알고리즘을 정의하는데, 이 알고리즘은 사용자를 인증하기 위해 서버와 클라이언트 모두에서 실행되어야 하며 동일한 결과를 제공해야 할 때입니다. 이는 물론, 두 알고리즘 중 하나의 세부 사항이 변경되면 핸드셰이크가 더 이상 작동하지 않으므로 높은 수준의 결합을 의미합니다.

# **동적 코내선스**

페이지-존스가 정의한 다른 유형의 연결은 *동적 연결*(dynamische Verknüpfung)인데, 이는 런타임 시 호출을 분석하는 방식입니다. 동적 코내선스의 유형에는 다음이 포함됩니다:

# *실행 순서의 코내선스*(Vollzugskonsequenz)

여러 구성 요소의 실행 순서가 중요합니다.

## 다음 코드를 고려해 보세요:

```
email = new Email();
email.setRecipient("foo@example.com");
email.setSender("me@me.com");
email.send();
email.setSubject("whoops");
```

특정 속성이 특정 순서로 설정되어야 하므로 올바르게 작동하지 않을 것입니다.

### *시간적 코내선스*(Zeitliche Konstellation)

여러 구성 요소의 실행 타이밍이 중요합니다.

이러한 유형의 충돌에서 가장 흔한 경우는 두 개의 스레드가 동시에 실행되어 공유 작업의 결과에 영향을 미치는 경쟁 조건(Race Condition)입니다.

#### *값의 코내선스*(Wertekongruenz)

여러 값이 서로 의존하며 함께 변경되어야 합니다.

개발자가 네 개의 점을 정의하여 사각형을 만들었다고 가정해 봅시다. 데이터 구조의 무결성을 유지하기 위해 개발자는 사각형의 형태를 유지하도록 다른 점들에 대한 영향을 고려하지 않고 임의로 한 점을 변경할 수 없습니다.

흔하고 문제가 되는 경우는 트랜잭션이며, 특히 분산 시스템에서 그렇습니다. 별도의 데이터베이스를 가진 시스템에서 누군가가 모든 데이터베이스의 단일 값을 업데이트해야 하는 경우, 해당 값들은 모두 함께 변경되거나 전혀 변경되지 않아야 합니다.

### *식별의 코내선스*(Identitätskonflikt)

여러 구성 요소가 동일한 엔티티를 참조해야 합니다.

*식별의 코내선스*(Connascence of Identity)의 일반적인 예는 공통 데이터 구조를 공유하고 업데이트해야 하는 두 개의 독립적인 구성 요소(예: 분산 큐)입니다.

# **코내선스 속성**

코내선스(Connascence)는 아키텍트와 개발자를 위한 분석 프레임워크이며, 그 속성 중 일부는 우리가 이를 현명하게 사용하도록 돕습니다. 코내선스의 이러한 속성은 다음과 같습니다:

## *강도*(Stärke)

아키텍트는 개발자가 결합을 수정할 수 있는 용이성을 기반으로 시스템 연결의 *강도*(Stärke)를 결정합니다. 일부 결합 유형은 식 3-5에 제시된 것처럼 다른 유형보다 분명히 더 바람직합니다. 더 나은 연결 유형으로 리팩토링함으로써 코드베이스의 결합 특성을 개선할 수 있습니다.

아키텍트는 동적 코내선스보다 정적 코내선스를 선호해야 합니다. 왜냐하면 개발자가 간단한 소스 코드 분석을 통해 이를 결정할 수 있고, 현대적인 도구로 정적 코내선스를 개선하는 것이 사소한 일이기 때문입니다. 예를 들어, *의미 연결성*(Bedeutungskonnektivität)은 마법의 값 대신 명명된 상수를 생성함으로써 *이름 연결성*(Namenskonnektivität)으로 리팩토링하여 개선될 수 있습니다.

식 3-5. *코내선스 강도*는 좋은 리팩토링 가이드가 될 수 있습니다.

#### *지역성*(Ortschaft)

시스템 연결의 *지역성*(Lokalität)은 코드베이스 내 모듈이 서로 얼마나 가까이 있는지를 측정합니다. *가까이 있는 코드*(동일 모듈 내 코드)는 일반적으로 멀리 떨어진 코드(별도의 모듈 또는 코드베이스)보다 더 많고 강한 형태의 연결을 보입니다. 다시 말해, 구성 요소가 멀리 떨어져 있을 때 나쁜 결합을 나타낼 수 있는 연결 형태도 구성 요소가 더 가까이 있을 때는 괜찮습니다. 예를 들어, 동일 모듈 내 두 클래스가 *의미의 코내선스*(Connascence of Meaning)를 가지고 있다면, 이 클래스들이 다른 모듈에 있는 것보다 코드베이스에 덜 해롭습니다.

저자가 이 관찰을 처음 발표했을 때, 아키텍트들은 이 발견의 중요성을 대부분 인식하지 못했습니다. 오늘날의 관점에서 그는 아키텍트가 구현 세부 사항(높은 결합)의 범위를 가능한 한 엄격하게 제한해야 한다고 제안합니다. 이는 도메인 주도 설계(DDD)의 개념인 제한된 컨텍스트(bounded context)에서 파생된 것과 동일한 조언입니다. 아키텍처적 관찰은 동일합니다. 즉, 구현의 결합을 제한하는 것입니다. 메일리르 페이지는 DDD를 통해 다시 도입된 좋은 설계 원칙("도메인 주도 설계의 제한된 컨텍스트" in 7장 참조)을 설명했습니다.

강도와 지역성을 함께 고려하는 것이 좋습니다. 동일 모듈 내의 더 강한 연결 형태는 다른 위치에서의 동일한 연결보다 "코드 스멜"을 덜 유발합니다.

*결합 정도*(Grad der Verflechtung)는 특정 모듈 내 클래스 변경의 영향 규모를 나타냅니다. 즉, 변경이 소수의 클래스에 영향을 미치는지 아니면 많은 클래스에 영향을 미치는지에 관한 것입니다. 낮은 정도의 코내선스는 다른 클래스 및 모듈에 대한 변경을 덜 요구하므로 코드베이스에 덜 손상을 줍니다. 다시 말해, 아키텍트가 몇 개의 모듈만 가지고 있다면 높은 정도의 동적 연결도 나쁘지 않습니다. 그러나 코드베이스는 성장하는 경향이 있으며, 이로 인해 변경과 관련된 작은 문제가 비례적으로 더 커집니다.

*What Every Programmer Should Know about Object-Oriented Design*에서 페이지-존스는 시스템 모듈성을 개선하기 위해 코내선스를 사용하는 세 가지 지침을 제공합니다:

- 시스템을 캡슐화된 요소로 분할하여 전체적인 응집도를 최소화합니다.
- 캡슐화 경계를 넘는 모든 남은 연결을 최소화합니다.
- 캡슐화 경계 내에서 코내선스를 최대화합니다.

코내선스 개념을 다시 대중화한 전설적인 소프트웨어 아키텍처 혁신가 짐 웨이리히(Jim [Weirich](https://oreil.ly/LpE7_))는 2012년 Emerging Technologies for the Enterprise 컨퍼런스에서의 강연 ["Connescence](https://oreil.ly/q7NxU) Examined"에서 두 가지 훌륭한 규칙을 제시합니다:

*정도 규칙: 강한 형태의 응집도를 약한 형태의 응집도로 변환하라.*

*지역성 규칙: 소프트웨어 요소 간 거리가 멀수록, 연결 형태는 약해져야 한다.*

아키텍트는 디자인 패턴에 대해 배우는 것이 유리한 것과 같은 이유로 코내선스에 대한 지식으로부터 이점을 얻습니다. 코내선스는 다양한 유형의 결합도를 설명하기 위한 보다 정밀한 언어를 제공합니다. 예를 들어, 아키텍트는 "하나의 인스턴스만 허용되는 서비스가 필요하다"고 말할 수도 있고, "싱글톤 서비스가 필요하다"고 말할 수도 있습니다. 싱글톤 디자인 패턴은 공통 문제에 대한 컨텍스트와 해결책을 단순한 이름으로 캡슐화합니다.

마찬가지로, 아키텍트가 코드 검토 시 개발자에게 "메서드 선언 중간에 마법의 문자열 상수를 삽입하지 마세요. 대신 상수로 추출하세요"라고 지시할 수 있습니다. 또는 "당신은 *의미 상수*(Bedeutungskonstante)를 가지고 있습니다. 이를 *이름 상수*(Namenskonstante)로 리팩토링하세요"라고 말할 수도 있습니다.

# 모듈에서 컴포넌트로

우리는 이 책에서 *모듈*(Modul)이라는 용어를 응집성 있는 코드 묶음을 나타내는 일반적인 용어로 사용합니다. 그러나 대부분의 아키텍트는 모듈을 소프트웨어 아키텍처의 가장 중요한 빌딩 블록인 *컴포넌트*(Komponenten)라고 부릅니다. *컴포넌트* 개념과 그에 따른 논리적 또는 물리적 분리에 대한 분석은 컴퓨터 과학의 초기부터 존재했지만, 개발자와 아키텍트는 여전히 좋은 결과를 얻기 위해 고군분투하고 있습니다.

8장에서는 문제 도메인으로부터 컴포넌트를 도출하는 방법을 다룰 것이지만, 먼저 소프트웨어 아키텍처의 또 다른 근본적인 측면인 아키텍처 특성과 그 범위를 논의해야 합니다.
