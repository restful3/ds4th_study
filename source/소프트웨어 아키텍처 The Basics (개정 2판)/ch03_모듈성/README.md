# ch03 모듈성

## 요약

이 문서는 소프트웨어 아키텍처의 핵심 개념인 **모듈성(Modularity)** 을 심층적으로 분석합니다. 모듈성은 관련 코드를 논리적으로 그룹화하여 지속 가능한 코드베이스를 만드는 암묵적 아키텍처 특성으로, 시스템을 분해하는 행위 그 자체와 각 부분의 크기를 결정하는 **세분성(Granularity)** 을 명확히 구분해야 합니다. 잘못된 세분성은 분산 모노리스 같은 복잡한 아키텍처 문제를 야기할 수 있습니다.

아키텍트는 모듈성을 객관적으로 측정하고 개선하기 위해 여러 메트릭을 활용해야 합니다. 주요 개념은 다음과 같습니다.

1. **응집도(Cohesion)**: 한 모듈의 구성 요소들이 얼마나 긴밀하게 연관되어 있는지를 측정합니다. 기능적 응집도가 가장 이상적이며, 우연적 응집도가 가장 좋지 않습니다. 메서드 응집도 부족(**LCOM**) 메트릭은 구조적 응집도를 평가하는 데 사용됩니다.
2. **결합도(Coupling)**: 모듈 간 의존성을 측정합니다. 유입(**Ca**)·유출(**Ce**) 결합도를 기반으로 **추상도(Abstractness)**, **불안정도(Instability)**, 주계열과의 거리(**Distance from the Main Sequence**) 같은 파생 메트릭을 계산하여 코드베이스의 건강도를 평가할 수 있습니다.
3. **커넥센스(Connascence)**: 결합도를 더 정밀하게 설명하기 위한 어휘 체계입니다. 정적(이름, 타입 등)과 동적(실행, 타이밍 등) 커넥센스로 분류하며, 리팩터링을 통해 더 약하고 바람직한 형태로 발전시키는 것을 목표로 합니다.

이러한 개념과 메트릭은 아키텍트가 시스템의 구조적 안정성을 유지하고, 코드베이스를 분석하며, 기술 부채를 평가하고, 성공적인 리팩터링과 마이그레이션을 계획하는 데 필수적인 도구를 제공합니다.

![모듈성 인포그래픽](unnamed.png)


---


## 모듈성의 개념과 중요성

소프트웨어 아키텍처 분야에서 **모듈성** 은 오랫동안 핵심 주제로 논의되어 왔습니다. 1978년 글렌포드 J. 마이어스는 대부분의 문헌이 모듈성의 장점만 강조하고 이를 달성하는 방법은 거의 다루지 않는다고 지적했습니다. 모듈성은 특정 플랫폼의 재사용 메커니즘과 무관하게 관련 코드를 모듈 단위로 논리적으로 그룹화하는 것을 의미하며, 통일된 정의가 부족한 만큼 아키텍트가 스스로 명확한 정의를 수립해야 합니다.

아키텍트에게 모듈성은 질서를 부여하는 원리입니다. 소프트웨어 시스템은 복잡계처럼 엔트로피가 증가하는 경향이 있으며, 물리 시스템에서 질서를 유지하기 위해 에너지가 필요하듯 아키텍처에서도 구조적 안정성을 유지하기 위한 지속적인 노력이 필요합니다. 좋은 모듈성은 요구사항에 직접 등장하지 않지만, 지속 가능한 코드베이스의 전제 조건입니다.

## 모듈성 대 세분성

개발자와 아키텍트는 종종 **모듈성(Modularity)** 과 **세분성(Granularity)** 을 혼용하지만, 두 용어는 명확히 구분해야 합니다.

- 모듈성: 시스템을 더 작은 부분으로 분해하는 행위 자체입니다. 예를 들어 모놀리식 아키텍처를 마이크로서비스로 전환하는 결정이 해당됩니다.
- 세분성: 분해된 각 부분의 크기를 결정하는 문제입니다. 특정 서비스나 컴포넌트가 얼마나 커야 하는지에 대한 판단을 의미합니다.

마크 리처즈는 "**모듈성을 수용하되, 세분성은 경계하라**"라고 조언했습니다. 잘못된 세분성은 서비스나 컴포넌트 간 과도한 결합을 유발하여 스파게티 아키텍처, 분산 모노리스, 분산된 진흙 덩어리(**Big Ball of Distributed Mud**)와 같은 유지보수 난제를 초래할 수 있습니다. 따라서 세분성과 전체 결합 수준을 함께 고려해야 합니다.

## 모듈성의 정의 및 역사적 발전

이 문서에서 모듈성은 객체 지향 언어의 클래스 그룹이나 구조적 언어의 함수 그룹처럼 관련된 코드를 논리적으로 묶는 일반적인 용어로 사용됩니다. 이는 물리적 분리가 아닌 논리적 그룹화를 의미합니다.

### 모듈성 개념의 진화

현대의 다양한 모듈화 메커니즘은 개발자 사고방식의 하위 호환성을 유지하며 발전해 왔습니다.

1. **구조적 프로그래밍 시대 (1970년대 중반)**: 에츠허르 다익스트라가 "Go To 문의 유해성"을 발표한 이후 파스칼과 C 같은 구조적 언어가 등장했습니다. 이 언어들은 코드 구조에 대한 고찰을 촉진했지만, 유사한 기능을 논리적으로 묶는 효과적인 수단은 제공하지 못했습니다.
2. **모듈러 언어 시대 (1980년대 중반)**: 니클라우스 비르트의 모듈라(Modula)와 에이다(Ada)가 등장하며 오늘날 패키지/네임스페이스와 유사한 '모듈' 구조가 도입되었습니다.
3. **객체 지향 프로그래밍 시대**: 객체 지향 언어가 새로운 캡슐화·재사용 기법을 제공하면서 모듈러 프로그래밍 시대는 짧게 막을 내렸지만, 언어 설계자들은 모듈의 유용성을 인식해 Java의 패키지, .NET의 네임스페이스 형태로 개념을 유지했습니다.

### 네임스페이스와 이름 충돌 방지

대부분의 언어는 변수와 함수를 조직화하기 위해 네임스페이스 역할의 모듈화 메커니즘을 제공합니다. Java 1.0 설계자들은 `package`라는 네임스페이스와 물리적 디렉터리 구조를 일치시키는 규칙을 도입해 클래스 이름 충돌을 예방했습니다. 그러나 프로젝트 규모가 커지면서 완전한 디렉터리 구조를 만드는 일이 번거로워졌고, Java 1.2에서 여러 클래스를 묶는 `jar` 메커니즘을 추가했습니다. 그 결과 서로 다른 jar 파일이 동일한 클래스 이름을 포함하면서 클래스로더 충돌이 빈번해졌습니다.

## 모듈성 측정

모듈성의 중요성 때문에 아키텍트는 이를 분석할 도구가 필요합니다. 언어에 독립적인 세 가지 핵심 개념인 응집도, 결합도, 커넥센스를 중심으로 살펴보겠습니다.

### 응집도 (Cohesion)

**응집도** 는 한 모듈 내 구성 요소들이 얼마나 긴밀하게 연결되어 있는지를 나타냅니다. 이상적인 응집도를 가진 모듈은 모든 부분이 함께 패키징되어야 하며, 더 작게 분해하면 모듈 간 호출이 증가해 비효율적입니다. 래리 콘스탄틴은 "**응집력 있는 모듈을 분할하려는 시도는 결합도를 높이고 가독성을 떨어뜨릴 뿐**"이라고 강조했습니다.

| 응집도 유형 | 설명 |
| --- | --- |
| 기능적(Functional) | 모듈의 모든 부분이 서로 연관되어 있으며 기능 수행에 필요한 모든 것을 포함함 (가장 이상적). |
| 순차적(Sequential) | 한 모듈의 출력이 다른 모듈의 입력이 되는 방식으로 상호작용함. |
| 교환적(Communicational) | 두 모듈이 통신 체인을 형성하여 각각 정보를 처리하고 특정 결과물에 기여함. |
| 절차적(Procedural) | 두 모듈이 특정 순서에 따라 코드를 실행해야 함. |
| 시간적(Temporal) | 시스템 시작 시 초기화되어야 하는 작업처럼 시간적 의존성으로 묶여 있음. |
| 논리적(Logical) | 모듈 내 데이터가 기능적으로는 무관하지만 논리적으로 관련되어 있음 (예: `StringUtils`). |
| 우연적(Coincidental) | 모듈 요소들이 같은 파일에 있다는 것 외에는 아무런 관련이 없음 (가장 부정적). |

응집도 평가는 주관적인 경우가 많습니다. 예를 들어 Customer Maintenance 모듈에 주문 관련 기능을 포함할지, 별도의 Order Maintenance 모듈로 분리할지는 기능 수, 확장성, 필요한 정보량(결합도) 등을 고려한 트레이드오프 분석을 거쳐야 합니다.

### 메서드 응집도 부족 (LCOM)

**LCOM(Lack of Cohesion in Methods)** 은 클래스 내 구조적 응집도를 수치화하는 메트릭입니다. LCOM 점수가 높을수록 공유 필드를 통해 연결되지 않은 메서드 집합이 많다는 뜻이며, 메서드 간 응집도가 낮음을 의미합니다.

- 클래스 X: 필드 A, B, C가 메서드 m1, m2, m3와 복잡하게 연결되어 있어 LCOM이 낮고 구조적 응집도가 높습니다.
- 클래스 Y: 각 필드가 하나의 메서드와만 연결되어 LCOM이 높고 응집도가 매우 낮으며, 각 필드/메서드 쌍을 별도 클래스로 분리할 수 있습니다.
- 클래스 Z: 일부는 연결되어 있고 일부는 독립적이라 혼합된 응집도를 보이며, 부분적으로 리팩터링 대상일 수 있습니다.

LCOM은 우연히 결합된 클래스를 식별해 리팩터링·마이그레이션 시 우선순위를 정하는 데 유용하지만, 논리적 연관성은 판단하지 못한다는 한계가 있습니다.

### 결합도 (Coupling)

**결합도** 는 코드베이스 내 의존성을 분석하는 도구입니다. 유어돈과 콘스탄틴은 다음 두 메트릭을 제시했습니다.

- **유입 결합도(Afferent Coupling, Ca)**: 특정 코드 아티팩트로 들어오는 연결 수.
- **유출 결합도(Efferent Coupling, Ce)**: 다른 코드 아티팩트로 나가는 연결 수.

#### 핵심 메트릭

로버트 C. 마틴은 결합도를 기반으로 다음과 같은 파생 메트릭을 정의했습니다.

1. **추상도(Abstractness, A)**: 추상 요소와 구체적 요소의 비율을 측정합니다. `A = Σm_a / (Σm_c + Σm_a)`이며, 0이면 지나치게 구체적이고 1이면 과도하게 추상적입니다.
2. **불안정도(Instability, I)**: 변경 용이성을 측정합니다. `I = Ce / (Ce + Ca)`이며, 0이면 매우 안정적이고 1이면 매우 불안정합니다.
3. **주계열과의 거리(Distance from the Main Sequence, D)**: 이상적인 결합 상태와의 편차를 측정합니다. `D = |A + I - 1|`이며, 0에 가까울수록 추상도와 불안정도가 균형을 이룹니다.

이 메트릭은 그림 3-3(추상도-불안정도 다이어그램)에 표시할 수 있으며, 0에 가까울수록 이상적인 클래스를 의미합니다.

**그림 3-4: 고통의 영역과 쓸모없는 영역**

- **고통의 영역(Zone of Pain)**: 추상도가 낮고 안정적이어서 변경이 매우 어렵고 취약한 코드.
- **쓸모없는 영역(Zone of Uselessness)**: 추상도가 높고 불안정하여 실제 활용이 어려운 코드.

이 메트릭은 기술 부채를 평가하는 데 유용하지만, 필수적 복잡성과 우연적 복잡성을 구분하지 못하므로 해석에 주의가 필요합니다.

### 커넥센스 (Connascence)

**커넥센스**는 메일리어 페이지-존스가 객체 지향 언어의 결합도를 정밀하게 설명하기 위해 만든 어휘 체계입니다. 한 컴포넌트를 변경하면 시스템 정확성을 위해 다른 컴포넌트도 변경해야 하는 관계를 커넥센스 관계라고 합니다.

#### 정적 커넥센스 (Static Connascence)

소스 코드 수준에서 분석 가능한 결합입니다.

| 유형 | 설명 |
| --- | --- |
| 이름(Name) | 여러 컴포넌트가 한 엔티티의 이름에 동의해야 함 (가장 흔하고 바람직함). |
| 타입(Type) | 여러 컴포넌트가 한 엔티티의 타입에 동의해야 함 (정적 타입 언어에서 흔함). |
| 의미(Meaning) | 여러 컴포넌트가 특정 값의 의미에 동의해야 함 (예: `TRUE = 1`). |
| 위치(Position) | 여러 컴포넌트가 값의 순서에 동의해야 함 (예: 메서드 파라미터 순서). |
| 알고리즘(Algorithm) | 여러 컴포넌트가 특정 알고리즘에 동의해야 함 (예: 보안 해시 알고리즘). |

#### 동적 커넥센스 (Dynamic Connascence)

런타임에 발생하는 결합입니다.

| 유형 | 설명 |
| --- | --- |
| 실행(Execution) | 여러 컴포넌트의 실행 순서가 중요함. |
| 타이밍(Timing) | 여러 컴포넌트의 실행 시점이 중요함 (예: 경합 조건). |
| 값(Value) | 여러 값이 서로 의존하여 함께 변경되어야 함 (예: 분산 트랜잭션). |
| 식별자(Identity) | 여러 컴포넌트가 동일한 엔티티를 참조해야 함 (예: 분산 큐). |

### 커넥센스 속성과 활용

커넥센스는 다음 속성을 통해 시스템 분석과 개선에 활용됩니다.

- **강도(Strength)**: 결합을 리팩터링하기 얼마나 쉬운지를 나타냅니다. 정적 커넥센스가 동적 커넥센스보다 약하고 바람직하며, 강한 형태를 약한 형태로 전환하는 것이 목표입니다.
- **지역성(Locality)**: 모듈들이 코드베이스에서 얼마나 가까이 있는지를 측정합니다. 동일 모듈 내에서는 강한 형태가 허용될 수 있으며, 이는 DDD의 제한된 컨텍스트 개념과도 맞닿아 있습니다.
- **정도(Degree)**: 결합의 파급 범위를 나타냅니다. 영향을 받는 클래스가 적을수록 변경 위험이 낮습니다.

### 커넥센스 활용 지침

1. 페이지-존스의 세 가지 지침
   - 시스템을 캡슐화된 요소로 분할하여 전체 커넥센스를 최소화하라.
   - 캡슐화 경계를 넘는 커넥센스를 최소화하라.
   - 캡슐화 경계 내 커넥센스를 최대화하라.
2. 짐 웨이릭(Jim Weirich)의 두 가지 규칙
   - **정도의 규칙**: 강한 형태의 커넥센스를 약한 형태로 전환하라.
   - **지역성의 규칙**: 소프트웨어 요소 간 거리가 멀수록 더 약한 형태의 커넥센스를 사용하라.

커넥센스는 디자인 패턴처럼 아키텍트가 결합의 종류를 정밀한 언어로 논의할 수 있게 해 줍니다. 예를 들어 "매직 상수를 쓰지 말고 상수로 추출하세요" 대신 "의미의 커넥센스를 이름의 커넥센스로 리팩터링하세요"라고 명확히 전달할 수 있습니다.

## 모듈에서 컴포넌트로

이 문서는 관련 코드 묶음을 일반적으로 '모듈'이라고 표현했지만, 아키텍트는 이를 소프트웨어 아키텍처의 가장 중요한 구성 요소인 '**컴포넌트(Component)**'라고 부릅니다. 컴포넌트의 개념과 이를 논리적·물리적으로 분리하는 방법에 대한 고민은 컴퓨터 과학 초기부터 현재까지 이어지고 있으며, 여전히 중요한 과제로 남아 있습니다.
