아키텍처 결정에 대한 브리핑 문서

주요 요약

이 문서는 소프트웨어 아키텍트의 핵심 역할인 아키텍처 결정 수립 과정을 심층적으로 분석합니다. 효과적인 아키텍처 결정은 개발팀이 올바른 기술적 선택을 하도록 돕는 지침이 되지만, 이 과정에는 흔히 발생하는 안티패턴들이 존재합니다.

가장 중요한 시사점은 다음과 같습니다.

1. 주요 안티패턴 극복: 아키텍트는 잘못된 결정에 대한 두려움으로 결정을 회피하는 '자산 보호(Covering Your Assets)', 결정의 근거가 불분명해 논쟁이 반복되는 '그라운드호그 데이(Groundhog Day)', 그리고 결정 사항이 이메일 속에 묻혀 잊히는 **'이메일 주도 아키텍처(Email-Driven Architecture)'**라는 세 가지 주요 안티패턴을 반드시 극복해야 합니다. 이를 해결하기 위해서는 '마지막 책임 순간'까지 기다리는 전략, 기술적 및 비즈니스적 근거를 명확히 제시하는 것, 그리고 중앙화된 문서 시스템을 활용하는 것이 핵심입니다.
2. ADR(아키텍처 결정 기록)의 활용: 아키텍처 결정을 문서화하는 가장 효과적인 방법은 ADR(Architectural Decision Records)을 사용하는 것입니다. ADR은 결정의 제목, 상태, 컨텍스트, 결정 사항, 결과 등을 포함하는 간결한 텍스트 파일로, 왜 특정 결정이 내려졌는지에 대한 명확한 근거와 트레이드오프 분석을 제공합니다. 이는 단순한 기록을 넘어, 아키텍처 그 자체를 설명하는 강력한 문서화 도구가 됩니다.
3. '아키텍처적 중요성'의 이해: 모든 기술 결정이 아키텍처 결정은 아닙니다. Michael Nygard가 제시한 '아키텍처적으로 중요한' 결정은 시스템의 구조, 비기능적 특성, 의존성, 인터페이스, 구축 기법에 영향을 미치는 것들로, 아키텍트가 집중해야 할 영역을 명확히 합니다.
4. 생성형 AI의 한계: 현재의 생성형 AI와 LLM은 아키텍처 결정에 필요한 비즈니스 컨텍스트와 트레이드오프 분석 능력이 부족합니다. AI는 가능한 선택지를 나열할 수는 있지만, 특정 상황에 맞는 최적의 결정을 내리는 데 필요한 '지혜'는 갖추지 못했으므로, 최종 결정은 여전히 아키텍트의 몫입니다.

아키텍처 결정의 본질

아키텍처 결정은 애플리케이션이나 시스템의 구조에 관한 것이며, 때로는 아키텍처 특성에 영향을 미치는 기술 선택을 포함합니다. 좋은 아키텍처 결정의 핵심은 개발팀이 올바른 기술적 선택을 할 수 있도록 충분한 정보를 수집하고, 결정을 정당화하며, 이를 문서화하고 이해관계자에게 효과적으로 전달하는 것입니다.

소프트웨어 아키텍트 Michael Nygard는 아키텍트가 책임져야 할 결정을 '아키텍처적으로 중요한(architecturally significant)' 결정으로 정의하며, 다음 다섯 가지 범주를 포함합니다.

* 구조 (Structure): 사용되는 아키텍처 패턴이나 스타일에 영향을 미치는 결정. (예: 마이크로서비스 간 코드 공유)
* 비기능적 특징 (Non-functional characteristics): 성능, 확장성 등 시스템의 아키텍처 특성에 영향을 미치는 기술 선택.
* 의존성 (Dependencies): 시스템 내 컴포넌트 간의 결합 지점에 관한 결정으로, 확장성, 모듈성, 테스트 용이성 등에 영향을 미침.
* 인터페이스 (Interfaces): 서비스 및 컴포넌트에 접근하고 오케스트레이션하는 방법에 관한 결정.
* 구축 기법 (Construction techniques): 플랫폼, 프레임워크, 도구 등 기술적이지만 아키텍처의 특정 측면에 영향을 미칠 수 있는 결정.

아키텍처 결정의 주요 안티패턴

아키텍트가 결정을 내릴 때 흔히 발생하는 세 가지 진행성 안티패턴이 있으며, 효과적인 결정을 위해서는 이들 모두를 극복해야 합니다.

자산 보호 안티패턴 (Covering Your Assets Antipattern)

잘못된 결정을 내릴 것에 대한 두려움 때문에 아키텍트가 결정을 회피하거나 연기하는 상황입니다.

* 극복 방안 1: 마지막 책임 순간(Last Responsible Moment)까지 기다리기
  * 결정을 정당화할 충분한 정보가 확보되었지만, 개발팀의 작업을 지연시키거나 '분석 마비'에 빠지지 않을 최적의 시점까지 기다리는 것입니다.
  * 이 시점은 결정 지연으로 인한 비용이 결정에 따르는 리스크를 초과하는 지점으로 정의할 수 있습니다. 초기에는 정보 부족으로 리스크가 높지만 지연 비용은 낮고, 시간이 지남에 따라 리스크는 감소하지만 분석과 지연에 따른 비용은 증가합니다. 두 곡선이 교차하는 지점이 바로 결정을 내려야 할 때입니다.
* 극복 방안 2: 개발팀과 긴밀한 협업
  * 아키텍트가 모든 기술의 세부 사항을 알 수는 없으므로, 개발팀과 협력하여 결정이 현실적으로 구현 가능한지 검증하고 피드백을 신속하게 받아 리스크를 줄입니다.
  * 예시: 모든 서비스 인스턴스에 제품 데이터를 복제 캐시로 저장하기로 결정했으나, 개발팀이 일부 서비스의 확장성 요구사항 때문에 필요한 메모리를 확보할 수 없다는 사실을 발견했습니다. 아키텍트는 팀과의 긴밀한 소통 덕분에 이 문제를 즉시 파악하고 아키텍처 결정을 조정할 수 있었습니다.

그라운드호그 데이 안티패턴 (Groundhog Day Antipattern)

아키텍트가 내린 결정의 이유를 사람들이 알지 못해 동일한 논의가 계속해서 반복되는 상황입니다.

* 극복 방안: 기술적 및 비즈니스적 정당화 제공
  * 결정을 내릴 때 기술적인 이유뿐만 아니라, 비즈니스 관점에서 왜 이 결정이 중요한지를 명확히 설명해야 합니다.
  * 예시: 모놀리식 애플리케이션을 마이크로서비스로 분리하는 결정에 대해 "기능을 분리하여 개별 배포와 유지보수를 용이하게 한다"는 기술적 정당화 외에, "새로운 비즈니스 기능을 더 빨리 출시하여 시장 출시 시간을 단축하고 개발 비용을 절감한다"는 비즈니스 가치를 함께 제시해야 합니다.
  * 주요 비즈니스 정당화 요소는 다음과 같습니다.
    * 비용 (Cost)
    * 시장 출시 시간 (Time to market)
    * 사용자 만족도 (User satisfaction)
    * 전략적 포지셔닝 (Strategic positioning)

이메일 주도 아키텍처 안티패턴 (Email-Driven Architecture Antipattern)

아키텍처 결정 사항이 이메일로만 전달되어 사람들이 그 내용을 잊어버리거나, 잃어버리거나, 심지어 결정이 내려졌다는 사실조차 몰라 구현이 불가능해지는 상황입니다.

* 극복 방안: 중앙화된 문서 시스템에 연결
  * 이메일 본문에 결정 사항을 직접 작성하는 대신, 결정의 종류와 컨텍스트만 간략히 언급하고, 위키 페이지나 문서 관리 시스템에 저장된 실제 ADR 문서로 연결되는 링크를 제공합니다.
  * 이는 결정 사항이 단일 소스에서 관리되도록 보장하며, 변경 사항이 발생했을 때 모든 관련자가 최신 정보를 참조할 수 있게 합니다.
  * 예시 이메일:

아키텍처 결정 기록(ADR)을 통한 문서화

ADR(Architectural Decision Records)은 Michael Nygard에 의해 널리 알려진 아키텍처 결정 문서화 기법으로, 간결한 텍스트 파일(보통 Markdown 또는 AsciiDoc 형식)을 사용하여 특정 결정을 기록합니다.

ADR의 기본 구조

ADR은 일반적으로 다음과 같은 섹션으로 구성되며, 필요에 따라 '준수' 및 '참고' 섹션을 추가하는 것이 권장됩니다.

섹션 (Section)	설명 (Description)
제목 (TITLE)	아키텍처 결정을 명시하는 짧은 설명 (예: "42. 주문과 결제 서비스 간 비동기 메시징 사용")
상태 (STATUS)	제안됨(Proposed), 수락됨(Accepted), 대체됨(Superseded) 중 하나
컨텍스트 (CONTEXT)	이 결정을 내려야만 하는 상황이나 요인은 무엇인가?
결정 (DECISION)	내려진 결정과 그에 대한 상세한 정당화
결과 (CONSEQUENCES)	이 결정이 미치는 영향은 무엇인가? (긍정적/부정적 측면 및 트레이드오프 분석 포함)
준수 (COMPLIANCE)	이 결정을 어떻게 측정하고 준수하도록 강제할 것인가? (수동 검토 또는 자동화된 피트니스 함수)
참고 (NOTES)	결정에 대한 메타데이터 (작성자, 승인자, 날짜 등)

ADR 상태(Status) 관리 심층 분석

* 대체됨(Superseded): 기존 결정이 새로운 결정으로 변경되었음을 나타냅니다. 예를 들어, ADR 42(비동기 메시징 사용)가 나중에 ADR 68(REST 사용)로 대체될 경우, 각 ADR 상태에 대체됨(by 68)과 대체함(42)을 명시하여 결정의 이력을 추적할 수 있습니다.
* 의견 요청(Request for Comments - RFC): 결정 초안에 대해 개발자 및 이해관계자들의 피드백을 공식적으로 요청하는 상태입니다. 마감일을 설정하여 의견을 수렴한 후 최종 결정을 내립니다. (예: 상태: 의견 요청, 마감일 2026년 1월 9일)
* 승인 기준 논의: 상태 섹션은 아키텍트와 상급자 간에 어떤 결정이 자체 승인 가능한지, 어떤 결정이 상급자나 아키텍처 검토 위원회의 승인을 받아야 하는지에 대한 기준(예: 비용, 팀 간 영향, 보안)을 논의하고 문서화하도록 유도합니다.

ADR 저장 및 관리

ADR은 소스 코드와 동일한 Git 저장소에 보관하기보다는, 접근성을 높이고 여러 애플리케이션에 걸친 결정을 관리하기 위해 별도의 전용 저장소(Git, 위키, 공유 파일 서버 등)에 저장하는 것이 권장됩니다. 권장되는 디렉터리 구조는 다음과 같습니다.

* architecture decisions/
  * application/ (애플리케이션별 결정)
    * common/ (모든 애플리케이션에 적용되는 공통 결정)
    * app1/
    * app2/
  * integration/ (시스템 간 통신에 관한 결정)
  * enterprise/ (모든 시스템에 영향을 미치는 전사적 결정)

ADR의 확장된 활용

아키텍처 문서로서의 ADR

ADR은 시스템의 특정 영역(컨텍스트), 선택된 솔루션과 그 이유(결정), 그리고 고려된 트레이드오프(결과)를 명확히 설명함으로써 "왜" 이 아키텍처가 이렇게 설계되었는지를 보여주는 가장 효과적인 아키텍처 문서가 될 수 있습니다.

표준 제정을 위한 ADR 활용

개발자들이 기피하는 경향이 있는 '표준'을 ADR 형식으로 문서화하면, 해당 표준이 필요한 이유(컨텍스트, 결정)와 그로 인한 영향(결과)을 명확히 제시할 수 있습니다. 이는 표준의 필요성을 검증하고 구성원들의 이해와 수용도를 높이는 데 도움이 됩니다.

기존 시스템에 ADR 적용

이미 운영 중인 시스템에 대해서도 ADR을 작성하는 것은 매우 유용합니다. 과거의 주요 아키텍처 결정들을 역으로 추적하고 문서화하는 과정에서, 당시 결정의 타당성을 재검토하고 현재 시스템의 비효율성이나 잘못된 설계를 발견할 수 있습니다.

생성형 AI와 아키텍처 결정

생성형 AI는 방대한 지식을 가지고 있지만, 아키텍처 결정을 내리는 데는 한계가 있습니다.

* 문제의 본질: 소프트웨어 아키텍처의 모든 것은 트레이드오프입니다. AI가 주로 의존하는 확률과 '모범 사례'는 특정 비즈니스 컨텍스트에 맞는 최적의 선택을 보장하지 못합니다.
* 컨텍스트의 부재: 아키텍처 결정은 '시장 출시 시간'과 같은 비즈니스 요구사항을 '유지보수성'과 같은 아키텍처 특성으로 변환하는 과정이 필요합니다. 이러한 고도의 추상화와 경험 기반의 트레이드오프 분석은 현재 AI가 수행하기 어렵습니다.
* 결론: 생성형 AI는 결정 과정에서 고려해야 할 잠재적 트레이드오프를 식별하는 데 도움을 줄 수는 있지만, 최종적인 결정을 내리는 데 필요한 '지혜'는 부족합니다. 따라서 아키텍처 결정은 여전히 아키텍트의 핵심적인 책임으로 남습니다.
