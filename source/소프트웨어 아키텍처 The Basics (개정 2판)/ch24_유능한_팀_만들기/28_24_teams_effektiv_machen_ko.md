---
lang: ko
format:
  html:
    toc: true
    embed-resources: true
    theme: cosmo
---
# 24장. 팀의 효율성 향상

이 문서는 AI를 통해 번역되었습니다. 귀하의 피드백과 의견을 환영합니다: [translation-feedback@oreilly.com](mailto:translation-feedback@oreilly.com)

소프트웨어 아키텍트는 기술 아키텍처를 구축하고 아키텍처 결정을 내릴 뿐만 아니라, 개발팀을 이끌고 아키텍처 구현을 안내하는 역할도 담당합니다. 이러한 역할을 잘 수행하는 아키텍트는 문제를 해결하고 성공적인 솔루션을 만들기 위해 긴밀하게 협력하는 효율적인 개발팀을 만듭니다. 이는 당연하게 들릴 수 있지만, 아키텍트가 개발팀을 무시하고 고립된 환경에서 단독으로 아키텍처를 만드는 경우를 너무 자주 보았습니다. 그런 아키텍처가 개발팀에 전달되면, 개발자들은 종종 이를 제대로 구현하는 데 어려움을 겪습니다.

성공적인 소프트웨어 아키텍트의 특징은 팀을 생산적으로 만드는 것입니다. 이 장에서는 개발팀의 효율성을 향상시키기 위한 몇 가지 기본적인 기술을 소개합니다.

# 협업

소프트웨어 산업에서는 아키텍처와 개발이 완전히 분리된 활동으로 간주되는 경우가 너무 많습니다. [그림](#page-2-0) 24-1은 아키텍트의 전통적인 작업과 개발자의 작업을 비교합니다. 아키텍트는 비즈니스 요구사항 분석, 문제 도메인 해결을 위한 아키텍처 패턴 및 스타일 선택, 논리적 구성 요소 생성과 같은 활동을 담당합니다. 개발팀은 이러한 활동 중에 아키텍트가 생성한 아티팩트를 사용하여 구성 요소의 클래스 다이어그램을 만들고, UI 화면을 구축하며, 소스 코드를 작성하고 테스트합니다.

<span id="page-2-0"></span>![](_page_2_Figure_0.jpeg)

그림 24-1. 아키텍트와 개발자의 전통적인 역할

[그림](#page-2-0) 24-1의 이미지는 아키텍처에 대한 이러한 전통적인 접근 방식이 거의 효과적이지 않은 이유를 보여줍니다. 아키텍트와 개발자를 분리하는 가상 및 물리적 장벽을 통과하는 일방향 화살표를 살펴보세요. 이것이 모든 문제의 원인입니다. 아키텍트의 결정이 항상 개발팀에 전달되는 것은 아니며, 개발팀이 아키텍처를 변경할 경우 아키텍트는 거의 피드백을 받지 못합니다. 이 모델에서 아키텍트가 개발팀과 거의 관련이 없기 때문에 아키텍처는 목표를 달성하는 경우가 거의 없습니다.

성공적인 아키텍처의 핵심은 아키텍트와 개발자 간의 물리적 및 가상적 장벽을 허물고, 대신 강력한 양방향 협업을 구축하는 것입니다. [그림](#page-4-0) 24-2에 표시된 협업 모델처럼 아키텍트와 개발팀은 동일한 가상 팀의 일원이어야 합니다. 이 모델은 강력한 양방향 커뮤니케이션과 협업을 촉진할 뿐만 아니라, 아키텍트가 개발자에게 멘토링과 코칭을 제공할 수 있도록 합니다.

<span id="page-4-0"></span>![](_page_4_Picture_0.jpeg)

그림 24-2. 협업을 통해 아키텍처 성공 이끌기

오래된 정적이고 엄격한 워터폴(waterfall) 방식과 달리, 오늘날의 소프트웨어 아키텍처는 제품 개발의 거의 모든 반복(iteration) 또는 단계(phase)에 따라 변화하고 발전합니다. 아키텍트와 개발팀 간의 긴밀한 협업은 성공을 위해 필수적입니다.

이 장의 나머지 부분과 [25장](#page--1-0)에서는 개발팀을 더 효율적으로 만들 뿐만 아니라, 더 견고하고 성공적인 아키텍처를 만들어내는 건강하고 양방향적인 협업 관계를 구축하기 위한 기술을 보여줄 것입니다.

# 제약과 경계

우리의 경험에 따르면, 소프트웨어 아키텍트는 개발팀의 성공 또는 실패에 큰 영향을 미칠 수 있습니다. 소외감을 느끼거나 아키텍트와 소원해진 팀은 시스템의 다양한 제약 조건에 대해 충분히 알지 못하는 경우가 많습니다. 올바른 지침 없이는 아키텍처를 제대로 구현하는 데 어려움을 겪습니다.

소프트웨어 아키텍트의 역할 중 하나는 개발자가 아키텍처를 구현해야 하는 가이드라인(constraints)을 만들고 전달하는 것입니다. 이러한 가이드라인은 개발팀이 아키텍처 구현을 진행하는 "공간"을 형성합니다. [그림](#page-6-0) 24-3에서 보듯이, 너무 좁거나 너무 느슨한 경계는 아키텍처의 성공적인 구현을 직접적으로 방해합니다.

<span id="page-6-0"></span>![](_page_6_Picture_0.jpeg)

그림 24-3. 소프트웨어 아키텍트가 설정하는 경계는 팀이 아키텍처를 구현하는 능력에 영향을 미칩니다.

너무 많은 제약은 개발팀의 공간을 너무 작게 만들고, 시스템 구현에 필요한 많은 도구, 라이브러리 및 관행에 접근하는 것을 방해합니다. 이는 좌절감을 유발하며, 일반적으로 개발자들이 더 행복하고 건강한 환경을 찾아 프로젝트를 떠나게 만듭니다.

그 반대의 경우도 발생할 수 있습니다. 너무 느슨한 가이드라인(또는 가이드라인이 전혀 없는 경우)은 공간을 너무 넓게 만듭니다. 이 경우 너무 많은 선택지가 있어 개발팀이 아키텍트의 역할을 맡아 모든 중요한 아키텍처 결정을 내려야 합니다. 올바른 지침 없이는 개발자들이 너무 많은 개념 증명(Proof of Concept)을 수행하고, 설계 결정과 씨름하며, 비생산적이고 혼란스러워하며 좌절감을 느끼게 됩니다.

효과적인 소프트웨어 아키텍트는 팀이 필요한 모든 것을 갖도록 적절한 수준의 지침과 합리적인 제약을 제공하기 위해 노력합니다. 이 장의 나머지 부분은 이러한 합리적인 경계를 만드는 방법에 대해 다룹니다.

# 아키텍트 유형

개념의 명확성을 위해 여기서는 과감하게 일반화하여 세 가지 기본 아키텍트 유형이 있다고 말할 것입니다: *통제적인 아키텍트(controlling architect)*, *안락의자 아키텍트(armchair architect)*, 그리고 *효과적인 아키텍트(effective architect)*. 통제적인 아키텍트는 좁은 경계를 설정하는 경향이 있고, 안락의자 아키텍트는 느슨한 경계를 설정하는 경향이 있으며, 효과적인 아키텍트는 적절한 경계를 설정합니다. 다음 섹션에서는 각 아키텍트 유형에 대한 세부 정보를 설명합니다.

## **통제적인 아키텍트**

통제적인 아키텍트는 소프트웨어 개발 프로세스의 모든 세부 사항을 통제하려고 합니다. 그들이 내리는 모든 결정은 일반적으로 너무 세분화되고 낮은 수준으로 이루어져, 개발팀에게 좁은 경계와 너무 많은 제약을 초래합니다.

예를 들어, 통제적인 아키텍트는 개발팀이 유용하거나 심지어 필요한 오픈 소스 라이브러리나 타사 라이브러리를 다운로드하는 것을 막거나, 명명 규칙, 클래스 디자인, 메서드 길이 등에 엄격한 제한을 둘 수 있습니다. 그들은 심지어 개발팀이 구현해야 할 의사 코드(pseudocode)를 작성하여 개발자에게 프로그래밍의 예술을 빼앗아 갈 수도 있습니다. 개발자들은 이것을 좌절스럽게 여기고 종종 아키텍트에 대한 존경심을 잃습니다.

불행히도, 특히 소프트웨어 개발자 역할에서 아키텍트 역할로 전환할 때 통제적인 아키텍트가 되기 쉽습니다. 아키텍트의 임무는 애플리케이션의 구성 요소(논리적 구성 요소)를 설계하고 이들이 어떻게 상호 작용하는지 정의하는 것입니다. 개발자의 임무는 클래스 다이어그램과 디자인 패턴을 사용하여 이러한 논리적 구성 요소를 가장 잘 구현하는 방법을 결정하는 것입니다. 개발자로서 클래스 다이어그램을 만들고 디자인 패턴을 직접 선택하는 데 익숙한 신입 아키텍트들은 종종 이러한 유혹을 떨쳐내기 어렵습니다.

예를 들어, 아키텍트가 시스템 내에서 참조 데이터를 관리하는 논리적 구성 요소를 만든다고 가정해 봅시다. 웹사이트에서 사용되는 정적 이름-값 쌍 데이터, 제품 코드, 재고 코드와 같은 것들입니다. 아키텍트의 임무는 논리적 구성 요소(이 경우 Reference Manager)를 식별하고, 핵심 작업을 정의하며(예: GetData, SetData, ReloadCache, NotifyOnUpdate), ReferenceManager와 상호 작용해야 하는 다른 구성 요소를 결정하는 것입니다. 통제적인 아키텍트는 이 구성 요소가 특정 데이터 구조를 사용하는 내부 캐시와 병렬 로드 패턴(parallel load pattern)을 통해 가장 잘 구현될 수 있다고 생각할 수 있습니다. 이는 효과적인 설계일 수 있지만, 유일한 설계는 아니며, 더 중요한 것은 Reference Manager에 대한 내부 설계를 설계하는 것이 아키텍트의 임무가 아니라는 것입니다. 그것은 개발자의 임무입니다.

이 장에서 논의하겠지만, 아키텍트는 프로젝트의 복잡성과 팀의 역량 수준에 따라 때로는 통제적인 역할을 해야 할 수도 있습니다. 그러나 대부분의 경우 통제적인 아키텍트는 개발팀을 방해하고, 올바른 지침을 제공하지 않으며, 방해가 되고, 리더로서 일반적으로 비효율적입니다.

## **안락의자 아키텍트**

안락의자 아키텍트는 프로그래밍을 오랫동안 하지 않았거나(전혀 안 한 경우도 있음) 아키텍처를 만들 때 구현 세부 사항을 고려하지 않는 아키텍트입니다. 그들은 일반적으로 개발팀과 단절되어 있으며, 초기 아키텍처 다이어그램이 완성된 후 단순히 다음 프로젝트로 이동하기 때문에 거의 자리를 지키지 않습니다.

일부 안락의자 아키텍트는 단순히 역량 부족입니다. 그들은 리더십이나 지침을 제공하기에 기술이나 비즈니스 도메인을 충분히 알지 못합니다. 생각해 보세요: 개발자는 무엇을 합니까? 물론 소스 코드를 작성합니다. 소스 코드를 작성하는 것은 정말 속이기 어렵습니다. 소스 코드를 작성할 수 있거나 작성할 수 없습니다. 아키텍트는 무엇을 합니까? 아무도 모릅니다! 그들은 많은 선과 상자를 그립니까? 아키텍트로서 이것을 가장하는 것은 너무 쉽습니다.

예를 들어, 주식 거래 시스템을 설계하는 안락의자 아키텍트가 완전히 압도되었다고 가정해 봅시다. 그의 아키텍처 다이어그램에는 거래 시스템과 통신하는 거래 규칙 준수 시스템이라는 두 개의 상자만 포함될 수 있습니다. 이 아키텍처에 *잘못된* 것은 없지만, 누군가에게 유용하기에는 너무 복잡합니다.

안락의자 아키텍트는 개발팀 주변에 느슨한 경계를 만들어, 결국 개발팀이 아키텍트가 해야 할 일을 하도록 만듭니다. 이로 인해 속도와 생산성이 저하되고, 모든 사람이 시스템이 어떻게 작동해야 하는지 혼란스러워합니다.

안락의자 아키텍트가 되는 것은 통제적인 아키텍트가 되는 것만큼이나 쉽습니다. 아키텍트가 아키텍처를 구현하는 개발팀을 위해 시간을 내지 못하거나(또는 단순히 그들과 시간을 보내지 않는 경우) 이는 그가 안락의자 아키텍트가 되고 있다는 신호입니다. 개발팀은 아키텍트의 지원과 지침이 필요하며, 아키텍트가 질문에 답해 주기를 바랍니다. 안락의자 아키텍트의 다른 징후는 다음과 같습니다.

- 비즈니스 도메인, 비즈니스 문제 또는 사용 중인 기술에 대한 불완전한 이해
- 소프트웨어 개발에 대한 실무 경험 부족
- 특정 아키텍처 솔루션 구현과 관련된 영향(예: 복잡성, 유지 보수, 테스트)을 고려하지 않음

안락의자 아키텍트가 되기를 *의도*하는 아키텍트는 거의 없습니다. 프로젝트나 팀 간에 너무 많이 분산되어 기술이나 비즈니스 도메인과의 접촉을 잃으면 "그냥" 그렇게 됩니다. 이를 피하려면 프로젝트의 기술에 더 많이 참여하고 비즈니스 문제와 도메인에 대한 이해를 높이는 것이 좋습니다.

## **효과적인 아키텍트**

*효과적인* 소프트웨어 아키텍트는 적절한 제약과 경계를 설정하고, 팀 구성원들이 잘 협력하도록 하며, 올바른 지침을 제공합니다. 또한 팀이 올바른 도구와 기술을 갖추도록 하고, 개발팀이 목표 달성을 방해하는 다른 모든 장애물을 제거합니다.

이것은 분명하고 간단해 보이지만, 실제로는 그렇지 않습니다. 효과적인 *리더*이자 효과적인 소프트웨어 아키텍트가 되는 것은 예술입니다. 이를 위해서는 개발팀과 긴밀하게 협력하고 그들의 존경을 얻어야 합니다. 다음 섹션에서는 아키텍트가 개발팀에 얼마나 관여해야 하는지 결정하는 데 도움이 되는 몇 가지 기술을 보여줄 것입니다.

# 얼마나 관여해야 하는가?

효과적인 아키텍트가 되기 위해서는 특정 개발팀에 얼마나 관여해야 하는지, 그리고 언제 개입을 피해야 하는지 아는 것이 중요합니다. *Elastic Leadership* ([https://elasticleadership.com/](https://elasticleadership.com/))으로 알려진 이 개념은 작가이자 컨설턴트인 Roy Osherove가 주창했습니다. 우리는 Osherove의 이 분야 연구에서 약간 벗어나 소프트웨어 아키텍처 리더십에 특화된 요소에 초점을 맞출 것입니다.

개발팀에 얼마나 관여해야 하는지 아는 것은 어려울 수 있습니다. 동시에 얼마나 많은 팀이나 프로젝트를 이끌 수 있는지도 마찬가지입니다. 고려해야 할 다섯 가지 주요 요소는 다음과 같습니다.

*팀 내 친숙도*

팀원들은 서로를 얼마나 잘 아나요? 이전에 함께 일한 적이 있나요? 팀원들이 서로를 더 잘 알수록 스스로 조직화하는 능력이 향상되며, 아키텍트의 필요성은 줄어듭니다. 반대로, 팀원들이 새로울수록 아키텍트의 도움이 협업을 촉진하고 파벌을 해소하는 데 더 많이 필요합니다.

## *팀 규모*

우리는 12명 이상의 개발자로 구성된 팀을 대규모 팀으로, 5명 이하의 팀을 소규모 팀으로 간주합니다. 팀 규모가 클수록 아키텍트의 필요성이 커집니다. 이 주제는 "팀의 [경고 신호](#page-23-0)"에서 더 자세히 논의할 것입니다.

#### *전반적인 경험*

팀은 경험이 많은 개발자와 경험이 적은 개발자로 어떻게 구성되어 있나요? 팀원들은 기술과 비즈니스 도메인에 대해 얼마나 잘 알고 있나요? (비즈니스 도메인이 특히 복잡하다면, 팀원들의 기술 경험을 비즈니스 도메인 경험과 별도로 평가해야 합니다). 주니어 개발자가 많은 팀은 아키텍트의 더 많은 참여와 감독, 그리고 더 많은 멘토링이 필요합니다. 경험이 많은 개발자로 구성된 팀에서는 아키텍트가 멘토보다는 촉진자의 역할을 할 수 있습니다.

### *프로젝트 복잡성*

고도로 복잡한 프로젝트에서는 아키텍트가 문제 해결을 위해 더 많이 상주해야 하는 반면, 비교적 간단하고 관리하기 쉬운 프로젝트에서는 개입이 덜 필요합니다.

### *프로젝트 기간*

프로젝트가 짧은가(예: 2개월), 긴가(2년), 또는 평균적인 기간(약 6개월)인가? 프로젝트 기간이 길수록 아키텍트의 참여가 더 많이 필요합니다.

이러한 요소들 대부분은 명백해 보이지만, 프로젝트 기간은 때때로 혼란스러울 수 있습니다. 앞서 언급했듯이, 프로젝트 기간이 짧을수록 개입이 덜 필요하고, 프로젝트 기간이 길수록 개입이 더 많이 필요합니다. 이것이 역직관적으로 들리나요? 빠른 2개월 프로젝트를 생각해 보세요. 2개월은 요구 사항을 검증하고, 실험하고, 코드를 개발하고, 모든 시나리오를 테스트하고, 프로덕션에 출시하기에는 충분한 시간이 아닙니다. 이 경우 아키텍트는 안락의자 아키텍트처럼 행동해야 합니다. 개발팀은 이미 긴박감을 가지고 있으며, 통제적인 아키텍트는 방해가 되고 프로젝트를 지연시킬 뿐입니다. 2년짜리 프로젝트를 상상해 보세요. 개발자들은 더 여유롭고 긴박감을 느끼지 못합니다. 그들은 아마도 휴가를 계획하고 긴 점심을 먹을 것입니다. 따라서 장기 프로젝트에서는 아키텍트가 프로젝트가 일정대로 진행되고 팀이 가장 복잡한 작업을 먼저 완료하도록 보장해야 합니다.

이러한 요소를 사용하여 적절한 참여 수준을 결정하는 방법을 설명하기 위해, [그림](#page-16-0) 24-4에 표시된 대로 각 요소에 대해 20점 척도를 가정해 봅시다. 척도의 음수 값은 낮은 참여를 나타내며, 안락의자 아키텍트의 극단으로 끝납니다. 양수 값은 더 많은 참여를 의미하며, 통제적인 아키텍트의 극단으로 끝납니다.

<span id="page-16-0"></span>![](_page_16_Figure_0.jpeg)

그림 24-4. 개발팀에 대한 아키텍트 참여 범위를 측정하기 위한 척도

이 척도는 물론 정확하지는 않지만, 개발팀에 대한 아키텍트 참여의 범위를 결정하는 데 도움이 됩니다. 예를 들어, [표](#page-18-0) 24-1과 [그림](#page-19-0) 24-5에 표시된 프로젝트 시나리오 1을 고려해 보세요. 표의 각 요소에 대한 값은 "바늘"을 두 극단으로 이동시킵니다. 즉, 더 많은 참여를 나타내는 요소에는 +20, 더 적은 참여를 나타내는 요소에는 -20을 부여합니다. 시나리오 1의 요소 값은 총 -60으로, 아키텍트가 팀을 지원하되 방해가 되지 않도록 일상적인 상호 작용에서 참여를 제한해야 함을 의미합니다. 그들은 질문에 답하고 팀이 올바른 방향으로 나아가고 있는지 확인해야 하지만, 대부분 아키텍트는 물러서서 숙련된 팀이 가장 잘하는 일, 즉 소프트웨어를 빠르게 개발하는 일을 하도록 해야 합니다.

<span id="page-18-0"></span>표 24-1. 참여 범위에 대한 시나리오 1 예시

| 요소                     | 값                       | 평가 | 성향             |
|----------------------------|----------------------------|-----------|------------------------|
| 팀 내<br>친숙도 | 신규<br>팀원     | +20       | 통제적인 아키텍트            |
| 팀 규모                  | 소규모<br>(4명<br>멤버) | -20       | 안락의자<br>아키텍트 |
| 전반적인<br>경험    | 모두<br>숙련됨         | -20       | 안락의자<br>아키텍트 |
| 프로젝트 복잡성         | 비교적<br>단순         | -20       | 안락의자<br>아키텍트 |
| 프로젝트 기간               | 2<br>개월                | -20       | 안락의자<br>아키텍트 |
|                            |                            |           |                        |
| 누적<br>점수    |                            | -60       | 안락의자<br>아키텍트 |

<span id="page-19-0"></span>![](_page_19_Figure_0.jpeg)

그림 24-5. 시나리오 1에 대한 참여 범위

이제 [표](#page-21-0) 24-2에 설명되고 [그림](#page-22-0) 24-6에 표시된 시나리오 2를 살펴보겠습니다. 팀원들은 서로를 잘 알고 있지만, 팀 규모는 크고(12명) 주로 주니어 개발자로 구성되어 있습니다. 프로젝트는 비교적 복잡하고 기간은 6개월입니다. 이 경우 총점은 +20으로, 효과적인 아키텍트가 멘토링 및 코칭 역할을 수행하고 일상적인 활동에 상당히 적극적으로 참여해야 하지만, 팀을 방해할 정도는 아니어야 함을 의미합니다.

<span id="page-21-0"></span>표 24-2. 참여 범위에 대한 시나리오 2 예시

| 요소                     | 값                       | 평가 | 성향          |
|----------------------------|----------------------------|-----------|------------------------|
| 팀 내<br>친숙도 | 서로<br>잘<br>앎  | -20       | 안락의자<br>아키텍트 |
| 팀 규모                  | 대규모<br>(12명<br>멤버) | +20       | 통제적인 아키텍트          |
| 전반적인<br>경험    | 대부분<br>주니어         | +20       | 통제적인 아키텍트          |
| 프로젝트 복잡성         | 높은<br>복잡성        | +20       | 통제적인 아키텍트          |
| 프로젝트 기간               | 6<br>개월                | -20       | 안락의자<br>아키텍트 |
|                            |                            |           |                        |
| 누적<br>점수    |                            | +20       | 통제적인 아키텍트          |

<span id="page-22-0"></span>![](_page_22_Figure_0.jpeg)

그림 24-6. 시나리오 2에 대한 참여 범위

아키텍트는 프로젝트 시작 시 이러한 요소를 활용하여 참여 수준을 결정하지만, 프로젝트가 진행됨에 따라 참여 수준은 일반적으로 변화합니다. 따라서 프로젝트 수명 주기 동안 이러한 요소를 지속적으로 분석하는 것이 좋습니다.

일부 요소(예: 팀의 전반적인 경험)가 다른 요소보다 중요할 수 있으므로 이러한 요소를 객관화하기는 어렵습니다. 이러한 경우 측정값을 쉽게 가중치를 부여하거나 특정 상황에 맞게 조정할 수 있습니다.

가장 중요한 메시지는 개발팀에 대한 아키텍트 참여의 적절한 범위가 이 다섯 가지 요소에 따라 달라진다는 것입니다. 아키텍트는 이러한 요소를 기반으로 참여 수준을 평가함으로써 올바른 경계를 설정하고 팀을 위한 "공간"의 적절한 크기를 만들 수 있습니다.

# <span id="page-23-0"></span>팀의 경고 신호

우리는 팀 규모를 아키텍트가 개발팀에 대한 참여 수준을 결정하는 데 도움이 되는 다섯 가지 요소 중 하나로 언급했습니다. 팀 규모가 클수록 아키텍트의 참여가 더 많이 필요하고, 팀 규모가 작을수록 참여가 덜 필요합니다. 그러나 "대규모 팀"을 구성하는 요소는 무엇일까요? 이 섹션에서는 아키텍트가 팀이 너무 커서 효율적이지 않을 수 있는지 판단하는 데 사용할 수 있는 세 가지 요소를 살펴보겠습니다.

## **프로세스 손실**

*프로세스 손실(process loss)*이라는 용어는 Fred Brooks가 그의 저서 *The Mythical Man-Month* (Addison-Wesley, 1995)에서 만들었습니다. 프로세스 손실의 기본 개념은 [Brooks' 법칙](https://oreil.ly/rZt88)으로도 알려져 있는데, *프로젝트에 더 많은 사람이 참여할수록 프로젝트는 더 많은 시간을 소요한다*는 것입니다. [그림](#page-24-0) 24-7에서 보듯이, *그룹 잠재력(group potential)*은 모든 팀원의 집단적인 노력에 의해 결정됩니다. 그러나 Brooks는 팀의 *실제* 생산성은 항상 *잠재적* 생산성보다 낮다고 말합니다. 그 차이를 팀의 *프로세스 손실*이라고 합니다.

<span id="page-24-0"></span>![](_page_24_Picture_1.jpeg)

그림 24-7. Brooks의 법칙은 팀 규모가 실제 생산성에 영향을 미친다고 말합니다.

프로세스 손실은 특정 프로젝트에 적합한 팀 규모를 결정하는 좋은 요소이며, 효과적인 소프트웨어 아키텍트는 프로세스 손실 징후를 찾기 위해 개발팀을 관찰합니다. 예를 들어, 팀원들이 리포지토리에 코드를 푸시할 때 자주 충돌이 발생한다면, 이는 그들이 동일한 코드를 작업하고 있으며 서로 방해가 될 수 있다는 신호입니다.

프로세스 손실을 피하려면 병렬 처리 영역을 찾고 팀원들이 별도의 서비스 또는 애플리케이션 영역에서 작업하도록 하는 것이 좋습니다. 프로젝트 관리자가 프로젝트에 새로운 팀원을 추가할 것을 제안할 때마다, 좋은 아키텍트는 병렬 워크플로를 만들 방법을 찾습니다. 찾지 못하면 새로운 사람이 팀에 부정적인 영향을 미칠 수 있음을 프로젝트 관리자에게 알립니다.

## **다원적 무지**

*다원적 무지(pluralistic ignorance)*는 모든 사람이 은밀히 어떤 규범을 거부하지만, 자신이 분명히 놓치고 있다고 생각하기 때문에 동의하는 경우를 말합니다. 예를 들어, 대규모 팀의 대다수가 두 원격 서비스 간에 메시지를 교환하는 것이 최선의 솔루션이라고 동의한다고 가정해 봅시다. 한 사람은 두 서비스 사이에 보안 방화벽이 있기 때문에 그것이 어리석은 생각이라고 생각합니다. 그러나 이 사람은 공개적으로 다른 모든 사람들과 메시징 사용에 동의합니다. 그는 은밀히 그 아이디어를 거부하지만, 자신이 말하면 분명히 놓치고 있는 것이 있을까 봐 두려워합니다. 그룹이 클수록 사람들은 다른 사람들에게 이의를 제기하는 것을 덜 주저합니다. 소규모 팀에서는 원래 솔루션에 의문을 제기하여 팀이 더 나은 솔루션을 위해 다른 프로토콜(예: REST)을 선택하도록 유도했을 수도 있습니다.

다원적 무지의 개념은 한스 크리스티안 안데르센의 덴마크 동화 "[벌거벗은 임금님](https://oreil.ly/ROvce)"을 통해 대중화되었습니다. 이 이야기에서 재단사로 가장한 두 사기꾼은 자신들이 "꿰맨" 새 옷이 그것을 볼 자격이 없는 사람에게는 보이지 않는다고 왕을 설득합니다. 왕은 옷을 볼 수 없지만 자신이 무능하다고 인정하고 싶지 않아 완전히 벌거벗은 채 돌아다니며 모든 신하들에게 새 옷이 어떤지 묻습니다. 무능하다고 여겨질까 봐 두려워하는 신하들은 왕에게 새 옷이 최고라고 장담합니다. 이 광기는 마침내 한 어린아이가 왕에게 옷을 전혀 입고 있지 않다고 외칠 때까지 계속됩니다.

효과적인 소프트웨어 아키텍트는 회의 중에 대화 상대의 표정과 몸짓을 관찰하여 일부 사람들이 다원적 무지 때문에 회의적인 태도를 숨기고 있는지 주의 깊게 살펴봅니다. 아키텍트가 이를 알아차리면, 촉진자의 역할을 합니다. 아마도 회의적인 사람을 가로막고 제안된 솔루션에 대해 어떻게 생각하는지 묻고, 그 사람이 틀렸더라도 목소리를 낼 때 그를 지지할 것입니다. 요점은 아키텍트가 촉진자로서 모든 사람이 자신의 의견을 말할 만큼 충분히 안전하다고 느끼도록 보장하는 것입니다.

적절한 팀 규모를 나타내는 세 번째 요소는 *책임의 분산(diffusion of responsibility)*입니다. 팀이 커질수록 이러한 성장은 의사소통에 부정적인 영향을 미칩니다. 팀원들이 누가 무엇을 책임지는지 더 이상 알지 못하고 일이 누락되기 시작하면, 이는 팀이 너무 크다는 좋은 신호입니다.

[그림](#page-28-0) 24-8은 시골길 옆에 고장 난 차 옆에 서 있는 사람을 보여줍니다. 이 시나리오에서 몇 명의 사람들이 차를 세우고 운전자에게 괜찮은지 물어볼까요? 작은 동네의 작은 길이라면 지나가는 모든 사람이 차를 세울 수도 있습니다. 하지만 같은 운전자가 대도시의 번화한 고속도로 옆에 갇혀 있다면 어떨까요? 수천 대의 차가 아무도 차를 세우고 괜찮은지 묻지 않고 지나갈 수도 있습니다. 이것은 책임의 분산에 대한 좋은 예시입니다. 도시가 점점 더 번잡해지고 사람들로 가득 차면서 사람들은 운전자가 이미 도움을 요청했거나, 사건을 목격한 다른 군중 구성원이 도와줄 것이라고 가정합니다. 그러나 이러한 대부분의 경우 도움은 오지 않으며 운전자는 배터리가 방전되거나 잊어버린 휴대폰과 함께 갇히게 됩니다.

<span id="page-28-0"></span>![](_page_28_Picture_0.jpeg)

그림 24-8. 책임의 분산

효과적인 아키텍트는 개발팀에게 아키텍처 구현을 안내할 뿐만 아니라, 팀원들이 건강하고 행복하며 공동의 목표를 달성하기 위해 협력하도록 보장합니다. 이러한 세 가지 경고 신호에 주의하고, 그들이 가리키는 문제를 해결하는 데 도움을 주는 것은 효과적인 개발팀을 보장하는 좋은 방법입니다.

# 체크리스트 활용

항공기 조종사들은 모든 비행에서 체크리스트를 사용합니다. 가장 숙련되고 노련한 조종사조차도 이륙, 착륙 및 수천 가지 다른 상황(일반적인 상황과 특이한 엣지 케이스 모두)에 대한 체크리스트를 가지고 있습니다. 그들은 단 하나의 설정이나 절차 누락(예: 이륙 전에 플랩을 10도로 설정하는 것을 잊는 경우)이 안전한 비행과 재앙의 차이를 만들 수 있기 때문에 체크리스트를 사용합니다.

아툴 가완디 박사(Dr. Atul Gawande)의 훌륭한 저서 *The Checklist [Manifesto](https://oreil.ly/XNcV9)* (Picador, 2011)에서 그는 수술을 더 안전하게 만드는 체크리스트의 힘을 설명합니다. 병원의 포도상구균 감염률이 높다는 사실에 경각심을 느낀 가완디 박사는 수술 체크리스트를 개발했습니다. 체크리스트를 사용한 병원에서는 감염률이 거의 0으로 떨어졌지만, 체크리스트를 사용하지 않은 대조군 병원에서는 감염률이 계속 증가했습니다.

체크리스트는 효과적입니다. 모든 작업이 다루어지고 완료되도록 보장하는 훌륭한 방법입니다. 그렇다면 소프트웨어 개발에서는 왜 사용되지 않을까요? 우리는 이 산업에서 수년간 일했으며, 체크리스트가 개발팀의 효율성에 큰 차이를 만든다고 굳게 믿습니다. 물론 대부분의 소프트웨어 개발자들은 비행기를 조종하거나 심장 수술을 하는 것과 같은 생명과 관련된 일을 다루지 않습니다. 다시 말해, 소프트웨어 개발자들이 모든 것에 체크리스트가 필요한 것은 아닙니다. 핵심은 언제 사용해야 하고 언제 사용하지 말아야 하는지 아는 것입니다.

[그림](#page-31-0) 24-9는 체크리스트가 아닙니다. 새로운 데이터베이스 테이블을 만들기 위한 일련의 절차 단계이므로 체크리스트 형태로 제시되어서는 안 됩니다. 일부 작업은 다른 작업에 의존합니다. 예를 들어, 양식이 아직 제출되지 않은 경우 데이터베이스 테이블을 확인할 수 없습니다. 종속적인 작업의 절차 흐름이 있는 모든 프로세스는 체크리스트에 포함되어서는 안 됩니다. 또한 자주 오류 없이 수행되는 간단하고 익숙한 프로세스는 체크리스트에 포함되어서는 안 됩니다.

<span id="page-31-0"></span>

| 완료 | 작업 설명                                |
|------|-------------------------------------------------|
|      | 데이터베이스 열 필드 이름과 유형 결정 |
|      | 데이터베이스 테이블 요청 양식 작성            |
|      | 새 데이터베이스 테이블에 대한 권한 획득        |
|      | 데이터베이스 그룹에 요청 양식 제출           |
|      | 생성된 테이블 확인                       |

그림 24-9. 좋지 않은 체크리스트의 예시

체크리스트에 적합한 후보는 정해진 순서나 종속적인 작업이 없으며, 단계가 자주 누락되거나 오류가 발생하는 프로세스입니다. 과장하지 말고 모든 것을 체크리스트로 만들지 마세요. 아키텍트들은 체크리스트가 개발팀을 실제로 더 효율적으로 만든다는 것을 깨달을 때 종종 이렇게 합니다. 그들은 *수확 체감의 법칙(law of diminishing returns)* ([https://oreil.ly/px1g3](https://oreil.ly/px1g3))을 따를 위험이 있습니다. 아키텍트가 더 많은 체크리스트를 만들수록 개발자들이 그것을 사용할 가능성은 줄어듭니다. 또한 모든 필요한 단계를 포함하면서 체크리스트를 가능한 한 작게 유지하는 것이 좋습니다. 개발자들은 일반적으로 너무 긴 체크리스트를 따르지 않을 것입니다. 나열된 작업 중 자동화할 수 있는 것이 있다면, 그것을 자동화하고 체크리스트에서 제거해야 합니다.

#### **참고**

체크리스트에 명백한 것을 언급하는 것에 대해 걱정하지 마세요. 명백한 것이 보통 간과되는 것입니다.

우리가 특히 유용하다고 생각한 세 가지 체크리스트는 개발자 코드 완성, 단위 및 기능 테스트, 소프트웨어 릴리스와 관련이 있습니다. 각 체크리스트는 다음 섹션에서 다룹니다.

#### **호손 효과**

개발팀에 체크리스트를 도입하는 데 가장 어려운 점은 개발자들이 실제로 그것을 사용하도록 하는 것입니다. 개발자들이 시간이 부족해서 실제 작업을 수행하지 않고 체크리스트의 모든 항목을 단순히 체크하는 경우가 너무 자주 발생합니다.

이 문제를 해결하는 한 가지 방법은 팀과 체크리스트 사용이 가져올 수 있는 변화에 대해 이야기하고, Atul Gawande의 책 *The Checklist Manifesto*를 읽게 하는 것입니다. 각 팀원이 각 체크리스트의 이유를 이해하도록 확인하세요. 어떤 프로세스를 체크리스트에 넣을지 말지에 대해 공동으로 결정하도록 고려해 보세요. 이는 책임감을 심어줄 것입니다.

모든 것이 실패하면, *[호손 효과](https://oreil.ly/caGH_)*가 있습니다. 즉, 관찰되거나 감시되고 있다는 것을 아는 사람들은 일반적으로 올바른 일을 하기 위해 행동을 바꾸는 경향이 있습니다. 이 효과는 실제 감시보다는 인식을 덜 필요로 합니다. 예를 들어, 많은 고용주들은 눈에 잘 띄는 곳에 작동하지 않는 카메라를 설치하고, 다른 사람들은 거의 확인하지 않는 웹사이트 모니터링 소프트웨어를 설치합니다. (이러한 보고서 중 관리자가 실제로 보는 것은 얼마나 될까요?)

체크리스트에 대한 호손 효과를 활용하려면, 팀의 생산성에 체크리스트 사용이 매우 중요하므로 모든 체크리스트를 검토하여 작업이 실제로 완료되었는지 확인한다는 것을 팀에게 알려야 합니다. 실제로는 가끔 무작위 샘플링만 필요합니다. 그러면 개발자들이 작업을 건너뛰거나 거짓으로 완료 표시할 가능성이 훨씬 줄어듭니다.

## **개발자 코드 완성 체크리스트**

코드 완성 체크리스트는 특히 개발자가 코드 "완료"를 선언할 때 유용한 도구입니다. 또한 "완료의 정의(definition of done)"를 찾는 데도 유용합니다. 체크리스트의 모든 항목이 완료되면 개발자는 자신이 작업한 코드를 실제로 완료했다고 말할 수 있습니다.

코드 완성 체크리스트에 포함되어야 할 몇 가지 사항은 다음과 같습니다.

- 자동화된 도구에 포함되지 않은 코딩 및 포맷팅 표준
- 자주 간과되는 사항(예: 흡수된 예외)
- 프로젝트별 표준
- 특정 팀 지침 또는 절차

[그림](#page-35-0) 24-10은 개발자 코드 완성 체크리스트의 예시를 보여줍니다. 여기에는 "코드 정리 및 코드 포맷팅 실행" 및 "흡수된 예외가 없는지 확인"과 같은 명백한 작업이 있습니다. 개발자들이 급하게 IDE에서 코드 정리 및 포맷팅을 실행하는 것을 얼마나 자주 잊을까요? 꽤 자주. *The Checklist Manifesto*에서 가완디는 수술에서도 동일한 현상을 발견합니다. 즉, 명백한 작업이 종종 간과됩니다.

<span id="page-35-0"></span>

| 완료 | 작업 설명                                         |
|------|----------------------------------------------------------|
|      | 코드 정리 및 코드 포맷팅 실행                     |
|      | 사용자 정의 소스 유효성 검사 도구 실행                    |
|      | 모든 업데이트에 대해 감사 로그가 기록되었는지 확인          |
|      | 흡수된 예외가 없는지 확인               |
|      | 하드코딩된 값 확인 및 상수로 변환      |
|      | setFailure()를 공용 메서드만 호출하는지 확인 |
|      | 서비스 API 클래스에 @ServiceEntrypoint 포함          |

아키텍트는 항상 체크리스트를 검토하여 특정 항목을 자동화하거나 코드 유효성 검사기 플러그인으로 작성할 수 있는지 확인해야 합니다. 체크리스트의 프로젝트별 작업(예: 사용자 정의 유효성 검사기 실행, 감사 로그 확인, `setFailure()` 메서드 호출, `@ServiceEntrypoint` 어노테이션 포함)은 체크리스트에 잘 포함되어 있지만, 일부는 자동화될 수 있습니다. "`@ServiceEntrypoint`를 서비스 API 클래스에 포함"에 대한 자동화된 검사는 불가능할 수 있지만, "`setFailure()`를 공용 메서드만 호출하는지 확인"에 대해서는 가능할 것입니다. 즉, 어떤 코드 크롤링 도구로든 자동화할 수 있는 간단한 검사입니다. 자동화 가능한 영역을 검사하면 체크리스트의 범위가 줄어들고 신호 대 잡음 비율이 향상됩니다.

## **단위 및 기능 테스트 체크리스트**

가장 좋은 체크리스트 중 하나는 단위 및 기능 테스트를 위한 것일 수 있습니다. 이 체크리스트에는 소프트웨어 개발자들이 종종 테스트하는 것을 잊는 특이한 경우와 엣지 케이스가 포함되어 있습니다. QA팀에서 특정 테스트 케이스로 인해 코드 문제를 발견하면 해당 테스트 케이스를 이 체크리스트에 추가하세요.

이 체크리스트는 코드에 대해 수행할 수 있는 모든 종류의 테스트를 포함하므로 일반적으로 가장 긴 체크리스트 중 하나입니다. 이는 테스트가 가능한 한 완벽하도록 보장하여 개발자가 체크리스트를 완료했을 때 코드가 실제로 프로덕션 준비가 되었는지 확인하는 것을 목표로 합니다.

일반적인 단위 및 기능 테스트 체크리스트에 포함되어야 할 몇 가지 사항은 다음과 같습니다.

- 텍스트 및 숫자 필드의 특수 문자
- 최소 및 최대 값 범위
- 특이하고 극단적인 테스트 케이스
- 누락된 필드

개발자 코드 완성 체크리스트와 마찬가지로, 자동화된 테스트로 작성할 수 있거나 이미 자동화된 테스트 스위트에 포함된 모든 항목은 체크리스트에서 제거하고 자동화되어야 합니다.

개발자들은 단위 테스트를 작성하는 방법을 모르거나 얼마나 많이 작성해야 하는지 모르는 경우가 있습니다. 이 체크리스트는 일반적이고 특정적인 테스트 시나리오가 개발 프로세스에 포함되도록 보장하는 데 도움이 됩니다. 테스트와 개발이 별도의 팀에서 수행되는 회사에서는 이 체크리스트가 격차를 해소하는 데 도움이 됩니다. 개발팀이 더 많은 완전한 테스트를 수행할수록 테스트 팀의 작업이 더 쉬워지고, 체크리스트에 포함되지 않은 비즈니스 시나리오에 집중할 수 있게 됩니다.

## **소프트웨어 릴리스 체크리스트**

소프트웨어를 프로덕션에 릴리스하는 것은 소프트웨어 개발 수명 주기에서 가장 오류가 발생하기 쉬운 지점 중 하나일 수 있으므로 체크리스트에 매우 적합합니다. 이 체크리스트는 빌드 및 배포 실패를 방지하고 소프트웨어 릴리스와 관련된 위험을 크게 줄이는 데 도움이 됩니다.

소프트웨어 릴리스 체크리스트는 일반적으로 여기에 제시된 체크리스트 중 가장 변동성이 큽니다. 실패한 배포나 문제가 발생할 때마다 새로운 오류와 변경된 상황을 반영하여 변경되기 때문입니다.

소프트웨어 릴리스 체크리스트는 일반적으로 다음을 포함합니다.

- 서버 또는 외부 구성 서버의 구성 변경
- 프로젝트에 추가된 타사 라이브러리(JAR, DLL 등)
- 데이터베이스 업데이트 및 관련 데이터베이스 마이그레이션 스크립트

빌드 또는 배포가 실패할 때마다 아키텍트는 실패의 원인을 분석하고 소프트웨어 릴리스 체크리스트에 해당 항목을 추가해야 합니다. 이렇게 하면 다음 빌드 또는 배포 시 해당 항목이 확인되어 문제가 다시 발생하는 것을 방지할 수 있습니다.

# 지침 제공

소프트웨어 아키텍트가 팀을 효율적으로 만드는 또 다른 방법은 설계 원칙을 지침으로 사용하는 것입니다. 이는 개발자가 아키텍처 구현을 진행하는 "공간"을 만드는 데도 도움이 됩니다. 설계 원칙을 전달하는 것은 팀 성공의 핵심 중 하나입니다.

이 점을 설명하기 위해, 소위 *계층 스택(Layered Stack)*, 즉 애플리케이션을 구성하는 타사 라이브러리 모음을 사용하는 개발팀을 이끌고 있다고 상상해 보세요. 개발팀은 어떤 라이브러리가 허용되고 어떤 라이브러리가 허용되지 않는지, 그리고 언제 라이브러리에 대한 자체 결정을 내릴 수 있는지 등 계층 스택에 대해 많은 질문을 가질 것입니다.

개발자들이 사용하려는 라이브러리에 대해 다음 질문에 답하도록 하는 것부터 시작할 수 있습니다.

- 제안된 라이브러리와 시스템의 기존 기능 간에 중복되는 부분이 있습니까?
- 제안된 라이브러리를 사용하려는 이유는 무엇입니까?

첫 번째 질문은 개발자에게 새로운 라이브러리가 제공하는 기능이 기존 라이브러리나 기존 기능으로 충족될 수 있는지 확인하도록 안내합니다. 개발자들이 이 작업을 무시하면(때때로 발생합니다), 특히 대규모 프로젝트와 팀에서 많은 중복 기능을 생성하게 될 수 있습니다.

두 번째 질문은 개발자에게 새로운 라이브러리나 기능이 정말 필요한지 스스로에게 물어보도록 합니다. 우리는 기술적 근거와 비즈니스 근거를 모두 묻는 것을 권장합니다. 또한 이 기술은 개발자들에게 비즈니스 근거를 제공해야 한다는 점을 인식시키기 때문입니다.

#### **비즈니스 정당화의 영향**

저자 중 한 분은 대규모 개발팀과 함께 특히 복잡한 Java 기반 프로젝트의 수석 아키텍트였습니다. 한 팀원은 Scala 프로그래밍 언어에 집착하여 프로젝트에서 Scala를 사용하기를 간절히 원했습니다. Scala를 사용하려는 그의 열망은 너무 강해서 두 명의 중요한 팀원이 프로젝트를 떠나 다른 "덜 유해한" 환경으로 옮겨갈 의사를 밝혔습니다. 저자는 그들을 설득하여 멈추게 했습니다. 그런 다음 그는 Scala 열정가에게 훈련 및 재작성 비용에 대한 비즈니스 정당화를 제시하면 프로젝트에서 Scala 사용을 지원할 것이라고 말했습니다. Scala 열정가는 기뻐하며 즉시 그것을 처리하겠다고 말했습니다. 그들은 "감사합니다. 당신이 최고입니다!"라고 말하며 회의장을 떠났습니다.

다음날 Scala 열정가는 완전히 다른 사람이 되어 사무실로 왔고, 저자와 이야기할 것을 요청했습니다. 그는 즉시 (그리고 겸손하게) "감사합니다"라고 말했습니다. Scala 열정가는 Scala를 사용하는 모든 기술적인 이유를 찾았지만, 이러한 기술적인 이점 중 어떤 것도 비용, 예산, 일정 측면에서 비즈니스적인 이점을 가져다주지 못했다고 설명했습니다. 실제로 Scala 열정가는 두 가지를 깨달았습니다. 첫째, 비용, 예산, 일정을 늘리는 것이 어떤 이점도 가져다주지 않을 것이며, 둘째, 그들이 팀을 방해하고 있었다는 것입니다. 얼마 지나지 않아 Scala 열정가는 최고의 도움을 주는 팀원 중 한 명으로 변모했습니다. 그들이 원했던 것에 대한 비즈니스 정당화를 요청하는 것은 그들의 비즈니스 요구에 대한 인식을 높여 더 나은 소프트웨어 개발자를 만들고 팀을 더 강하고 건강하게 만들었습니다. 실제로 떠나려 했던 두 명의 주요 개발자들은 팀에 남았습니다.

설계 원칙을 전달하는 또 다른 좋은 방법은 개발팀이 어떤 결정을 내릴 수 있고 어떤 결정을 내릴 수 없는지에 대한 그래픽 설명을 사용하는 것입니다. [그림](#page-43-0) 24-11의 그래픽은 계층 스택(layered stack) 제어에 대한 예시를 보여줍니다.

![](_page_43_Figure_0.jpeg)

이러한 범주는 단지 예시일 뿐이지만, 훨씬 더 많은 범주를 정의할 수 있습니다. 아키텍트가 [그림](#page-43-0) 24-11을 팀에 소개할 때, 그는 각 범주를 사용 제안된 타사 라이브러리에 적용해야 합니다.

#### *특별한 목적*

이는 PDF 렌더링, 바코드 스캔 등 자체 소프트웨어를 작성할 필요가 없는 특수 라이브러리입니다.

#### *일반적인 목적*

이러한 라이브러리는 Apache Commons 및 Guava for Java와 같이 언어 API 위에 구축된 래퍼(wrapper)입니다.

#### *프레임워크*

이러한 라이브러리는 지속성(Hibernate와 같은) 및 제어 역전(Spring과 같은)과 같은 용도로 사용됩니다. 다시 말해, 애플리케이션의 전체 계층 또는 구조를 형성하며 매우 침습적입니다.

다음으로 아키텍트는 이 설계 원칙 주변에 "공간"을 만듭니다. [그림](#page-43-0) 24-11에서 아키텍트는 개발자가 아키텍트와 상의하지 않고도 특수 라이브러리에 대한 결정을 내릴 수 있도록 허용했습니다. 범용 라이브러리의 경우 개발자는 중복 분석을 수행하고 근거를 제시하며 권장 사항을 제시할 수 있지만, 이 라이브러리 범주는 아키텍트의 승인을 받아야 합니다. 마지막으로 프레임워크 라이브러리의 경우 아키텍트가 전적으로 책임집니다. 개발팀은 이러한 유형의 라이브러리에 대해 분석조차 수행해서는 안 됩니다.

# 요약

개발팀을 효율적으로 만드는 것은 힘든 일입니다. 많은 경험과 연습, 그리고 좋은 사회성(이는 다음 장에서 논의할 것입니다)이 필요합니다. 그러나 이 장의 탄력적 리더십, 체크리스트 사용, 설계 원칙 전달과 같은 간단한 기술은 실제로 효과적입니다. 우리는 개발팀이 더 스마트하게 일할 수 있도록 하는 데 있어 이러한 기술들이 얼마나 유용한지 보았습니다.

일부 사람들은 이러한 활동에서 아키텍트의 역할에 의문을 제기하며, 이 작업이 개발 리더나 프로젝트 관리자에게 위임되어야 한다고 주장합니다. 우리는 이에 강력히 반대합니다. 소프트웨어 아키텍트는 기술적인 문제에 대해 팀을 이끌고 아키텍처 구현을 통해 팀을 안내합니다. 개발팀과 긴밀하게 협력함으로써 아키텍트는 팀 역학을 관찰하고 팀을 더 생산적으로 만들기 위한 변경 사항을 적용할 수 있습니다.