---
lang: ko
format:
  html:
    toc: true
    embed-resources: true
    theme: cosmo
---

# 10장. 계층형 아키텍처 스타일

이 문서는 AI를 사용하여 번역되었습니다. 귀하의 피드백과 의견을 환영합니다: [translation-feedback@oreilly.com](mailto:translation-feedback@oreilly.com)

*계층형 아키텍처(Layered Architecture)*는 *n-계층(n-tiered)*으로도 알려져 있으며 가장 일반적인 아키텍처 스타일 중 하나입니다. 단순성, 친숙성 및 저렴한 비용으로 인해 많은 레거시 애플리케이션의 사실상 표준입니다.

계층형 아키텍처 스타일은 *내포적 아키텍처(Architecture by Implication)* 및 *우발적 아키텍처(Accidental Architecture)* 안티패턴을 포함하여 여러 아키텍처 안티패턴에 빠질 수 있습니다. 개발자나 아키텍트가 어떤 아키텍처 스타일을 사용할지 모르고 "그냥 코딩을 시작"할 경우, 계층형 아키텍처 스타일을 구현할 가능성이 높습니다.

# 토폴로지 (Topology)

계층형 아키텍처의 구성 요소는 [그림](#page-1-0) 10-1에 표시된 것처럼 논리적인 수평 계층으로 구성되며, 각 계층은 애플리케이션 내에서 특정 작업(예: 프레젠테이션 로직 또는 비즈니스 로직)을 수행합니다. 계층의 수와 유형에 대한 특정 제한은 없지만, 대부분의 계층형 아키텍처는 프레젠테이션(Presentation), 비즈니스(Business), 영속성(Persistence), 데이터베이스(Database)의 네 가지 표준 계층으로 구성됩니다. 일부 아키텍처에서는 비즈니스 계층 구성 요소에 영속성 로직(SQL 또는 HSQL 등)이 포함된 경우 비즈니스 계층과 영속성 계층이 결합되기도 합니다. 소규모 애플리케이션은 세 가지 계층만 가질 수 있지만, 더 크고 복잡한 비즈니스 애플리케이션은 다섯 개 이상의 계층을 포함할 수 있습니다.

<span id="page-1-0"></span>![](_page_1_Picture_1.jpeg)

그림 10-1. 계층형 아키텍처 스타일의 논리적 표준 계층

[그림](#page-3-0) 10-2는 물리적 계층(배포) 관점에서 본 토폴로지 변형을 보여줍니다. 첫 번째 변형에서는 프레젠테이션, 비즈니스 및 영속성 계층이 단일 배포 단위로 번들링되며, 데이터베이스 계층은 일반적으로 별도의 외부 물리적 데이터베이스(또는 파일 시스템)로 표시됩니다. 두 번째 변형에서는 프레젠테이션 계층이 자체 배포 단위로 물리적으로 분리되고, 비즈니스 및 영속성 계층은 두 번째 배포 단위로 번들링됩니다. 이 변형에서도 데이터베이스 계층은 일반적으로 외부 데이터베이스 또는 파일 시스템에 의해 물리적으로 분리됩니다. 세 번째 변형은 데이터베이스 계층을 포함하여 네 가지 표준 계층을 모두 단일 배포 단위로 결합합니다. 이 변형은 내부 임베디드 데이터베이스 또는 인메모리 데이터베이스를 사용하는 소규모 애플리케이션(예: 모바일 장치 애플리케이션)에 유용할 수 있습니다. 많은 온프레미스(on-premises) 제품은 이 세 번째 변형을 사용하여 빌드되고 고객에게 제공됩니다.

<span id="page-3-0"></span>![](_page_3_Picture_0.jpeg)

그림 10-2. 물리적 토폴로지 (배포 변형)

각 계층은 특정 역할과 책임을 가지며, 특정 비즈니스 요청을 충족하기 위해 수행해야 하는 작업을 추상화합니다. 예를 들어, 프레젠테이션 계층은 모든 사용자 인터페이스 및 브라우저 통신 로직을 담당하는 반면,

비즈니스 계층은 요청과 관련된 특정 비즈니스 규칙을 실행하는 역할을 합니다. 프레젠테이션 계층은 고객 데이터를 어떻게 얻는지 알 필요도, 신경 쓸 필요도 없으며, 단지 특정 형식으로 화면에 정보를 표시하면 됩니다. 비즈니스 계층 역시 고객 데이터가 화면에 표시될 방식으로 어떻게 포맷되는지 또는 데이터가 어디에서 오는지에 대해 신경 쓸 필요가 없습니다. 단지 영속성 계층에서 데이터를 검색하고, 비즈니스 로직(예: 값 계산 또는 데이터 집계)을 적용한 다음, 이 정보를 프레젠테이션 계층으로 전달하면 됩니다.

계층형 아키텍처 스타일의 이러한 관심사 분리는 효과적인 역할 및 책임 모델을 생성하기 쉽게 만듭니다. 특정 계층의 구성 요소는 범위가 제한적이며 해당 계층에 속하는 로직만 처리합니다. 예를 들어, 프레젠테이션 계층의 구성 요소는 프레젠테이션 로직만 처리하고, 비즈니스 계층의 구성 요소는 비즈니스 로직만 처리합니다. 이를 통해 개발자는 특정 전문 지식(예: 프레젠테이션 로직 또는 영속성 로직)에 집중할 수 있습니다. 그러나 이 장점의 절충점은 *전체론적 민첩성(holistic agility)*의 부족입니다(전체 시스템이 변화에 신속하게 대응하는 능력).

계층형 아키텍처는 *기술적으로 파티셔닝된(technically partitioned)* 아키텍처입니다(*도메인 파티셔닝된 아키텍처*와 대조됨). 이는

[9장](#page--1-0)에서 배웠듯이, 구성 요소가 영역(예: 고객)이 아닌 아키텍처 내의 기술적 역할(예: 프레젠테이션 또는 비즈니스)에 따라 분리된다는 것을 의미합니다. 이로 인해 특정 비즈니스 도메인이 아키텍처의 모든 계층에 분산됩니다. 예를 들어, "고객" 도메인은 프레젠테이션 계층, 비즈니스 계층, 규칙 계층, 서비스 계층 및 데이터베이스 계층에 포함되어 이 도메인에 대한 변경을 어렵게 만듭니다. 따라서 DDD(Domain-Driven Design) 접근 방식은 계층형 아키텍처 스타일과 잘 맞지 않습니다.

### 스타일 특징 (Style Characteristics)

이 아키텍처 스타일의 계층은 특정 기술적 책임을 캡슐화하지만, 계층 자체도 다른 특성을 가질 수 있습니다.

### **격리 계층 (Layers of Isolation)**

각 계층은 폐쇄형(closed) 또는 개방형(open)일 수 있습니다. 계층이 *폐쇄형(closed)*인 경우, 최상위 계층에서 최하위 계층으로 내려가는 요청은 계층을 건너뛸 수 없습니다. 다음 계층으로 이동하려면 바로 아래 계층을 통과해야 합니다( [그림](#page-6-0) 10-3 참조). 모든 계층이 폐쇄형인 아키텍처에서 프레젠테이션 계층에서 시작된 요청은 데이터베이스 계층에 도달하기 전에 비즈니스 계층을 먼저 통과한 다음 영속성 계층을 통과해야 합니다.

<span id="page-6-0"></span>![](_page_6_Picture_0.jpeg)

그림 10-3. 다계층 아키텍처 내의 폐쇄형 계층

[그림](#page-6-0) 10-3에서 프레젠테이션 계층이 간단한 쿼리의 경우 불필요한 계층을 모두 우회하고 데이터베이스에 직접 접근하는 것이 훨씬 빠르고 쉬울 것이라는 점에 주목하십시오(이는 2000년대 초반에 *패스트 레인 리더 패턴(Fast-Lane Reader Pattern)*으로 알려져 있었습니다). 이를 위해서는 비즈니스 계층과 영속성 계층이 *개방형(open)*이어야 요청이 다른 계층을 우회할 수 있습니다. 개방형 계층과 폐쇄형 계층 중 어느 것이 더 좋을까요? 이 질문에 대한 답은 *격리 계층(Layers of Isolation)*이라고 알려진 핵심 개념에 있습니다.

*격리 계층* 개념은 아키텍처의 한 계층에서 변경이 발생하더라도 해당 계층 간의 계약이 변경되지 않는 한 일반적으로 다른 계층의 구성 요소에 영향을 미치지 않는다는 것을 의미합니다. 각 계층은 다른 계층과 독립적이며 내부 작동에 대해 거의 알지 못합니다. 그러나 계층 격리를 지원하려면 요청의 주 흐름에 참여하는 계층은 폐쇄형이어야 합니다. 프레젠테이션 계층이 영속성 계층에 직접 접근할 수 있다면, 영속성 계층의 변경 사항은 비즈니스 계층 *과* 프레젠테이션 계층 모두에 영향을 미칩니다. 이는 계층형 아키텍처를 매우 깨지기 쉽게 만들고 변경하기 어렵고 비용이 많이 들게 만듭니다.

<span id="page-7-0"></span>격리 계층을 사용하면 아키텍처의 각 계층을 다른 계층에 영향을 주지 않고 교체할 수 있습니다(계약이 명확하게 정의되어 있고 *비즈니스 델리게이트(Business Delegate)* 패턴이 사용되는 경우). 예를 들어, 프레젠테이션 계층 내에서 오래된 UI 프레임워크를 새로운 프레임워크로 교체할 수 있습니다. **[1](#page-25-0)**

### **계층 추가 (Adding Layers)**

폐쇄형 계층이 계층 격리를 용이하게 하고 변경 사항을 격리하는 데 도움이 되더라도 특정 계층이 개방형인 것이 합리적인 경우가 있습니다. 예를 들어, 계층형 아키텍처의 비즈니스 계층에 공통 비즈니스 구성 요소 기능(예: 날짜 및 문자열 유틸리티 클래스, 감사 클래스, 로깅 클래스 등)이 포함된 공유 객체가 있다고 가정해 봅시다. 당신은 프레젠테이션 계층이 이러한 공유 비즈니스 객체를 사용하지 못하도록 하는 아키텍처 결정을 내립니다. 이 제약 조건은 [그림](#page-9-0) 10-4에 표시되어 있으며, 점선은 프레젠테이션 구성 요소에서 비즈니스 계층의 공유 비즈니스 객체로 연결됩니다. 프레젠테이션 계층이 *아키텍처적으로* 비즈니스 계층에 접근할 수 있고, 따라서 해당 계층 내의 공유 객체에도 접근할 수 있기 때문에 이 시나리오는 관리하고 통제하기 어렵습니다.

![](_page_9_Figure_0.jpeg)

이러한 제약을 아키텍처적으로 구현하는 한 가지 방법은 모든 공유 비즈니스 객체를 포함하는 새로운 서비스 계층을 추가하는 것입니다([그림](#page-11-0) 10-5 참조). 이 새로운 계층을 추가하면 비즈니스 계층이 폐쇄형이므로 프레젠테이션 계층이 공유 비즈니스 객체에 아키텍처적으로 접근하는 것을 방지할 수 있습니다. 그러나 비즈니스 계층이 영속성 계층에 접근하기 위해 서비스 계층을 통과해야 하는 것을 피하려면 새로운 서비스 계층을 *개방형(open)*으로 표시해야 합니다. 서비스 계층을 개방형으로 표시하면 비즈니스 계층은 이 계층에 접근하거나(실선 화살표로 표시됨) 이를 우회하고 다음 하위 계층으로 이동할 수 있습니다(점선 화살표로 표시됨).

![](_page_11_Picture_0.jpeg)

개방형 및 폐쇄형 계층 개념을 활용하면 아키텍처 계층과 요청 흐름 간의 관계를 정의하는 데 도움이 됩니다. 또한 개발자에게 아키텍처 내의 계층 접근 제한을 이해하는 데 필요한 정보와 지침을 제공합니다. 아키텍처에서 어떤 계층이 개방형이고 폐쇄형인지(그리고 그 이유) 문서화되거나 전달되지 않으면 일반적으로 밀접하게 결합되고 취약한 아키텍처가 되어 테스트, 유지 관리 및 배포가 매우 어려워집니다.

모든 계층형 아키텍처에는 최소한 *아키텍처 싱크홀 안티패턴(Architecture Sinkhole Antipattern)*에 해당하는 일부 시나리오가 있습니다. 이 패턴은 비즈니스 로직을 실행하지 않고 단순히 계층에서 계층으로 요청이 전달될 때 발생합니다. 예를 들어, 프레젠테이션 계층이 기본 고객 데이터(이름 및 주소 등)를 검색하려는 사용자의 간단한 요청에 응답한다고 가정해 봅시다. 프레젠테이션 계층은 요청을 비즈니스 계층으로 전달하고, 비즈니스 계층은 규칙 계층으로 요청을 전달하는 것 외에는 아무것도 하지 않으며, 규칙 계층은 영속성 계층으로 전달하는 것 외에는 아무것도 하지 않으며, 영속성 계층은 데이터베이스 계층에 간단한 SQL 호출을 하여 고객 데이터를 검색합니다. 그런 다음 데이터는 추가 처리나 집계, 계산, 규칙 적용 또는 변환 로직 없이 스택을 통해 다시 전달됩니다. 이는 불필요한

객체 인스턴스화 및 처리를 초래하여 메모리 사용량과 성능을 모두 저하시킵니다.

이것이 안티패턴인지 확인하려면 이 범주에 속하는 요청의 비율을 분석해야 합니다. 80-20 규칙이 일반적으로 좋은 방법입니다. 예를 들어, 요청의 20%만 싱크홀인 경우 허용 가능합니다. 그러나 80%인 경우 계층형 아키텍처가 문제 영역에 적합한 아키텍처 스타일이 아니라는 좋은 지표입니다. 아키텍처 싱크홀 문제를 해결하기 위한 또 다른 접근 방식은 아키텍처의 모든 계층을 개방형으로 만드는 것입니다. 물론 이는 변경 사항 관리가 더 어려워진다는 절충점을 동반합니다.

## 데이터 토폴로지 (Data Topologies)

전통적으로 계층형 아키텍처는 단일 모놀리식 데이터베이스 옆에 모놀리식 시스템을 형성합니다. 공통 영속성 계층은 종종 선호하는 객체 지향 언어와 관계형 데이터베이스의 집합 기반 세계 간의 객체 계층을 매핑하는 데 사용됩니다.

# 클라우드 고려 사항 (Cloud Considerations)

계층형 아키텍처는 일반적으로 모놀리식이며 계층으로 분할되어 있기 때문에 클라우드 옵션은

클라우드 제공업체를 통해 하나 이상의 계층을 배포하는 것으로 제한됩니다. 이 아키텍처에 내재된 기술적 파티셔닝은 클라우드에서 분리된 배포에 적합합니다. 그러나 이 아키텍처의 워크플로우는 일반적으로 대부분의 계층을 통과하므로 온프레미스 서버와 클라우드 간의 통신 지연은 문제를 야기할 수 있습니다.

### 공통 위험 (Common Risks)

계층형 아키텍처는 모놀리식으로 구축되고 모듈형 아키텍처가 없기 때문에 내결함성(fault tolerance)을 제공하지 않습니다. 계층형 아키텍처의 작은 부분에서 메모리 부족 상태가 발생하면 전체 애플리케이션이 충돌합니다. 대부분의 모놀리식 애플리케이션은 평균 복구 시간(MTTR: Mean Time To Recovery)이 길기 때문에 전체 가용성도 저하됩니다. MTTR은 소규모 애플리케이션의 경우 2분에서 대부분의 대규모 애플리케이션의 경우 15분 이상에 달할 수 있습니다.

### 거버넌스 (Governance)

이 아키텍처 스타일의 관리에 대한 좋은 소식입니다. 널리 사용되기 때문에 일부 초기 구조 테스트 도구를 개발한 아키텍트들은 이 아키텍처를 염두에 두었습니다. [그림](#page--1-0) 6-4의 예시 적합성 함수는

심지어 [계층형 아키텍처](#page-15-0)를 위해 개발되었습니다(예시 10-1 참조).

#### <span id="page-15-0"></span>**예시 10-1. 계층 제어를 위한 ArchUnit 적합성 함수**

```
layeredArchitecture()
.layer("Controller").definedBy("..controller..")
.layer("Service").definedBy("..service..")
.layer("Persistence").definedBy("..persistence..")
.whereLayer("Controller").mayNotBeAccessedByAnyLayer()
.whereLayer("Service").mayOnlyBeAccessedByLayers("Control
.whereLayer("Persistence").mayOnlyBeAccessedByLayers("Ser
```

[예시](#page-15-0) 10-1에서 아키텍트는 아키텍처의 계층을 정의하고 패키지 이름으로 표현되는 구성 요소에 대해 컨트롤러와 같은 실용적인 이름을 지정합니다. (ArchUnit 구문에서 패키지 이름 양쪽의 두 점(..)은 해당 패키지가 소유권임을 나타냅니다.) 그런 다음 아키텍트는 개방형 및 폐쇄형 계층을 결정하여 계층 간의 통신을 설정합니다.

적합성 함수 라이브러리는 계층형 아키텍처 스타일을 매우 잘 지원하며 아키텍트가 구현 중에 계층 간 관계 제어를 자동화할 수 있도록 합니다.

# 팀 토폴로지 고려 사항 (Team Topology Considerations)

이 책에서 설명하는 일부 아키텍처 스타일과 달리 계층형 아키텍처 스타일은 일반적으로 팀 토폴로지와 독립적이며 모든 팀 구성에서 작동합니다.

#### *플로우 지향 팀 (Stream-Aligned Teams)*

계층형 아키텍처는 일반적으로 작고 자체 포함되어 있으며 시스템을 통한 단일 여정 또는 흐름을 나타내므로 플로우 지향 팀과 잘 작동합니다. 이 팀 토폴로지에서 팀은 일반적으로 처음부터 끝까지 시스템을 통한 흐름을 담당하며 솔루션의 일부로 워크플로우를 생성합니다.

#### *인에이블링 팀 (Enabling Teams)*

계층형 아키텍처는 기술적 관점에서 고도로 모듈화되고 분리되어 있으므로 인에이블링 팀 토폴로지와 잘 결합됩니다. 전문가 및 교차 기능 팀원은 하나 이상의 계층과 상호 작용하여 흐름의 나머지 부분에 영향을 주지 않고 제안을 하고 실험을 수행할 수 있습니다. 예를 들어, 팀은 프레젠테이션 계층에 새로운 동작을 추가하여 새로운 UI 라이브러리로 실험할 수 있으며, 다른 계층은 변경 사항으로부터 격리됩니다.

*복잡한 서브시스템 팀 (Complicated Subsystem Teams)*

각 계층이 매우 구체적인 작업을 수행하므로 이 스타일은 복잡한 서브시스템 팀 토폴로지에 적합합니다. 예를 들어, 영속성 계층은 분석을 위해 운영 데이터에 접근해야 하는 팀에게 완벽한 연결 지점입니다. 영속성 계층에 대한 접근이 허용되면 복잡한 서브시스템 팀은 플로우 지향 팀에 속한 다른 계층에 영향을 주지 않고 작업할 수 있습니다.

#### *플랫폼 팀 (Platform Teams)*

다계층 아키텍처에서 작업하는 플랫폼 팀은 사용 가능한 많은 도구를 활용하여 높은 모듈성을 활용할 수 있습니다.

대부분의 플랫폼 팀이 직면하는 가장 큰 과제는 일반적으로 모놀리식과 동일한 문제입니다. 성장함에 따라 점점 더 다루기 힘들어집니다. 팀이 얼마나 잘 분할되고 관리되든 상관없이 모놀리식에 새로운 기능을 계속 추가하면 결국 데이터베이스 연결, 메모리, 성능, 동시 사용자 또는 기타 여러 가지 임박한 문제와 같은 한계에 도달할 것입니다. 시스템을 계속 작동시키려면 플랫폼 팀은 점점 더 어려운 작업을 수행해야 합니다.

# 스타일 특성 (Style Characteristics)

특성 평가표([그림](#page-19-0) 10-6 참조)의 별 한 개는 특정 아키텍처 특성이 아키텍처에서 잘 지원되지 않음을 의미하고, 별 다섯 개는 해당 아키텍처 특성이 아키텍처 스타일의 가장 강력한 특성 중 하나임을 의미합니다. 점수표에 식별된 각 특성에 대한 정의는 [4장](#page--1-0)에서 찾을 수 있습니다.

|             | Architectural characteristic | Star rating                      |
|-------------|------------------------------|----------------------------------|
|             | 전반적인 비용                | \$                               |
| Structural  | 파티셔닝 유형                | Technical                        |
|             | 퀀텀 수                      | 1                                |
|             | 단순성                       | ***                              |
|             | 모듈성                       | $\bigstar$                       |
| Engineering | 유지보수성                   | $\stackrel{\bigstar}{\sim}$      |
|             | 테스트 용이성                | $\stackrel{\wedge}{\Rightarrow}$ |
|             | 배포 용이성                  | $\stackrel{\bigstar}{\sim}$      |
|             | 진화 가능성                  | $\stackrel{\bigstar}{\sim}$      |
| Operational | 응답성                       | <b>☆☆☆</b>                       |
|             | 확장성                       | $\bigstar$                       |
|             | 탄력성                       | $\stackrel{\bigstar}{\sim}$      |
|             | 내결함성                     | $\stackrel{\bigstar}{\sim}$      |

전반적인 비용과 단순성은 계층형 아키텍처의 주요 강점입니다. 모놀리식이므로 계층형 아키텍처는 분산 아키텍처만큼 복잡하지 않습니다. 더 간단하고 이해하기 쉬우며 구축 및 유지 관리가 상대적으로 저렴합니다. 그러나 모놀리식 계층형 아키텍처가 더 커지고 복잡해짐에 따라 이러한 특성들이 빠르게 저하될 수 있으므로 주의해야 합니다.

배포 용이성(Deployability)과 테스트 용이성(Testability)은 이 아키텍처 스타일에서 좋지 않습니다. 배포 용이성은 배포에 높은 위험이 따르고, 드물게 발생하며, 많은 노력이 필요하기 때문에 낮습니다. 예를 들어, 클래스 파일에 간단한 세 줄 변경을 하려면 전체 배포 단위를 재배포해야 하는데, 이는 원래 변경 사항 외에 데이터베이스, 구성 또는 코드의 다른 측면에 변경 사항이 몰래 들어갈 위험이 있습니다. 또한 이 간단한 세 줄 변경은 일반적으로 수십 개의 다른 변경 사항과 함께 번들링되어 배포의 위험과 빈도를 더욱 증가시킵니다. 테스트 용이성의 낮은 평가도 이 시나리오를 반영합니다. 간단한 세 줄 변경의 경우 대부분의 개발자는 간단한 세 줄 변경을 위해 전체 회귀 테스트 스위트를 실행하는 데 시간을 낭비하지 않을 것입니다(물론 그러한 테스트 스위트가 있다는 가정하에). 우리는 이 스타일이 구성 요소나 전체 계층을 모의(mock)하거나 스터브(stub)할 수 있는 기능을 제공하여 전체 테스트 노력을 용이하게 하므로 테스트 용이성을 두 개의 별(하나의 별 대신)로 평가합니다.

계층형 아키텍처의 기술적 특성은 위에서 언급한 동적 특성을 반영합니다. 모두 잘 시작되지만 코드베이스의 크기가 커짐에 따라 악화됩니다.

탄력성(Elasticity)과 확장성(Scalability)은 계층형 아키텍처에서 매우 낮게 평가됩니다(별 한 개). 이는 주로 아키텍처의 모놀리식 구현과 모듈성 부족 때문입니다. 모놀리식 내에서 특정 기능을 다른 기능보다 더 확장하는 것이 가능하지만, 이러한 노력은 일반적으로 멀티스레딩, 내부 메시징 및 기타 병렬 처리 방법과 같이 이 아키텍처에 잘 맞지 않는 매우 복잡한 설계 기술을 필요로 합니다. 그러나 계층형 시스템의 아키텍처 퀀텀은 항상 1(모놀리식 사용자 인터페이스와 데이터베이스, 백엔드 처리로 인해)이므로 애플리케이션은 특정 지점까지만 확장할 수 있습니다.

아키텍트는 신중한 설계를 통해 계층형 아키텍처에서 높은 응답성을 달성할 수 있으며 캐싱 및 멀티스레딩과 같은 기술을 통해 이를 더욱 향상시킬 수 있습니다. 우리는 이 스타일이 내재된 병렬 처리 부족과 폐쇄형 계층화 및 아키텍처 싱크홀 안티패턴으로 인해 고통받기 때문에 전반적으로 별 세 개를 부여합니다.

### **언제 사용해야 하는가**

다계층 아키텍처 스타일은 작고 간단한 애플리케이션이나 웹사이트에 좋은 선택입니다. 또한 예산과 시간 제약이 매우 엄격한 상황에 대한 좋은 출발점입니다. 단순성과 개발자 및 아키텍트에게 친숙하다는 점 때문에, 이 스타일은 소규모 애플리케이션 개발을 용이하게 하는 가장 비용 효율적인 스타일 중 하나일 수 있습니다. 계층형 아키텍처는 아키텍트가 더 복잡한 아키텍처가 더 적합한지 여부를 아직 고려 중이지만 개발을 시작해야 하는 경우에도 좋은 선택입니다.

이 기술을 사용할 때는 코드 재사용을 최소화하고 객체 계층 구조(상속 트리의 깊이)를 상대적으로 평평하게 유지하여 좋은 수준의 모듈성을 유지해야 합니다. 이렇게 하면 나중에 다른 아키텍처 스타일로 전환하기가 더 쉬워집니다.

### **언제 사용하지 말아야 하는가**

우리가 보여주었듯이, 계층형 아키텍처 스타일을 사용하는 애플리케이션이 성장함에 따라 유지보수성(Maintainability), 민첩성(Agility), 테스트 용이성(Testability), 배포 가능성(Distributability)과 같은 특성은 부정적인 영향을 받습니다. 이러한 이유로 대규모 애플리케이션 및 시스템은 다른, 더 모듈화된 아키텍처로 전환하는 것이 좋습니다.

# 예시 및 사용 사례 (Examples and Use Cases)

계층형 아키텍처는 가장 일반적인 아키텍처 스타일 중 하나이며 수많은 맥락에서 나타납니다.

운영 체제 개발자(Linux 또는 Windows 등)는 애플리케이션 아키텍트와 동일한 이유로 계층을 사용합니다. 즉, 관심사를 분리하기 위해서입니다. 운영 체제의 일반적인 계층은 다음과 같습니다.

*하드웨어 계층 (Hardware-Ebene)*

CPU, 메모리 및 I/O 장치와 같은 물리적 하드웨어를 포함합니다.

*커널 계층 (Kernel-Schicht)*

하드웨어 추상화, 메모리 관리 및 프로세스 스케줄링을 제공합니다.

*시스템 호출 인터페이스 계층 (System Call Interface Schicht)*

커널과 상호 작용하여 시스템 서비스를 제공합니다.

*사용자 계층 (Benutzerschicht)*

사용자가 상호 작용하는 애플리케이션 및 유틸리티를 포함합니다.

OSI( *Open Systems Interconnection* ) 모델은 네트워크가 책임을 어떻게 구분하는지 설명합니다. 예를 들어, 인터넷의 기본 프로토콜인 TCP/IP는 다음 계층을 포함합니다.

*물리 계층 (Physikalische Schicht)* 데이터 물리적으로 전송

*데이터 링크 계층 (Datenübertragungsschicht)*

오류 감지 및 프레임 동기화를 사용합니다.

*네트워크 계층 (Network+ Schicht)*

라우팅을 관리합니다 (예: IP).

*전송 계층 (Transportschicht)*

신뢰할 수 있는 데이터 전송을 보장합니다 (예: TCP).

*응용 계층 (Anwendungsschicht)*

이메일(SMTP), 파일 전송(FTP), 웹 브라우징(HTTP)과 같은 서비스를 제공합니다.

계층형 아키텍처는 관심사 분리를 촉진하고, 유지보수성을 향상시키며, 개별 계층의 독립적인 개발을 가능하게 하여 이러한 특성을 중요하게 생각하는 모든 아키텍처에 이점을 제공합니다.

다계층 아키텍처는 *실현 가능성(feasibility)*이라는 아키텍처 특성을 달성하려는 팀에서도 매우 자주 사용됩니다. 즉, 주어진 시간 내에 주어진 범위 내에서 사용 가능한 리소스를 사용하여 실제로 구현할 수 있는가? 예를 들어, 회사가 투자자에 의해 주도되고 가능한 한 빨리 무언가를 제공해야 하는 경우, 계층형 아키텍처의 단순성은 나중에 다른 기능을 달성하기 위해 일부를 다시 작성해야 하더라도 종종 좋은 선택입니다.

<span id="page-25-0"></span>*비즈니스 델리게이트(Business Delegate)*는 비즈니스 서비스와 사용자 인터페이스 간의 결합을 줄이기 위한 패턴입니다. 비즈니스 델리게이트는 프레젠테이션 계층에서 비즈니스 객체를 호출하기 위한 어댑터 역할을 합니다. **[1](#page-7-0)**