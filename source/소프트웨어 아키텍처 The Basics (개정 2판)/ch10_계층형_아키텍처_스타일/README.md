# ch10 계층형 아키텍처 스타일

## 요약

**계층형 아키텍처(Layered Architecture)** 또는 **n계층 아키텍처(n-tiered Architecture)** 는 가장 널리 사용되는 아키텍처 스타일 중 하나로, 단순성, 친숙함, 낮은 초기 비용 덕분에 많은 레거시 애플리케이션의 사실상 표준으로 자리 잡았습니다. 이 아키텍처의 핵심 원칙은 구성 요소를 프레젠테이션, 비즈니스, 퍼시스턴스, 데이터베이스와 같은 논리적 수평 계층으로 구성하여 **'관심사를 분리(Separation of Concerns)'** 하는 것입니다. 각 계층은 명확히 정의된 역할을 수행합니다.

이 스타일의 주요 강점은 **단순성** 과 **낮은 초기 비용** 으로, 소규모 애플리케이션이나 예산과 시간이 제한된 프로젝트에 이상적인 출발점입니다. 그러나 시스템 규모가 커지면서 **모놀리식 구조** 의 한계가 드러납니다. 확장성, 탄력성, 내결함성이 매우 낮고, 작은 변경 사항 하나를 배포하기 위해 전체 애플리케이션을 재배포해야 하므로 배포 용이성과 유지보수성이 급격히 저하됩니다.

설계 시 핵심 고려 사항은 **'폐쇄형 계층(Closed Layers)'** 과 **'개방형 계층(Open Layers)'** 의 개념입니다. 폐쇄형 계층은 **계층 간 격리** 를 강화하여 안정성을 높이는 반면, 개방형 계층은 성능을 위해 유연성을 제공하지만 결합도를 높일 수 있습니다. 또한, 아무런 로직 없이 요청이 여러 계층을 통과하는 **'아키텍처 싱크홀(Architecture Sinkhole)'** 안티패턴은 성능 저하를 유발할 수 있으므로 주의해야 합니다.

![계층형 아키텍처 스타일 가이드](unnamed.png)

## 계층형 아키텍처의 기본 개념

### 정의 및 특징

**계층형 아키텍처** 는 구성 요소를 수평적 계층으로 구성하는 아키텍처 스타일로, 각 계층은 애플리케이션 내에서 특정 역할을 수행합니다. 이 스타일은 단순성과 낮은 비용 덕분에 매우 일반적이며, 때로는 명확한 아키텍처 설계 없이 개발을 시작할 때 자연스럽게 구현되는 **'우발적 아키텍처(Accidental Architecture)'** 가 되기도 합니다.

### 토폴로지 및 표준 계층

#### 논리적 계층

대부분의 계층형 아키텍처는 다음과 같은 **4개의 표준 논리적 계층** 으로 구성됩니다.

* **프레젠테이션 계층(Presentation layer)**: 모든 사용자 인터페이스 및 브라우저 통신 로직을 담당합니다.
* **비즈니스 계층(Business layer)**: 요청과 관련된 특정 비즈니스 규칙 실행을 담당합니다.
* **퍼시스턴스 계층(Persistence layer)**: 데이터베이스와의 상호작용 및 영속성 로직을 처리합니다.
* **데이터베이스 계층(Database layer)**: 실제 데이터가 저장되는 물리적 데이터베이스입니다.

애플리케이션의 특성에 따라 비즈니스 계층과 퍼시스턴스 계층을 결합하거나, 더 복잡한 시스템에서는 5개 이상의 계층을 포함할 수도 있습니다.

#### 물리적 배포

계층은 다음과 같은 여러 방식으로 물리적으로 배포될 수 있습니다.

1. **단일 배포 단위(DB 제외)**: 프레젠테이션, 비즈니스, 퍼시스턴스 계층이 하나의 배포 단위로 묶이고 데이터베이스는 외부에서 별도로 운영됩니다.
2. **분리된 프레젠테이션 계층**: 프레젠테이션 계층이 별도의 배포 단위로 분리되고, 비즈니스와 퍼시스턴스 계층이 또 다른 단위로 묶입니다. 데이터베이스는 여전히 외부에 존재합니다.
3. **완전 통합 배포 단위**: 모든 4개 계층이 하나의 배포 단위에 포함됩니다. 이 방식은 내장된 **인메모리 데이터베이스** 를 사용하는 소규모 모바일 애플리케이션이나 온프레미스 제품에 유용합니다.

## 핵심 원칙 및 설계 고려사항

### 관심사의 분리(Separation of Concerns)

계층형 아키텍처의 가장 큰 특징은 각 계층이 특정 책임 영역에만 집중한다는 것입니다. 예를 들어, 프레젠테이션 계층은 데이터가 어디서 오는지 신경 쓸 필요 없이 화면에 표시하는 방법에만 집중하고, 비즈니스 계층은 데이터 표시 방식이나 출처에 관계없이 비즈니스 로직을 처리하는 데만 집중합니다.

* **장점**: 명확한 역할과 책임 모델을 구축하기 용이하며, 개발자는 자신의 전문 분야(예: UI, 데이터베이스)에 집중할 수 있습니다.
* **단점**: 전체 시스템이 변화에 신속하게 대응하는 능력, 즉 **종합적인 민첩성(holistic agility)** 이 부족해집니다.

### 기술적 파티셔닝(Technical Partitioning)

계층형 아키텍처는 비즈니스 도메인이 아닌 **기술적 역할** (예: 프레젠테이션, 퍼시스턴스)에 따라 구성 요소를 분할합니다. 그 결과, '고객'과 같은 단일 **비즈니스 도메인** 이 모든 계층에 걸쳐 분산됩니다. 이는 해당 도메인과 관련된 변경 작업을 어렵게 만들며, **도메인 주도 설계(DDD)** 접근 방식과는 잘 맞지 않습니다.

### 계층 격리: 폐쇄형 vs. 개방형 계층

각 계층은 **'폐쇄형(closed)'** 또는 **'개방형(open)'** 으로 정의될 수 있으며, 이는 요청 흐름과 계층 간의 관계를 결정합니다.

* **폐쇄형 계층(Closed Layers)**: 요청은 상위 계층에서 하위 계층으로 이동할 때 반드시 바로 아래 계층을 통과해야 합니다. 계층을 건너뛰는 것이 허용되지 않습니다. 이 방식은 **계층 격리(layers of isolation)** 개념을 강화하여 한 계층의 변경이 다른 계층에 미치는 영향을 최소화합니다. 이로 인해 아키텍처는 덜 취약해지고 변경에 더 용이해집니다.
* **개방형 계층(Open Layers)**: 요청이 특정 계층을 우회하여 다른 계층으로 직접 전달될 수 있습니다. 예를 들어, 단순 데이터 조회를 위해 프레젠테이션 계층이 비즈니스 계층을 건너뛰고 데이터베이스에 직접 접근하는 경우 **Fast-Lane-Reader 패턴** 이 이에 해당합니다.
* **활용 사례**: 아키텍처적 제약 조건을 적용하기 위해 새로운 계층을 추가할 때 개방형 계층 개념이 유용할 수 있습니다. 예를 들어, 프레젠테이션 계층이 비즈니스 계층의 특정 공유 컴포넌트에 접근하는 것을 막기 위해 별도의 **'서비스 계층'** 을 추가할 수 있습니다. 이 경우, 비즈니스 계층이 퍼시스턴스 계층에 접근하기 위해 불필요하게 서비스 계층을 거치지 않도록 서비스 계층을 '개방형'으로 설정하여 우회할 수 있도록 허용합니다.

이러한 **개방형/폐쇄형 계층 규칙** 을 명확히 문서화하고 전달하지 않으면, 시스템은 긴밀하게 결합되고 취약해져 테스트, 유지보수, 배포가 어려워집니다.

## 주요 안티패턴 및 위험

### 아키텍처 싱크홀 안티패턴(Architecture Sinkhole Antipattern)

이는 요청이 별다른 비즈니스 로직을 수행하지 않은 채 여러 계층을 단순히 통과하는 현상을 말합니다. 예를 들어, 프레젠테이션 계층이 받은 단순 데이터 조회 요청이 비즈니스 계층과 퍼시스턴스 계층을 거치면서 아무런 추가 처리 없이 데이터베이스까지 전달되는 경우입니다. 이 패턴은 불필요한 **객체 생성과 처리** 를 유발하여 **메모리 사용량** 과 **성능** 에 악영향을 미칩니다.

* **판단 기준**: **80-20 규칙** 을 적용해볼 수 있습니다. 전체 요청의 20%가 싱크홀이라면 수용 가능하지만, 80%에 달한다면 계층형 아키텍처가 해당 문제 영역에 적합하지 않다는 신호일 수 있습니다.

### 공통된 위험

* **내결함성(Fault Tolerance)**: 모놀리식 구조로 인해 내결함성이 거의 없습니다. 시스템의 한 부분에서 메모리 부족과 같은 문제가 발생하면 전체 애플리케이션이 중단될 수 있습니다.
* **가용성(Availability)**: 대부분의 모놀리식 애플리케이션은 **평균 복구 시간(MTTR)** 이 깁니다. 작은 애플리케이션은 2분, 대규모 애플리케이션은 15분 이상 소요될 수 있어 전체적인 가용성이 저하됩니다.

## 아키텍처 특성 평가

다음 표는 계층형 아키텍처의 주요 특성을 **1성(매우 약함)** 부터 **5성(매우 강함)** 까지 평가한 것입니다.

아키텍처 특성	별점 평가
구조적 (Structural)	
전체 비용 (Overall cost)	$
파티셔닝 유형 (Partitioning type)	기술적 (Technical)
퀀텀 수 (Number of quanta)	1
단순성 (Simplicity)	⭐⭐⭐⭐⭐
모듈성 (Modularity)	⭐
엔지니어링 (Engineering)	
유지보수성 (Maintainability)	⭐
테스트 용이성 (Testability)	⭐⭐
배포 용이성 (Deployability)	⭐
진화성 (Evolvability)	⭐
운영 (Operational)	
응답성 (Responsiveness)	⭐⭐⭐
확장성 (Scalability)	⭐
탄력성 (Elasticity)	⭐
내결함성 (Fault tolerance)	⭐

### 평가 요약

* **강점**: **단순성(5점)** 과 **낮은 전체 비용($)** 이 가장 큰 장점입니다. 이해하고 구축하기 쉬워 초기 개발 비용이 상대적으로 저렴합니다.
* **약점**: 모듈성, 유지보수성, 배포 용이성, 진화성, 확장성, 탄력성, 내결함성이 모두 1점으로 매우 낮게 평가됩니다. 이는 **모놀리식 구현** 과 아키텍처의 **모듈성 부족** 에 기인합니다.
* **배포 용이성(1점)**: 단 세 줄의 코드 변경을 위해 전체 배포 단위를 재배포해야 하므로 위험이 높고 배포 빈도가 낮아집니다.
* **테스트 용이성(2점)**: 전체 회귀 테스트가 어렵지만, 특정 계층이나 컴포넌트를 **모의(mock)** 또는 **스텁(stub)** 처리하여 테스트를 용이하게 할 수 있어 1점이 아닌 2점을 받았습니다.

## 거버넌스 및 팀 토폴로지

### 거버넌스

계층형 아키텍처는 널리 퍼져 있어 거버넌스가 용이합니다. **ArchUnit** 과 같은 **피트니스 함수 라이브러리** 는 계층 간의 통신 규칙(예: Controller는 Service만 호출 가능)을 코드로 정의하고 자동으로 검증할 수 있도록 강력하게 지원합니다.

### 팀 토폴로지

이 아키텍처는 **기술적 분리 특성** 덕분에 다양한 팀 토폴로지와 잘 작동합니다.

* **스트림 정렬 팀(Stream-Aligned Team)**: 시스템의 단일 흐름을 책임지는 팀에 적합합니다.
* **지원 팀(Enabling Team)**: 전문가들이 특정 계층(예: UI)에 대한 개선 실험을 다른 계층에 영향을 주지 않고 수행할 수 있습니다.
* **복잡한 하위 시스템 팀(Complicated Subsystem Team)**: 분석 팀이 다른 계층에 영향을 주지 않고 퍼시스턴스 계층에 접근하여 운영 데이터를 활용할 수 있습니다.
* **플랫폼 팀(Platform Team)**: 모듈성을 활용하여 시스템을 관리할 수 있지만, 시스템이 성장함에 따라 모놀리스가 점점 다루기 어려워지는 공통적인 문제에 직면합니다.

## 적용 사례 및 사용 지침

### 사용 시기

* 작고 간단한 애플리케이션 또는 웹사이트 개발 시
* 예산과 시간이 매우 제한적인 상황
* 보다 복잡한 아키텍처를 도입하기 전의 초기 개발 단계에서 좋은 출발점으로 활용

### 사용하지 말아야 할 시기

* 대규모 애플리케이션 및 시스템 개발 시. 시스템이 성장함에 따라 유지보수성, 민첩성, 테스트 용이성 등의 특성이 급격히 악화되므로 더 모듈화된 다른 아키텍처를 고려해야 합니다.

### 실제 예시

* **운영 체제(OS)**: 하드웨어, 커널, 시스템 콜 인터페이스, 사용자 계층으로 구성되어 관심사를 분리합니다.
* **OSI 모델 / TCP/IP**: 물리, 데이터 링크, 네트워크, 전송, 애플리케이션 계층으로 네트워크 책임을 분리하여 통신을 관리합니다. 이처럼 관심사 분리, 유지보수성 향상, 독립적인 개발이 중요한 모든 시스템에서 계층형 아키텍처는 유용하게 활용될 수 있습니다.
