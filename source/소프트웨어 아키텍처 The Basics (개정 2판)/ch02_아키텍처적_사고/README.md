# ch02 아키텍처적 사고

## 요약

본 브리핑 문서는 소프트웨어 아키텍트의 핵심 역량인 '건축적 사고방식'의 주요 개념과 실행 기법을 종합적으로 분석합니다. 건축적 사고방식은 개별 기술 구현을 넘어 시스템의 전체 구조, 확장성, 구성 요소 간의 상호작용을 고려하는 능력입니다.

핵심적으로, 아키텍처는 변경 비용이 크고 장기적인 영향을 미치는 '전략적' 결정인 반면, 디자인은 비교적 변경이 용이하고 단기적인 '전술적' 결정에 가깝습니다. 이 둘은 명확히 구분되기보다 하나의 스펙트럼 위에 존재합니다. 아키텍트는 특정 기술에 대한 깊이 있는 지식(Technical Depth)보다는 다양한 솔루션과 기술에 대한 폭넓은 지식(Technical Breadth)을 갖추는 것이 더 중요합니다. 이는 '지식의 피라미드' 모델을 통해 설명되며, 아키텍트는 자신이 모른다는 사실조차 몰랐던 지식을 인지하는 단계로 전환시키는 데 주력해야 합니다.

이러한 기술적 폭을 넓히기 위한 구체적인 방법론으로 '20분 규칙'과 개인 '기술 레이더' 개발이 제시됩니다. 또한, 아키텍처의 본질은 정답이 없는 '트레이드오프'를 분석하고 주어진 비즈니스 상황과 제약 조건 내에서 최적의 결정을 내리는 데 있습니다. 마지막으로, 아키텍트는 실무 코딩과의 균형을 유지하며 '병목 함정'을 피해야 하며, 이를 위해 개념 증명(POC), 기술 부채 해결, 코드 리뷰 등 다양한 활동에 참여할 것이 권장됩니다.

아래 시각 자료는 건축적 사고의 핵심 메시지를 한눈에 보여줍니다. 아키텍처는 구조, 디자인은 외형이라는 대비, 개발자의 기술적 깊이와 아키텍트의 기술적 폭, 그리고 매일 20분 학습과 개인 기술 레이더를 통한 지속적인 역량 확장을 강조하고 있습니다.

![아키텍트처럼 생각하기 인포그래픽: 구조와 외형의 대비, 깊이와 넓이, 20분 규칙, 개인 기술 레이더](info-graph.png)


---

## 1. 건축적 사고방식의 정의

건축적 사고방식이란 사물을 아키텍트의 눈, 즉 아키텍처의 관점에서 바라보는 것을 의미합니다. 이는 다음과 같은 활동을 포함합니다.

* 특정 변경 사항이 시스템의 전반적인 확장성에 미치는 영향을 이해하는 것.
* 시스템의 여러 부분이 어떻게 상호 작용하는지에 주의를 기울이는 것.
* 주어진 상황에 가장 적합한 서드파티 라이브러리 및 프레임워크를 파악하는 것.

아키텍트처럼 생각하기 위해서는 소프트웨어 아키텍처의 본질과 디자인과의 차이점을 이해하고, 비즈니스 요인을 아키텍처 관심사로 변환하며, 다양한 솔루션과 기술 간의 트레이드오프를 분석하고 조화시키는 능력이 필수적입니다.

## 2. 아키텍처 대 디자인: 스펙트럼의 이해

소프트웨어 아키텍처는 시스템의 외형보다는 구조에, 디자인은 구조보다는 외형과 느낌에 더 중점을 둡니다. 예를 들어 마이크로서비스 아키텍처를 채택하는 결정은 시스템의 구조를 정의하므로 아키텍처에 해당하고, 사용자 인터페이스(UI)의 외형과 작동 방식은 디자인에 해당합니다.

그러나 대부분의 결정은 아키텍처와 디자인 사이의 스펙트럼 어딘가에 위치합니다. 어떤 결정이 스펙트럼의 어느 쪽에 더 가까운지 판단하기 위해 다음 세 가지 기준을 사용할 수 있습니다.

### 2.1. 전략적 결정 대 전술적 결정

결정이 전략적일수록 아키텍처에 가깝고, 전술적일수록 디자인에 가깝습니다. 전략적 결정은 장기적인 반면, 전술적 결정은 단기적이고 독립적인 경향이 있습니다.

* 고려와 계획의 양: 몇 주간의 계획이 필요하다면 전략적(아키텍처), 몇 분 만에 내릴 수 있다면 전술적(디자인)입니다.
* 관련 인원의 수: 여러 이해관계자와의 수많은 회의가 필요하다면 전략적(아키텍처), 혼자 또는 동료와 결정할 수 있다면 전술적(디자인)입니다.
* 결정의 지속성: 오랫동안 유지될 결정은 전략적(아키텍처), 곧 변경될 가능성이 있는 결정은 전술적(디자인)입니다.

### 2.2. 노력의 정도

소프트웨어 아키텍트 마틴 파울러(Martin Fowler)는 아키텍처를 "변경하기 어려운 것"이라고 정의했습니다. 무언가를 변경하는 데 더 많은 노력이 필요할수록 그 결정은 아키텍처 쪽에 가깝습니다.

* 아키텍처 예시: 모놀리식 계층형 아키텍처에서 마이크로서비스로 전환하는 것은 막대한 노력이 필요합니다.
* 디자인 예시: 화면의 필드 순서를 재배치하는 것은 최소한의 노력만 필요합니다.

### 2.3. 트레이드오프의 중요성

결정에 따른 트레이드오프가 중대할수록 아키텍처적 결정에 가깝습니다.

* 아키텍처 예시: 마이크로서비스 아키텍처는 확장성, 유연성, 탄력성을 제공하지만 복잡성, 비용, 데이터 일관성 저하, 성능 문제와 같은 중대한 트레이드오프를 수반합니다.
* 디자인 예시: 클래스 파일을 분리하면 유지보수성과 가독성이 향상되지만, 더 많은 클래스를 관리해야 하는 비교적 사소한 트레이드오프가 발생합니다.

## 3. 기술적 폭: 아키텍트의 핵심 역량

개발자는 특정 기술에 대한 깊이 있는 지식(Technical Depth)이 요구되는 반면, 소프트웨어 아키텍트는 폭넓은 기술적 지식(Technical Breadth)을 갖추어야 합니다.

### 3.1. 지식의 피라미드

모든 기술 지식은 세 가지 단계로 나눌 수 있습니다.



1. 아는 것 (Stuff you know): 전문성을 갖춘 기술, 프레임워크, 언어. 피라미드의 가장 작은 최상단 부분.
2. 모른다는 것을 아는 것 (Stuff you know you don't know): 들어는 봤지만 경험이나 전문성이 없는 것들. 피라미드의 중간 부분.
3. 모른다는 것조차 모르는 것 (Stuff you don't know you don't know): 존재 자체를 알지 못해 문제 해결에 활용하지 못하는 솔루션들. 피라미드의 가장 큰 하단 부분.

모든 기술인의 커리어 목표는 하단(3단계)의 지식을 중간(2단계)으로, 필요에 따라 중간(2단계)의 지식을 상단(1단계)으로 이동시키는 것입니다.

### 3.2. 아키텍트의 지식 구조 변화

개발자는 피라미드의 상단, 즉 기술적 깊이를 넓히고 유지하는 데 집중합니다. 반면 아키텍트로 전환하면 관점이 바뀝니다. 아키텍트의 가치는 다양한 기술을 폭넓게 이해하고 문제 해결에 적용하는 능력에서 나옵니다. 따라서 아키텍트에게는 깊이보다 폭이 더 중요합니다.



이러한 전환에 실패하면 다음과 같은 문제가 발생할 수 있습니다.

* 너무 많은 분야에서 전문성을 유지하려다 모두 실패하고 번아웃에 빠집니다.
* 과거의 낡은 지식이 여전히 최신이라고 착각하는 '오래된 전문 지식' 문제를 겪습니다.

이는 과거의 나쁜 결정이나 예상치 못한 사건으로 인해 특정 아키텍처 특징에 비이성적으로 집착하는 아키텍트의 행동 패턴을 말합니다. 예를 들어, 몇 년 전 이탈리아 지사와의 통신 장애를 겪은 아키텍트가 모든 설계 검토에서 "만약 이탈리아를 잃으면 어떻게 하죠?"라고 반복해서 묻는 것입니다. 아키텍트적 사고는 이러한 고정관념을 극복하고 더 현실적인 위험 평가를 통해 다양한 솔루션을 모색하는 것을 요구합니다.

## 4. 기술적 폭을 넓히기 위한 기법

### 4.1. 20분 규칙

하루에 최소 20분을 새로운 것을 배우거나 특정 주제를 탐구하는 데 투자하는 기법입니다.

* 권장 시간: 방해 요소가 적고 정신이 맑은 아침 시간, 특히 이메일을 확인하기 전.
* 활용 자료: InfoQ, DZone Refcardz, Thoughtworks Technology Radar 등.
* 목표: '모른다는 것조차 모르는' 지식을 '모른다는 것을 아는' 영역으로 꾸준히 옮기는 것.

### 4.2. 개인 기술 레이더 개발

기술 레이더는 기존 기술과 신기술의 위험과 기회를 평가하는 데 도움이 되는 살아있는 문서입니다. 이는 기술 포트폴리오를 체계적으로 관리하고 다각화하는 데 효과적입니다.

* 구성:
  * 4개의 사분면(Quadrants): 도구(Tools), 언어 및 프레임워크(Languages & Frameworks), 기법(Techniques), 플랫폼(Platforms).
  * 4개의 링(Rings):
    * 채택 (Adopt): 업계에서 적극적으로 사용해야 한다고 확신하는 기술.
    * 시험 (Trial): 리스크가 낮은 프로젝트에 적용해 볼 가치가 있는 기술.
    * 평가 (Assess): 기업에 미칠 영향을 파악하기 위해 탐색해 볼 가치가 있는 기술.
    * 보류 (Hold): 새로운 프로젝트에 도입하는 것을 재고해야 하는 기술. 개인 레이더에서는 버리고 싶은 나쁜 습관도 포함할 수 있습니다.



개인 기술 레이더를 만드는 행위 자체가 자신의 기술 포트폴리오에 대해 깊이 생각할 시간을 갖게 해주며, 이는 시각화된 결과물보다 더 중요합니다. Thoughtworks에서 제공하는 'Build Your Own Radar' 도구를 활용할 수 있습니다.

## 5. 트레이드오프 분석: 아키텍처의 본질

아키텍처의 모든 것은 트레이드오프입니다. 아키텍처에 관한 모든 질문에 대한 답이 "상황에 따라 다릅니다(It depends)"인 이유입니다.

"아키텍처는 구글 검색이나 LLM에 질문해서 답을 얻을 수 없는 것이다." — 마크 리처즈 (Mark Richards)

"아키텍처에는 정답이나 오답이 없고, 오직 트레이드오프만 있을 뿐이다." — 닐 포드 (Neal Ford)

### 5.1. 사례 연구: 경매 시스템의 메시징

온라인 경매 시스템에서 입찰 정보를 Bid Capture, Bid Tracking, Bid Analytics 서비스로 비동기적으로 전달해야 하는 상황을 가정해 봅시다.



두 가지 선택지가 있습니다: 토픽(Topic)을 사용하는 발행-구독(Publish-Subscribe) 방식과 큐(Queue)를 사용하는 점대점(Point-to-Point) 방식.

솔루션	장점	단점
토픽 (Topic)	아키텍처 확장성: 새로운 구독자(서비스) 추가 시 기존 인프라 변경 불필요.<br>서비스 비결합: 생산자는 소비자가 누구인지, 정보를 어떻게 사용하는지 알 필요 없음.	데이터 보안 우려: 토픽에 접근 권한이 있는 누구나 데이터를 볼 수 있음.<br>이종 계약 불가: 모든 구독자는 동일한 데이터 계약을 사용해야 함.<br>모니터링 및 확장성: 개별적인 모니터링 및 자동 확장이 어려움.
큐 (Queue)	보안: 메시지는 특정 소비자만 수신하므로 데이터 접근 제어가 용이함.<br>이종 계약 가능: 각 소비자는 자신에게 맞는 맞춤형 데이터 계약을 가질 수 있음.<br>모니터링 및 확장성: 각 큐를 개별적으로 모니터링하고 자동 확장 적용 가능.	확장성 저하: 새로운 소비자 추가 시 생산자 코드 및 인프라 변경 필요.<br>서비스 결합도 증가: 생산자는 소비자가 누구인지 정확히 알아야 함.

"프로그래머는 모든 것의 장점은 알지만 트레이드오프는 모른다. 아키텍트는 둘 다 이해해야 한다." — 리치 히키 (Rich Hickey)

이처럼 아키텍트는 단순히 장점만을 보는 것이 아니라, 양쪽의 장단점(트레이드오프)을 모두 분석하고 "확장성이 더 중요한가, 보안이 더 중요한가?"와 같은 질문을 통해 주어진 상황에 최적인(또는 차악의) 결정을 내려야 합니다.

## 6. 실무 코딩과의 균형 유지

모든 아키텍트는 코딩을 지속하며 일정 수준의 기술적 깊이를 유지해야 합니다. 그러나 이 과정에서 **'병목 함정(Bottleneck Trap)'** 을 피하는 것이 중요합니다. 이는 아키텍트가 시스템의 핵심 경로 코드를 직접 책임지면서 팀 전체의 걸림돌이 되는 현상입니다.

### 병목 함정을 피하고 코딩을 지속하는 방법

1. 핵심 경로 코드 위임: 시스템의 중요 부분은 개발팀에 위임하고, 아키텍트는 이후 이터레이션에서 더 작은 비즈니스 기능 구현에 참여합니다. 이는 아키텍트의 실무 경험 축적, 팀의 책임감 및 이해도 향상, 개발팀과의 공감대 형성이라는 긍정적 효과를 낳습니다.
2. 개념 증명(Proof-of-Concept, POC) 수행: POC를 통해 소스 코드를 작성하고 아키텍처 결정을 검증합니다. 이때 작성하는 코드는 "버리는 코드"가 아니라, 참조 아키텍처가 될 수 있으므로 가능한 한 프로덕션 수준의 품질로 작성하는 것이 좋습니다.
3. 기술 부채 해결: 개발팀이 주요 기능 개발에 집중할 수 있도록 아키텍트가 기술 부채 관련 작업을 처리합니다.
4. 버그 수정: 버그 수정에 참여하며 코드베이스의 문제점과 취약점을 파악합니다.
5. 자동화 도구 개발: 개발팀의 반복적인 작업을 자동화하는 커맨드 라인 도구나 분석 스크립트를 개발합니다. 아키텍처 준수 여부를 검증하는 피트니스 함수(Fitness Function) 작성도 좋은 방법입니다.
6. 코드 리뷰 수행: 직접 코드를 작성하지 않더라도, 코드 리뷰를 통해 소스 코드에 대한 관여를 유지하고 아키텍처 준수 여부를 확인하며 팀원들을 멘토링할 기회를 가집니다.
