# 마이크로커널 아키텍처 스타일 브리핑

## 요약

마이크로커널 아키텍처(플러그인 아키텍처라고도 함)는 핵심 기능을 담당하는 **코어 시스템(Core System)**과 특정 처리 로직, 추가 기능, 사용자 정의 코드를 포함하는 독립적인 **플러그인 컴포넌트(Plug-in Component)**라는 두 가지 주요 요소로 구성된 모놀리식 아키텍처 스타일입니다. 이 구조의 핵심 철학은 시스템의 최소 기능만을 코어 시스템에 남겨 안정적으로 유지하고, 자주 변경되거나 특화된 로직은 플러그인으로 분리하여 격리하는 것입니다.

이 아키텍처는 다운로드하여 설치하는 제품 기반 애플리케이션(예: Eclipse IDE, Jira)에 특히 적합하며, 각 지역이나 상황에 따라 다른 규칙과 로직이 필요한 비즈니스 애플리케이션(예: 보험 청구, 세금 계산)에도 효과적으로 사용됩니다. 독립적인 플러그인 덕분에 확장성, 유지보수성, 테스트 용이성, 배포 용이성에서 높은 점수를 받습니다.

하지만 일반적으로 모놀리식으로 구현되므로 전체적인 확장성, 탄력성, 내결함성에는 약점을 보입니다. 이는 모든 요청이 플러그인에 도달하기 전에 코어 시스템을 거쳐야 하는 단일 아키텍처 퀀텀(Quantum)을 갖기 때문입니다.

![마이크로커널 아키텍처 한눈에 보기](unnamed.png)

--------------------------------------------------------------------------------


## 1. 마이크로커널 아키텍처 개요

**마이크로커널 아키텍처 스타일**은 수십 년 전에 개발되었지만 오늘날에도 널리 사용되는 구조입니다. **애플리케이션 로직**을 핵심적인 **코어 시스템**과 독립적인 **플러그인 컴포넌트**로 분리하여 **확장성, 적응성, 유지보수성**을 높이는 것이 특징입니다.

* 주요 적용 분야:
  * **제품 기반 애플리케이션**: 다운로드하여 고객사에 설치되는 단일 **모놀리식 패키지** 형태의 소프트웨어.
  * **사용자 정의가 필요한 비즈니스 애플리케이션**: 각 주마다 다른 규정을 가진 미국 보험 회사나, 국가별로 법적 및 물류적 변형을 준수해야 하는 국제 배송 회사와 같은 문제 영역에 유용합니다.
* **기본 토폴로지**: 아키텍처는 중앙의 코어 시스템과 이를 둘러싼 다수의 플러그인 컴포넌트로 구성된 비교적 간단한 **모놀리식 구조**를 가집니다.
*  기본 마이크로커널 아키텍처 스타일의 구성 요소

## 2. 핵심 구성 요소

마이크로커널 아키텍처는 코어 시스템과 플러그인 컴포넌트라는 두 가지 유형의 요소로 이루어집니다.

### 2.1. 코어 시스템 (Core System)

* 정의 및 역할:
  1. **최소 기능 집합**: 시스템을 운영하는 데 필요한 최소한의 기능으로 정의됩니다. 예를 들어, Eclipse IDE의 코어 시스템은 파일을 열고, 텍스트를 수정하고, 저장하는 단순한 텍스트 편집기 기능뿐입니다. 유용한 제품이 되려면 플러그인을 추가해야 합니다.
  2. **해피 패스(Happy Path)**: 사용자 정의 처리가 거의 또는 전혀 없는 애플리케이션의 일반적인 처리 흐름으로 정의되기도 합니다. **순환 복잡성**이 높은 코드를 코어에서 분리하여 플러그인에 배치합니다.
* **구현 변형**: 코어 시스템의 크기와 복잡성에 따라 다음과 같은 방식으로 구현될 수 있습니다.
  * **계층형 코어 시스템** (기술적 분할): 프레젠테이션, 비즈니스, 영속성 계층으로 구성됩니다.
  * **모듈형 코어 시스템** (도메인 분할): 여러 도메인 컴포넌트로 구성됩니다.
  * **프레젠테이션 계층**: 코어 시스템에 내장되거나(단일 배포), 코어 시스템이 백엔드 서비스를 제공하는 별도의 사용자 인터페이스(다중 배포)로 구현될 수 있습니다.

### 2.2. 플러그인 컴포넌트 (Plug-in Components)

* 정의 및 역할:
  * 코어 시스템을 향상시키거나 확장하기 위한 **특수 처리, 추가 기능, 사용자 정의 코드**를 포함하는 **독립적인 컴포넌트**입니다.
  * **변동성이 높은 코드**를 격리하여 애플리케이션 내 **유지보수성**과 **테스트 용이성**을 향상시킵니다.
  * 이상적으로 플러그인 컴포넌트 간에는 서로 **의존성이 없어야** 합니다.
* **통신 및 구현**:
  * **점대점(Point-to-Point) 통신**: 일반적으로 플러그인과 코어 시스템 간의 통신은 메소드나 함수 호출을 통해 이루어집니다.
    * **컴파일 기반**: 변경, 제거 또는 추가 시 전체 애플리케이션을 재배포해야 합니다.
    * **런타임 기반**: OSGi(Java), Prism(.NET)과 같은 프레임워크를 사용하여 런타임에 추가하거나 제거할 수 있습니다.
  * **구현 방법**:
    * **공유 라이브러리**: JAR, DLL, Gem 파일과 같은 공유 라이브러리로 구현됩니다.
    * **패키지/네임스페이스**: 동일한 코드베이스 내에서 app.plugin.<도메인>.<컨텍스트>와 같은 명명 규칙을 사용하여 패키지나 네임스페이스로 구현됩니다.
  * **원격 접근(Remote Access)**: REST나 메시징을 사용하여 플러그인 기능을 호출할 수도 있습니다. 이 경우 각 플러그인은 **독립적인 서비스**가 됩니다.
    * 장점: 컴포넌트 간 **디커플링** 향상, **확장성** 및 **처리량** 증가, **비동기 통신** 가능.
    * 단점: **분산 아키텍처**가 되어 구현 및 배포가 복잡해지고, 원격 플러그인이 응답하지 않을 경우 요청이 실패할 위험이 있습니다.

## 3. 주요 개념 및 고려사항

### 3.1. "마이크로커널성" 스펙트럼

모든 플러그인 지원 시스템이 마이크로커널은 아니지만, 모든 마이크로커널은 플러그인을 지원합니다. **"마이크로커널성"의 정도**는 코어 시스템에 얼마나 많은 독립적인 기능이 포함되어 있는지에 따라 결정됩니다.

* **순수 마이크로커널**: Eclipse IDE나 Linter 도구처럼 코어 기능이 매우 적어 플러그인 없이는 거의 쓸모가 없습니다.
* **기능적 시스템**: 웹 브라우저는 플러그인을 지원하지만, 플러그인 없이도 완전히 기능합니다.

**코어의 변동성**을 파악하는 것은 아키텍트가 순수 마이크로커널과 단순히 플러그인을 지원하는 시스템 사이에서 결정하는 데 도움이 됩니다.

### 3.2. 레지스트리 (Registry)

코어 시스템은 어떤 플러그인 모듈이 사용 가능하며 어떻게 접근할 수 있는지 알아야 합니다. 이를 위해 **플러그인 레지스트리**를 사용합니다.

* 내용: 각 플러그인 모듈의 **이름, 데이터 계약, 원격 접근 프로토콜** 등의 정보를 포함합니다.
* 구현: 간단한 내부 **맵(Map) 구조**부터 Apache ZooKeeper나 Consul과 같은 **외부 레지스트리 및 검색 도구**까지 다양합니다.

### 3.3. 계약 (Contracts)

플러그인과 코어 시스템 간의 **계약**은 일반적으로 **동작, 입력 데이터, 출력 데이터**를 포함하며, 플러그인 도메인 내에서 **표준화**됩니다. 제3자가 개발한 플러그인의 경우, 코어 시스템이 각기 다른 계약을 처리하지 않도록 **어댑터(Adapter)**를 사용하는 것이 일반적입니다.

### 3.4. 데이터 토폴로지

* 일반적으로 **단일 중앙 공유 데이터베이스**(주로 관계형)를 사용하는 모놀리식 아키텍처로 구현됩니다.
* 플러그인은 중앙 데이터베이스에 직접 연결하지 않습니다. 대신 **코어 시스템이 데이터 접근을 처리**하고 필요한 데이터를 플러그인에 전달하여 **디커플링을 유지**합니다.
* 플러그인은 자체적인 **별도의 데이터 저장소**(예: 자체 데이터베이스 또는 규칙 엔진)를 소유할 수 있습니다.

## 4. 리스크 및 거버넌스

### 4.1. 공통 리스크

이 아키텍처와 관련된 일반적인 리스크는 주로 **잘못된 적용**에서 비롯됩니다.

* **변동성이 큰 코어(Volatile Core)**: 마이크로커널의 코어는 초기 개발 후 가능한 한 **안정적으로 유지**되어야 합니다. 코어가 지속적으로 변경된다면, 변경 사항을 플러그인에 격리한다는 아키텍처의 철학이 훼손됩니다.
* **플러그인 의존성(Plug-in Dependencies)**: 마이크로커널은 플러그인이 서로가 아닌 **코어 시스템과만 통신**할 때 가장 잘 작동합니다. 플러그인 간의 의존성은 **전이적 의존성 충돌**을 해결해야 하는 복잡성을 야기하므로 가능한 한 피해야 합니다.

### 4.2. 거버넌스

마이크로커널 아키텍처의 거버넌스는 아키텍트가 아키텍처의 철학을 얼마나 잘 준수하는지 확인하는 데 중점을 둡니다. 주요 검사 항목은 다음과 같습니다.

* 코어의 변동성 검사
* 코어의 변경률
* 계약 테스트
* 토폴로지에 대한 기타 구조적 검사

## 5. 아키텍처 특성 평가

다음 표는 마이크로커널 아키텍처 스타일의 특성을 1~5개의 별점으로 평가한 것입니다.

아키텍처 특성	별점 평가
전체 비용	$
구조적 (Structural)	
분할 유형	도메인 및 기술적
퀀텀 수	1
단순성	⭐⭐⭐⭐⭐
모듈성	⭐⭐⭐⭐
엔지니어링 (Engineering)	
유지보수성	⭐⭐⭐⭐
테스트 용이성	⭐⭐⭐
배포 용이성	⭐⭐⭐
진화 가능성	⭐⭐⭐
운영 (Operational)	
응답성	⭐⭐⭐⭐
확장성	⭐
탄력성	⭐
내결함성	⭐

* **강점**: **단순성**과 **전체 비용**이 주요 강점입니다. 기능이 독립적인 플러그인에 격리되므로 **모듈성, 유지보수성, 진화 가능성**도 평균 이상입니다. 불필요한 기능을 제거하여 애플리케이션을 최적화할 수 있어 **응답성**도 좋습니다.
* **약점**: 모놀리식 구현으로 인해 **확장성, 탄력성, 내결함성**은 주요 약점입니다. **아키텍처 퀀텀**이 항상 1이라는 점이 이를 뒷받침합니다.
* **고유성**: **도메인 분할**과 **기술적 분할**을 모두 지원하는 유일한 아키텍처 스타일입니다.

## 6. 적용 사례

* **소프트웨어 개발 및 게시 도구**: Eclipse IDE, PMD, Jira, Jenkins 등.
* **인터넷 브라우저**: Chrome, Firefox 등은 기본 브라우저(코어 시스템)에 포함되지 않은 추가 기능을 플러그인으로 추가합니다.
* **대규모 비즈니스 애플리케이션**:
  * **세금 신고 소프트웨어**: 요약 세금 양식(예: 미국 1040 양식)이 코어 시스템 역할을 하고, 각 추가 양식 및 작업표가 플러그인 컴포넌트로 구현될 수 있습니다. 이를 통해 세법 변경 시 관련 플러그인만 수정하면 되므로 변경이 용이하고 위험이 적습니다.
  * **보험금 청구 처리**: 표준 청구 처리 절차를 코어 시스템으로 두고, 각 관할권(국가, 주)의 복잡한 규칙을 별도의 플러그인 컴포넌트로 구현할 수 있습니다. 이는 거대한 **규칙 엔진(Rules Engine)**이 복잡한 의존성 덩어리가 되는 것을 방지하고, 특정 관할권의 규칙을 다른 시스템 부분에 영향을 주지 않고 추가, 제거, 변경할 수 있게 합니다.
