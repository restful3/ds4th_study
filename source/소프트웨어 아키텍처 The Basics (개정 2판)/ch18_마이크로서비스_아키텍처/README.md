마이크로서비스 아키텍처: 핵심 브리핑

Executive Summary

마이크로서비스 아키텍처는 최근 몇 년간 큰 인기를 얻은 분산 아키텍처 스타일로, 시스템을 독립적으로 배포 가능한 작은 서비스들의 집합으로 구성하는 데 중점을 둡니다. 이 아키텍처의 핵심 철학은 도메인 주도 설계(DDD)의 '경계 컨텍스트(Bounded Context)' 개념에서 영감을 받은 극단적인 분리(decoupling)입니다. 이는 각 서비스가 자체 코드, 데이터 스키마, 데이터베이스를 포함하여 특정 비즈니스 기능을 수행하는 데 필요한 모든 것을 소유하는 "아무것도 공유하지 않는(Share Nothing)" 접근 방식을 지향합니다.

이 스타일의 기본 토폴로지에는 클라이언트 요청을 처리하는 API 계층과 독립적으로 실행되는 여러 서비스가 포함되며, 각 서비스는 자체 데이터베이스를 가집니다. 이러한 구조는 공유 인프라 문제를 해결하고 높은 수준의 모듈성, 유지보수성, 테스트 용이성, 배포 용이성 및 확장성을 제공합니다. 특히, 각 서비스를 독립적으로 개발, 배포, 확장할 수 있어 진화적 변경을 지원하고 장애 격리를 통해 시스템 전체의 내결함성을 향상시킵니다.

그러나 마이크로서비스는 서비스 간 네트워크 통신으로 인한 성능 저하, 분산 트랜잭션 관리의 복잡성(사가 패턴 필요), 서비스 세분성 결정의 어려움과 같은 고유한 과제를 안고 있습니다. 서비스가 너무 작아지면("모래알" 안티패턴) 서비스 간 통신이 과도해져 분산된 거대한 진흙 덩어리(big ball of mud)가 될 수 있습니다. 운영상의 공통 관심사(모니터링, 로깅 등)는 사이드카(Sidecar) 패턴과 서비스 메시(Service Mesh)를 통해 해결하며, 이는 도메인 로직과 운영 로직을 분리하는 데 기여합니다.

결론적으로, 마이크로서비스는 기능적 모듈성이 높은 시스템에 적합하며, 올바르게 구현될 경우 비즈니스 민첩성과 기술적 유연성을 극대화할 수 있습니다. 하지만 그 복잡성으로 인해 신중한 설계, 거버넌스, 그리고 도메인 중심의 팀 구조가 성공의 필수 요건입니다.


--------------------------------------------------------------------------------


1. 마이크로서비스 아키텍처 개요

1.1. 정의 및 철학

마이크로서비스는 2014년 Martin Fowler와 James Lewis에 의해 널리 알려진 아키텍처 스타일입니다. 이 스타일의 핵심은 소프트웨어 개발 생태계의 변화에 대응하여 등장했으며, 특히 도메인 주도 설계(Domain-Driven Design, DDD)의 개념에 깊이 영향을 받았습니다.

DDD의 핵심 개념 중 하나인 **경계 컨텍스트(Bounded Context)**는 마이크로서비스의 철학적 기반을 형성합니다. 경계 컨텍스트는 코드 및 데이터 스키마와 같은 내부 구성 요소는 서로 결합될 수 있지만, 다른 경계 컨텍스트의 데이터베이스나 클래스 정의와는 절대 결합되지 않는 분리 스타일을 의미합니다. 이로 인해 마이크로서비스는 "아무것도 공유하지 않는(Share Nothing)" 아키텍처로 불립니다.

전통적인 모놀리식 아키텍처에서는 재사용 가능한 클래스와 연결된 데이터베이스를 통해 여러 개념을 공유하는 것이 일반적입니다. 그러나 재사용성은 시스템의 결합도를 높이는 단점이 있습니다. 마이크로서비스의 주요 목표는 높은 수준의 분리된 시스템을 구축하는 것이므로, 결합을 유발하는 재사용보다 코드의 중복을 선호합니다. 아키텍트는 경계 컨텍스트라는 논리적 개념을 서비스와 관련 데이터를 포함하는 물리적 모델로 구현합니다.

1.2. 기본 토폴로지

마이크로서비스의 기본 토폴로지는 클라이언트의 요청이 API 계층(API Layer)을 통과하여 여러 개의 독립적인 서비스로 전달되는 구조를 가집니다. 각 서비스는 자체 모듈과 전용 데이터베이스를 포함하며, 독립적인 프로세스(가상 머신 또는 컨테이너)에서 실행됩니다.

이러한 분산 아키텍처는 각 서비스가 자체 데이터베이스를 포함한 모든 종속 구성 요소를 소유하여 독립적으로 작동하도록 설계되었습니다. 이는 다중 테넌트 인프라에서 발생하는 자원 고갈이나 애플리케이션 간 부적절한 격리 문제를 해결합니다. 클라우드 리소스와 컨테이너 기술의 발전으로 각 도메인이 자체 인프라를 소유하는 극단적인 분리가 실용적이게 되었습니다.

그러나 이러한 분산된 특성은 성능 면에서 단점을 가집니다. 네트워크 호출은 인-프로세스(in-process) 메서드 호출보다 훨씬 오래 걸리며, 각 엔드포인트에서의 보안 검사는 추가 처리 시간을 유발합니다. 따라서 아키텍트는 서비스의 세분성이 성능에 미치는 영향을 신중하게 고려해야 합니다. 또한, 서비스 경계를 넘나드는 트랜잭션은 사용하지 않는 것이 좋습니다.

2. 핵심 특성 및 개념

2.1. 경계 컨텍스트 (Bounded Context)

경계 컨텍스트는 마이크로서비스의 추진 철학입니다. 각 서비스는 특정 기능, 하위 도메인 또는 워크플로우를 모델링하며, 해당 기능을 실행하는 데 필요한 모든 것(논리적 컴포넌트, 클래스, 데이터베이스 스키마 및 데이터베이스)을 포함합니다. 이 철학은 결합을 피하기 위해 Address와 같은 공통 클래스를 공유하는 대신, 각 서비스의 경계 컨텍스트 내에 코드를 중복하여 유지하는 결정을 내리게 합니다.

2.2. 서비스 세분성 (Granularity)

아키텍트가 직면하는 가장 큰 어려움 중 하나는 적절한 서비스 세분성을 찾는 것입니다. '마이크로'라는 용어를 문자 그대로 해석하여 서비스를 너무 작게 만들면, 의미 있는 작업을 수행하기 위해 서비스 간 통신이 과도하게 필요해져 분산 시스템의 복잡성만 증가시키는 결과를 낳을 수 있습니다.

"마이크로서비스라는 용어는 설명이 아니라 명칭이다." — Martin Fowler

이는 서비스의 크기가 작아야 한다는 명령이 아니라, 당시 유행하던 서비스 지향 아키텍처(SOA)의 거대한 서비스와 구별하기 위한 이름이라는 의미입니다. 적절한 서비스 경계를 찾기 위한 지침은 다음과 같습니다.

* 목적: 각 마이크로서비스는 기능적으로 응집성 있어야 하며, 전체 애플리케이션에 중요한 동작을 기여해야 합니다.
* 트랜잭션: 비즈니스 트랜잭션에 함께 참여해야 하는 엔티티들은 종종 좋은 서비스 경계를 제시합니다.
* 코레오그래피: 여러 서비스 간에 광범위한 통신이 필요한 경우, 통신 오버헤드를 줄이기 위해 이들을 더 큰 서비스로 묶는 것을 고려할 수 있습니다.

완벽한 세분성은 반복적인 설계를 통해 발견되며, 시스템과 비즈니스 기능에 대한 이해가 깊어질수록 설계는 더욱 정교해집니다.

2.3. 데이터 격리 (Data Isolation)

경계 컨텍스트 개념에 기반한 또 다른 요구사항은 데이터 격리입니다. 마이크로서비스는 공유 스키마나 데이터베이스를 통합 지점으로 사용하는 것을 포함하여 모든 종류의 결합을 피하려고 합니다. 각 서비스는 자체 데이터를 소유하며, 이는 각 팀이 서비스의 예산, 저장 구조, 운영 특성에 가장 적합한 데이터베이스 기술을 자유롭게 선택할 수 있게 합니다. 이로 인해 다른 팀에 영향을 주지 않고 데이터베이스 기술을 변경하는 유연성을 확보할 수 있습니다.

2.4. API 계층 (API Layer)

대부분의 마이크로서비스 아키텍처는 시스템 소비자(UI 또는 다른 시스템)와 마이크로서비스 사이에 API 계층(일반적으로 API 게이트웨이)을 둡니다. 이 계층은 단순한 역방향 프록시 역할을 하거나, 보안, 이름 지정 서비스 등과 같은 공통 관심사를 처리하는 정교한 게이트웨이로 구현될 수 있습니다.

중요한 점은 API 계층을 중재자(mediator)나 오케스트레이터(orchestrator)로 사용해서는 안 된다는 것입니다. 모든 비즈니스 로직은 경계 컨텍스트 내에 위치해야 하며, API 계층에는 요청 라우팅과 보안, 모니터링, 로깅과 같은 횡단 관심사(cross-cutting concerns)만 포함해야 합니다.

2.5. 운영 재사용성: 사이드카 패턴과 서비스 메시

마이크로서비스는 도메인 관련 재사용은 피하지만, 모니터링, 로깅, 서킷 브레이커와 같은 운영상의 관심사는 결합을 통해 이점을 얻을 수 있습니다. 이때 사이드카(Sidecar) 패턴이 해결책을 제공합니다.

사이드카 패턴에서는 공통 운영 관심사를 각 서비스 내의 별도 컴포넌트로 분리합니다. 이 사이드카 컴포넌트는 공통 인프라팀이 관리할 수 있으며, 모니터링 툴 업그레이드와 같은 변경 사항을 각 마이크로서비스에 일관되게 적용할 수 있게 합니다.

각 서비스의 사이드카 컴포넌트들은 **서비스 플레인(Service Plane)**을 통해 연결되어 **서비스 메시(Service Mesh)**를 형성합니다. 서비스 메시는 전체 아키텍처에 걸쳐 모니터링 수준, 로깅 등과 같은 운영상의 결합을 전역적으로 제어할 수 있는 통합된 콘솔을 제공합니다. 또한, 서비스 메시에 **서비스 디스커버리(Service Discovery)**를 통합하여 요청량에 따라 서비스 인스턴스를 동적으로 생성하고 확장성을 높일 수 있습니다.

3. 통신 및 통합 패턴

3.1. 통신 스타일

마이크로서비스 아키텍처는 일반적으로 프로토콜 기반의 이기종 상호운용성을 통해 통신합니다.

* 프로토콜 의존적: 중앙 통합 허브가 없으므로, 각 서비스는 다른 서비스를 호출하는 방법을 알아야 합니다. 아키텍트는 REST, 메시지 큐 등 특정 통신 프로토콜을 지정합니다.
* 이기종(Heterogeneous): 각 서비스는 서로 다른 기술 스택으로 작성될 수 있습니다. 이는 문제에 가장 적합한 기술을 선택할 수 있는 유연성을 제공하며, 의도치 않은 결합을 방지하는 수단이 될 수도 있습니다.
* 상호운용성(Interoperability): 서비스들은 협업하고 정보를 교환하기 위해 네트워크를 통해 서로를 호출합니다.

비동기 통신을 위해서는 이벤트 기반 아키텍처에서와 유사하게 이벤트와 메시지를 자주 사용합니다.

3.2. 코레오그래피와 오케스트레이션

서비스 간의 조정을 위해 두 가지 주요 스타일이 사용됩니다.

* 코레오그래피(Choreography): 중앙 조정자 없이 각 서비스가 필요에 따라 다른 서비스를 직접 호출하는 분산된 방식입니다. 이는 경계 컨텍스트 철학을 존중하고 서비스 간의 분리를 유지하지만, 복잡한 워크플로우에서의 오류 처리 및 조정을 어렵게 만듭니다.
* 오케스트레이션(Orchestration): 여러 서비스를 조정해야 할 때, 호출을 조정하는 역할만 하는 국소적인 중재자(오케스트레이션 서비스)를 생성합니다. 이는 특정 서비스들 간의 결합을 생성하지만, 조정 로직을 한곳에 집중시켜 다른 서비스들의 복잡성을 줄입니다.

아키텍트의 임무는 도메인과 아키텍처 목표를 가장 잘 지원하는 방식으로 결합을 표현하는 방법을 찾는 것입니다.

3.3. 트랜잭션과 사가 패턴

서비스 경계를 넘나드는 분산 트랜잭션을 구축하는 것은 마이크로서비스의 핵심 분리 원칙에 위배됩니다. 따라서 가장 좋은 조언은 서비스 간 트랜잭션을 피하고, 대신 서비스의 세분성을 조정하는 것입니다.

그러나 예외적인 상황에서는 사가(Saga) 패턴을 사용하여 분산 트랜잭션을 처리할 수 있습니다. 사가 패턴에서는 중재자 서비스가 트랜잭션의 각 부분을 순차적으로 호출하고 성공 또는 실패를 기록합니다. 만약 트랜잭션의 일부가 실패하면, 중재자는 이미 성공한 다른 모든 참여 서비스에 이전 요청을 되돌리도록 요청하는 **보상 트랜잭션(compensating transaction)**을 실행해야 합니다. 이는 상당한 조정 오버헤드를 유발하며 매우 복잡할 수 있습니다.

4. 데이터 토폴로지

마이크로서비스는 아키텍트에게 데이터 분할을 요구하는 유일한 아키텍처 스타일입니다.

데이터베이스 토폴로지	설명 및 특징
모놀리식 데이터베이스	60개의 서비스가 동일한 데이터베이스를 공유한다고 가정할 때, 데이터베이스 스키마 변경 시 60개 서비스 모두를 수정, 테스트, 배포해야 하는 엄청난 조정 비용이 발생합니다. 이는 경계 컨텍스트 개념을 무너뜨리고 확장성, 가용성 문제를 야기하므로 마이크로서비스에서는 실행 불가능한 옵션입니다.
서비스당 데이터베이스 패턴	각 마이크로서비스가 자체 데이터를 소유하는 표준적인 접근 방식입니다. 이는 경계 컨텍스트를 유지하고, 변경 제어를 용이하게 하며, 뛰어난 확장성, 탄력성, 가용성 및 내결함성을 제공합니다. 다른 서비스는 계약을 통해 데이터에 접근하므로 데이터의 내부 구조로부터 분리됩니다.
데이터 공유 접근법	둘 이상의 서비스가 동일한 데이터베이스 테이블에 써야 하는 경우와 같이 예외적인 상황에서는 여러 서비스(5~6개 이하 권장)가 하나의 데이터베이스를 공유할 수 있습니다. 이는 더 넓은 경계 컨텍스트를 형성하며, 데이터베이스 변경 시 여러 서비스의 배포를 조정해야 하는 위험을 감수해야 합니다.

5. 아키텍처 특성 평가

마이크로서비스 아키텍처 스타일의 특성은 다음과 같이 평가됩니다. (1점: 약함, 5점: 매우 강함)

아키텍처 특성	별점 평가	설명
전체 비용	$	분산 시스템의 복잡성, 인프라, 운영 오버헤드로 인해 비용이 매우 높습니다.
파티셔닝 유형	도메인	서비스 경계가 비즈니스 도메인과 일치합니다.
퀀텀 수	1 ~ 다수	각 서비스가 독립적인 퀀텀을 형성하여 배포 단위를 세분화합니다.
단순성	★☆☆☆☆	분산 시스템의 고유한 복잡성으로 인해 단순성은 매우 낮습니다.
모듈성	★★★★★	서비스 수준에서의 높은 모듈성은 이 아키텍처의 가장 큰 강점입니다.
유지보수성	★★★★★	각 서비스를 독립적으로 수정하고 유지보수할 수 있습니다.
테스트 용이성	★★★★★	서비스 범위가 작아 테스트가 용이하고 격리된 테스트가 가능합니다.
배포 용이성	★★★★★	각 서비스를 독립적으로 배포할 수 있어 지속적 배포에 매우 유리합니다.
진화성	★★★★★	새로운 기능을 점진적으로 추가하거나 기존 기능을 변경하기 용이합니다.
응답성	★★★☆☆	네트워크 호출, 보안 검사, 데이터 지연 시간으로 인해 성능이 문제가 될 수 있습니다.
확장성	★★★★★	필요한 서비스만 독립적으로 확장할 수 있어 자원 효율성이 높습니다.
탄력성	★★★★★	자동화 및 서비스 디스커버리를 통해 부하에 따라 동적으로 확장/축소할 수 있습니다.
내결함성	★★★★★	하나의 서비스 장애가 다른 서비스에 영향을 미치지 않아 시스템 전체의 안정성이 높습니다.

6. 주요 고려사항 및 위험

6.1. 클라우드 및 서버리스

마이크로서비스는 온프레미스에서도 배포 가능하지만, 가상 머신, 컨테이너, 데이터베이스의 온디맨드 프로비저닝 덕분에 클라우드 기반 구현에 매우 적합하여 "클라우드 네이티브" 아키텍처라고도 불립니다. AWS 람다와 같은 서버리스는 별개의 아키텍처 스타일이 아니라, 마이크로서비스 아키텍처 스타일의 배포 모델로 간주됩니다.

6.2. 일반적인 위험 요소

* 너무 작은 서비스: Mark Richards가 "모래알(Grains of Sand)"이라고 명명한 이 패턴은 서비스가 너무 세분화되어 서비스 간 통신이 과도해지는 문제입니다.
* 과도한 서비스 간 통신: 서비스 간의 동적 결합이 너무 많으면 시스템 전체의 복잡성과 지연 시간이 증가합니다.
* 과도한 데이터 공유: 데이터 공유가 너무 많아지면 변경 제어, 확장성, 내결함성 등 마이크로서비스의 장점이 약화됩니다.
* 코드 재사용 및 공유 기능: 사용자 정의 라이브러리(JAR, DLL 등)를 통한 코드 공유는 "아무것도 공유하지 않는다"는 원칙에 위배되며, 경계 컨텍스트를 무너뜨릴 수 있습니다.

6.3. 거버넌스

마이크로서비스의 거버넌스는 주로 구조적 부패를 방지하는 데 초점을 맞춥니다. 아키텍트는 서비스 간의 정적 결합(공유 라이브러리, 계약)과 동적 결합(서비스 간 호출)을 모니터링하고 제어해야 합니다. 이를 위해 소프트웨어 명세서(SBOM), 배포 스크립트, 로그 분석, 서비스 레지스트리 등을 활용할 수 있습니다.

6.4. 팀 토폴로지

마이크로서비스 아키텍처는 도메인별로 분할되어 있으므로, 팀 구조 역시 도메인 영역에 맞춰 구성될 때(예: 스트림 정렬 팀) 가장 효과적입니다. UI팀, 백엔드팀과 같이 기술적으로 분할된 팀은 도메인 파티셔닝과 잘 맞지 않아 비효율적인 팀 간 커뮤니케이션을 유발합니다.

7. 적용 사례: 의료 모니터링 시스템

마이크로서비스 아키텍처의 좋은 예는 환자의 심박수, 혈압, 산소 포화도 등 생체 신호를 모니터링하는 의료 시스템입니다.

* 구조: 각 생체 신호(심박수, 혈압 등)는 자체 데이터 저장소를 가진 별도의 마이크로서비스로 구현됩니다. 모든 서비스에 공통적인 경보 기능은 '의료진 호출(Alert Staff)'이라는 공유 서비스로, 환자실 모니터에 값을 표시하는 기능은 '생체 신호 표시(Display Vital Signs)' 서비스로 구현됩니다.
* 장점:
  * 내결함성: 혈압 모니터링 서비스가 실패하더라도 다른 모든 생체 신호 모니터링 서비스는 정상적으로 작동합니다.
  * 테스트 용이성: 개발자가 혈압 서비스만 수정하는 경우, 테스트 범위가 해당 서비스로 제한되어 다른 서비스에 미치는 영향을 걱정할 필요가 없습니다.
  * 진화성: 다른 서비스에 영향을 주지 않고 새로운 생체 신호 모니터(예: 혈당)를 쉽게 추가할 수 있습니다.

이 예시는 마이크로서비스가 기능적 모듈성이 높은 시스템에서 어떻게 강력한 내결함성, 테스트 용이성, 진화성을 제공하는지 잘 보여줍니다.
