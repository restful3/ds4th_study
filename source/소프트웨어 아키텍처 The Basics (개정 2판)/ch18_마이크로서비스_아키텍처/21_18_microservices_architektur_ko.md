---
lang: ko
format:
  html:
    toc: true
    toc-location: left
    toc-depth: 3
    theme: cosmo
    embed-resources: true
    code-fold: true
    code-tools: true
    smooth-scroll: true
    css: |
      body {
        margin-top: 0 !important;
        padding-top: 0 !important;
      }
      #quarto-header {
        display: none !important;
      }
      .quarto-title-block {
        display: none !important;
      }
      /* Center content with equal padding */
      body, #quarto-content, .content, #quarto-document-content, main, .main {
        max-width: 100% !important;
        width: 100% !important;
        margin: 0 auto !important;
        padding-left: 1em !important;
        padding-right: 1em !important;
        box-sizing: border-box !important;
      }
      .container, .container-fluid, article {
        max-width: 100% !important;
        width: 100% !important;
        margin: 0 auto !important;
        padding-left: 1em !important;
        padding-right: 1em !important;
        box-sizing: border-box !important;
      }
---

## 18장. 마이크로서비스 아키텍처 (Kapitel 18. Microservices-Architektur)

이 저작물은 AI의 도움으로 번역되었습니다. 여러분의 피드백과 의견을 환영합니다: [translation-feedback@oreilly.com](mailto:translation-feedback@oreilly.com)

*마이크로서비스(Microservices)*는 최근 몇 년간 급격히 인기를 얻은 아키텍처 스타일입니다. 이 장에서는 이 아키텍처를 토폴로지적으로나 철학적으로 특징짓는 중요한 특성들에 대한 개요를 제공합니다.

대부분의 아키텍처 스타일은 특정 패턴이 반복적으로 나타나는 것을 발견한 아키텍트들에 의해 명명됩니다. 다음 큰 움직임이 무엇이 될지 결정하는 비밀 아키텍트 그룹은 존재하지 않습니다 - 아키텍트들은 소프트웨어 개발 생태계가 변화하고 진화할 때 결정을 내리며, 이러한 변화에 대응하고 이를 활용하는 가장 일반적인 방법들 중에서 가장 좋은 것으로 판명되는 것들이 다른 사람들이 따라하는 아키텍처 스타일이 됩니다.

마이크로서비스는 이러한 측면에서 다릅니다 - 상당히 일찍 명명되었습니다. 마틴 파울러(Martin Fowler)와 제임스 루이스(James Lewis)는 2014년의 유명한 [블로그 게시물](https://oreil.ly/Px3Wk)에서 이 비교적 새로운 아키텍처 스타일의 특성을 인식하고 설명하여 이를 대중화했습니다. 그들의 블로그 게시물은 아키텍처의 정의를 형성했고 호기심 많은 아키텍트들이 근본적인 철학을 이해하는 데 도움을 주었습니다.

마이크로서비스는 소프트웨어 프로젝트를 위한 논리적 설계 프로세스인 도메인 주도 설계(Domain-Driven Design, DDD)의 아이디어에 크게 영감을 받았습니다. 특히 DDD의 한 가지 개념인 *제한된 컨텍스트(Bounded Context)*가 마이크로서비스에 결정적인 영감을 주었습니다. 제한된 컨텍스트의 개념은 ([7장](#page--1-0) ["Domain-Driven](#page--1-1) Design's Bounded Context"에서 설명한) 분리 스타일을 나타내며, 이것이 마이크로서비스가 "공유하지 않는(Share Nothing)" 아키텍처로도 불리는 이유입니다.

개발자가 도메인을 정의할 때, 이 도메인은 코드 및 데이터베이스 스키마와 같은 아티팩트에서 식별되는 많은 엔티티와 동작을 포함합니다. 예를 들어, 애플리케이션은 카탈로그 항목, 고객, 결제를 포함하는 CatalogCheckout이라는 도메인을 가질 수 있습니다. 전통적인 모놀리식 아키텍처에서 개발자들은 이러한 개념들 중 많은 것을 공유하고 재사용 가능한 클래스와 연결된 데이터베이스를 생성할 것입니다. 제한된 컨텍스트 내에서 코드 및 데이터 스키마와 같은 내부 부분들은 작업을 수행하기 위해 서로 결합될 수 있지만, 제한된 컨텍스트 외부의 것들, 예를 들어 다른 제한된 컨텍스트의 데이터베이스나 클래스 정의와는 *절대로* 결합되지 않습니다. 이런 방식으로 각 컨텍스트는 필요한 것만 정의할 수 있으며, 다른 컴포넌트를 고려할 필요가 없어 제한된 컨텍스트 간의 재사용이 제한됩니다.

재사용은 일반적으로 유익하지만, 소프트웨어 아키텍처의 첫 번째 법칙을 기억하십시오. 모든 것은 트레이드오프입니다. 재사용의 단점은 상속이나 조합을 통해 일반적으로 시스템의 더 강한 결합을 필요로 한다는 것입니다.

아키텍트의 목표가 고도로 분리된 시스템(마이크로서비스의 주요 목표)인 경우, 재사용보다 중복을 선호하고 제한된 컨텍스트의 논리적 개념을 서비스와 관련 데이터를 포함하도록 물리적으로 모델링할 것입니다.

## 토폴로지 (Topologie)

마이크로서비스의 기본 토폴로지는 [그림](#page-4-0) 18-1에 나와 있습니다. 단일 목적 특성으로 인해 이 아키텍처 스타일의 서비스는 오케스트레이션 중심 SOA([17장](#page--1-0)), 이벤트 기반 아키텍처([15장](#page--1-0)), 서비스 기반 아키텍처([14장](#page--1-0))와 같은 다른 분산 아키텍처의 서비스보다 훨씬 작습니다. 아키텍트들은 각 서비스가 데이터베이스 및 기타 종속 컴포넌트를 포함하여 독립적으로 작동하는 데 필요한 모든 부분을 포함할 것으로 기대합니다.

마이크로서비스는 *분산(distributed)* 아키텍처입니다: 각 서비스는 가상 머신이나 컨테이너에서 자체 프로세스로 실행됩니다. 이러한 서비스의 분리는 애플리케이션 호스팅을 위해 멀티테넌트 인프라에 크게 의존하는 아키텍처에서 흔한 문제에 대한 간단한 해결책을 가능하게 합니다. 예를 들어, 시스템이 애플리케이션 서버를 사용하여 여러 실행 중인 애플리케이션을 관리하는 경우, 애플리케이션 서버는 무엇보다도 네트워크 대역폭, 메모리, 디스크 공간의 운영적 재사용을 가능하게 합니다. 그러나 지원되는 모든 애플리케이션이 계속 성장하면, 공유 인프라의 일부 리소스가 언젠가는 부족해질 것입니다.

또 다른 문제는 공유 애플리케이션 간의 부적절한 격리입니다. 각 서비스를 자체 프로세스로 분리하면 공유로 인해 발생하는 모든 문제가 해결됩니다. 자유롭게 사용 가능한 오픈 소스 운영 체제와 머신의 자동 프로비저닝이 개발되기 전에는 각 영역이 자체 인프라를 갖는 것이 비실용적이었습니다. 클라우드 리소스와 컨테이너 기술(["클라우드](#page-45-0) 고려사항" 참조)을 통해 팀들은 이제 영역 수준과 운영 수준 모두에서 극단적인 분리의 이점을 활용할 수 있습니다.

![](_page_4_Picture_0.jpeg)

성능은 종종 마이크로서비스의 분산 특성의 이면입니다. 네트워크 호출은 메서드 호출보다 훨씬 오래 걸리며, 각 엔드포인트에서의 보안 확인은 추가 처리 시간을 초래하므로 아키텍트들은 세분성의 영향에 대해 신중하게 생각해야 합니다.

마이크로서비스는 분산 아키텍처이므로, 경험 많은 아키텍트들은 서비스 경계를 넘어 트랜잭션을 사용하는 것을 권장하지 않습니다. 서비스의 세분성을 결정하는 것이 이 아키텍처에서 성공의 열쇠입니다.

## 스타일 특성 (Stil Besonderheiten)

다음 섹션들은 완전하지는 않지만, 마이크로서비스에만 존재하는 일부 고유한 요소를 포함하여 마이크로서비스 토폴로지의 몇 가지 중요한 측면을 설명합니다.

### **제한된 컨텍스트 (Begrenzter Kontext)**

마이크로서비스의 주도적인 철학으로 언급한 *제한된 컨텍스트(Bounded Context)* 개념에 대해 더 자세히 살펴보겠습니다. 각 서비스는 특정 기능, 하위 도메인 또는 워크플로우를 모델링합니다. 따라서 각 제한된 컨텍스트는 해당 기능이나 하위 도메인을 실행하는 데 필요한 모든 것을 포함합니다 - 논리적 컴포넌트와 클래스로 구성된 서비스, 데이터베이스 스키마 및 서비스가 기능을 실행하는 데 필요한 해당 데이터베이스를 포함합니다. 각 서비스는 특정 하위 도메인이나 기능을 나타냅니다.

이 철학은 아키텍트가 마이크로서비스 내에서 내리는 많은 결정을 결정합니다. 예를 들어, 모놀리스에서는 개발자들이 애플리케이션의 다른 부분 간에 Address와 같은 공통 클래스를 공유하는 것이 일반적입니다. 그러나 마이크로서비스 아키텍처는 결합을 피하려고 시도하므로, 이 아키텍처 스타일로 구축하는 아키텍트는 결합보다는 중복에 의존하여 각 기능이나 하위 도메인의 제한된 컨텍스트 내에 *모든* 코드를 유지할 것입니다.

마이크로서비스는 도메인 분할 아키텍처의 개념을 극단으로 몰고 갑니다. 여러 면에서 이 아키텍처는 도메인 주도 설계의 논리적 개념을 구현합니다.

### **세분성 (Granularität)**

마이크로서비스를 설계하는 아키텍트들은 종종 올바른 세분성을 찾는 데 어려움을 겪으며, *마이크로(micro)* 라는 용어를 문자 그대로 받아들여 서비스를 너무 작게 만드는 경우가 많습니다. 그런 다음 의미 있는 작업을 수행하기 위해 서비스 간에 통신 연결을 구축해야 하는데, 이는 전체 목적을 무의미하게 만들고 분산된 진흙 덩어리(big ball of distributed mud)로 이어집니다.

*마이크로서비스라는 용어는 레이블이지, 설명이 아닙니다.*

### —마틴 파울러 (Martin Fowler)

다시 말해서: 이 용어의 발명자들은 이 새로운 스타일에 *어떤* 이름을 붙여야 했고, 당시(약 2007년) 지배적이었던 아키텍처 스타일인 서비스 지향 아키텍처(Service-Oriented Architecture)와 구별하기 위해 *마이크로서비스*를 선택했습니다. 서비스 지향 아키텍처는 "거대한 서비스(gigantic services)"라고 불릴 수도 있었을 것입니다. 그러나 많은 개발자들은 *마이크로서비스*라는 용어를 설명이 아닌 명령으로 받아들여 지나치게 세밀한 서비스를 만듭니다.

마이크로서비스에서 서비스 경계의 목적은 도메인이나 워크플로우를 포착하는 것입니다. 일부 애플리케이션에서는 시스템의 일부에 대한 이러한 자연스러운 경계가 매우 클 수 있는데, 이는 단순히 일부 비즈니스 프로세스가 다른 것보다 더 강하게 결합되어 있기 때문입니다. 다음은 아키텍트가 올바른 경계를 찾는 데 도움이 될 수 있는 몇 가지 지침입니다:

#### *목적 (Zweck)*

가장 명확한 경계는 아키텍처 스타일의 영감인 문제 도메인에 있습니다. 이상적으로, 각 마이크로서비스는 기능적으로 응집력이 있어야 하며 전체 애플리케이션에 대한 중요한 동작에 기여해야 합니다.

#### *트랜잭션 (Transaktionen)*

제한된 컨텍스트는 비즈니스 워크플로우이며, 종종 트랜잭션에서 함께 작동해야 하는 엔티티가 좋은 서비스 경계를 제안합니다. 트랜잭션이 분산 아키텍처에서 문제를 일으키므로, 이를 피하는 것을 목표로 시스템을 설계하면 일반적으로 더 나은 설계로 이어집니다.

### *안무/코레오그래피 (Choreografie)*

일련의 서비스들은 훌륭한 도메인 격리를 제공하지만, 작동하기 위해서는 광범위한 통신이 필요합니다. 아키텍트는 통신 오버헤드를 피하기 위해 이러한 서비스들을 더 큰 서비스로 묶는 것을 고려할 수 있습니다.

반복(iteration)이 좋은 서비스 설계를 보장하는 유일한 방법입니다. 아키텍트들은 처음부터 완벽한 세분성, 데이터 종속성 및 통신 스타일을 발견하는 경우가 드뭅니다: 특히 시스템과 그 비즈니스 기능에 대해 더 많이 배우면서 설계를 개선하기 위해 옵션을 반복합니다.

### **데이터 격리 (Datenisolierung)**

마이크로서비스에 대한 또 다른 요구사항으로, 역시 제한된 컨텍스트 개념에 기반한 것은 *데이터 격리(data isolation)*입니다. 많은 아키텍처가 지속성을 위해 단일 데이터베이스를 사용합니다. 그러나 마이크로서비스에서는 공유 스키마와 데이터베이스를 통합 포인트로 사용하는 것을 *포함하여* *모든* 종류의 결합을 피하려고 시도합니다.

데이터 격리는 서비스의 세분성을 고려할 때 또 다른 요소입니다. 엔티티 함정(["엔티티](#page--1-2) 함정" 참조)을 조심하십시오: 데이터베이스의 개별 엔티티와 유사하게 서비스를 모델링하지 마십시오. 아키텍트들은 관계형 데이터베이스를 사용하여 시스템 내의 값을 통합하고 단일 진실의 원천(single source of truth)을 만드는 데 익숙하지만, 아키텍처 전체에 데이터를 분산시킬 때는 더 이상 이것이 옵션이 아닙니다. 따라서 각 아키텍트는 이 문제를 어떻게 처리할지 결정해야 합니다: 특정 사실에 대한 진실의 원천으로 도메인을 식별하고 값을 검색하기 위해 이와 조정하거나, 데이터베이스 복제나 캐싱을 통해 정보를 분산시킵니다.

이러한 정도의 데이터 격리는 골치 아프지만 기회도 제공합니다. 이제 단일 데이터베이스에 집중할 필요가 없으므로, 각 팀은 서비스의 예산, 저장 구조, 운영 특성, 프로세스 특성 등에 가장 적합한 데이터베이스 기술을 선택할 수 있습니다. 고도로 분리된 시스템의 또 다른 이점은 각 팀이 다른 팀에 영향을 주지 않고 방향을 전환하고 더 적절한 데이터베이스(또는 다른 종속성)를 선택할 수 있다는 것입니다. 다른 팀들은 구현 세부사항에 간섭할 수 없습니다. (데이터 격리 및 데이터베이스 고려사항에 대해서는 ["데이터](#page-38-0) 토폴로지" 섹션에서 더 자세히 다룹니다.)

### **API 레이어 (API-Schicht)**

대부분의 마이크로서비스 아키텍처는 시스템의 소비자(사용자 인터페이스 또는 다른 시스템의 호출) 와 마이크로서비스 사이에 API 레이어(일반적으로 *API 게이트웨이(API Gateway)*라고 함)를 포함합니다. API 레이어는 간단한 역방향 프록시로 구현되거나 보안, 이름 서비스 등과 같은 교차 관심사(cross-cutting concerns)를 포함하는 더 정교한 게이트웨이로 구현될 수 있습니다(이는 ["운영](#page-10-0) 재사용"에서 더 자세히 다룹니다).

API 레이어는 많은 사용 사례가 있지만, 이 아키텍처의 철학에 충실하기 위해서는 중재자(mediator)나 오케스트레이터로 사용해서는 안 됩니다. 이 아키텍처의 모든 흥미로운 비즈니스 로직은 제한된 컨텍스트 내에 위치해야 하며, 오케스트레이션이나 다른 비즈니스 로직을 중재자에 포함시키는 것은 이 규칙을 위반합니다. 아키텍트들은 일반적으로 기술적으로 분할된 아키텍처에서 중재자를 사용하는 반면, 마이크로서비스는 도메인으로 확고하게 분할됩니다.

#### **팁 (TIPP)**

마이크로서비스 아키텍처에서 API 레이어를 사용하는 경우, 요청 라우팅과 보안, 모니터링, 로깅 등과 같은 교차 관심사만 포함하십시오. 비즈니스 관련 로직을 API 레이어에 포함시키지 않도록 주의하십시오.

## **운영 재사용 (Betriebliche Wiederverwendung)**

마이크로서비스가 결합보다 중복을 선호한다는 점을 고려할 때, 아키텍트들이 모니터링, 로깅, 회로 차단기(circuit breakers)와 같이 실제로 결합으로부터 이익을 얻는 아키텍처의 부분들을 어떻게 처리하는가 하는 질문이 제기됩니다. 서비스 지향 아키텍처의 전통적인 철학은 도메인과 운영 모두에서 가능한 한 많은 기능을 재사용하는 것이었습니다. 그러나 마이크로서비스에서 아키텍트들은 이 두 가지 관심사를 분리하려고 시도합니다.

팀이 여러 마이크로서비스를 구축하면, 구성원들은 각 마이크로서비스가 유사성으로부터 이익을 얻는 공통 요소를 가지고 있다는 것을 발견합니다. 예를 들어, 조직이 각 서비스 팀에게 모니터링을 독립적으로 구현할 수 있도록 허용한다면, 각 팀이 실제로 이를 수행하도록 어떻게 보장할 수 있을까요? 그리고 조직은 업그레이드와 같은 문제를 어떻게 처리할까요 - 각 팀이 모니터링 도구의 새 버전으로 업그레이드할 책임이 있고, 이것이 얼마나 걸릴까요? *사이드카 패턴(Sidecar Pattern)*이 이 문제에 대한 해결책을 제공합니다([그림](#page-12-0) 18-2).

<span id="page-12-0"></span>![](_page_12_Picture_0.jpeg)

그림 18-2. 마이크로서비스의 사이드카 패턴

[그림](#page-12-0) 18-2에서 공통 운영 관심사(회로 차단기, 로깅, 모니터링)는 각 서비스에서 별도의 컴포넌트로 표시되며, 각각 개별 팀이나 공통 인프라 팀에 속할 수 있습니다. 사이드카 컴포넌트는 결합으로부터 이익을 얻는 모든 운영 관심사를 처리합니다. 따라서 모니터링 도구를 업데이트할 시간이 되면, 공통 인프라 팀이 사이드카를 업데이트할 수 있고, 각 마이크로서비스는 새로운 기능을 받게 됩니다(["팀](#page-51-0) 토폴로지 고려사항" 참조).

각 서비스가 공통 사이드카 컴포넌트를 포함하는 경우, 아키텍트는 *서비스 메시(Service Mesh)*를 구축하여 팀들에게 아키텍처 전체에서 이러한 공통 관심사에 대한 통합된 제어를 제공할 수 있습니다. 사이드카 컴포넌트들은 [그림](#page-14-0) 18-3에 나와 있는 것처럼 모든 마이크로서비스에 대한 통합 운영 인터페이스로 연결됩니다.

<span id="page-14-0"></span>![](_page_14_Picture_0.jpeg)

그림 18-3. 서비스 플레인이 서비스 메시에서 사이드카를 연결합니다

[그림](#page-14-0) 18-3에서 각 사이드카는 *서비스 플레인(Service Plane)*에 연결되어 있습니다. 서비스 플레인은 개별 사이드카를 통합 인터페이스로 연결하여 서비스 메시를 형성하는 통합 소프트웨어(일반적으로 [Istio](https://oreil.ly/cohCg)와 같은 제품 형태)입니다.

각 서비스는 [그림](#page-16-0) 18-4에 표시된 것처럼 전체 메시에서 노드를 형성합니다. 서비스 메시는 팀들이 모니터링 수준, 로깅 및 기타 교차 운영 관심사와 같은 운영 결합을 전역적으로 제어할 수 있는 콘솔을 형성합니다.

![](_page_16_Picture_0.jpeg)

아키텍트들은 [서비스 디스커버리(Service Discovery)](https://oreil.ly/IvPCO)를 사용하여 마이크로서비스 아키텍처의 탄력성을 높입니다. *서비스 디스커버리*는 네트워크 내에서 서비스를 자동으로 감지하고 찾는 방법입니다. 요청이 들어오면 단일 서비스만 호출되는 것이 아니라, 요청의 수와 빈도를 모니터링하고 확장성이나 탄력성 문제를 해결하기 위해 새로운 서비스 인스턴스를 생성하는 서비스 디스커버리 도구가 호출됩니다. 아키텍트들은 종종 서비스 디스커버리를 서비스 메시에 통합하여 각 마이크로서비스의 일부로 만듭니다. API 레이어는 종종 서비스 디스커버리의 호스트로 사용되므로, 사용자 인터페이스나 다른 호출 시스템이 단일 위치에서 탄력적이고 일관된 방식으로 서비스를 찾고 생성할 수 있습니다.

### **프론트엔드 (Frontends)**

마이크로서비스는 이상적으로 사용자 인터페이스와 백엔드 관심사를 모두 포함하는 분리를 선호합니다. 실제로 마이크로서비스의 원래 비전은 DDD의 제한된 컨텍스트 원칙에 충실하게 사용자 인터페이스를 제한된 컨텍스트의 일부로 보았습니다. 그러나 웹 애플리케이션에 필요한 파티셔닝의 실제 구현(및 기타 외부 제약)은 이를 어려운 목표로 만듭니다. 따라서 마이크로서비스 아키텍처에는 일반적으로 두 가지 UI 스타일이 있습니다.

[그림](#page-19-0) 18-5에 표시된 첫 번째 스타일은 *모놀리식 프론트엔드(monolithic frontend)*로, API 레이어를 호출하여 사용자 요청을 충족하는 단일 사용자 인터페이스입니다. 이 프론트엔드는 데스크톱, 모바일 또는 웹 애플리케이션일 수 있습니다. 예를 들어, 많은 웹 애플리케이션은 오늘날 JavaScript 웹 프레임워크를 사용하여 단일 사용자 인터페이스를 만듭니다.

<span id="page-19-0"></span>![](_page_19_Picture_0.jpeg)

그림 18-5. 모놀리식 사용자 인터페이스를 갖춘 마이크로서비스 아키텍처

두 번째 UI 옵션은 [그림](#page-21-0) 18-6에 표시된 것처럼 *마이크로 프론트엔드(Micro Frontends)*입니다.

![](_page_21_Picture_0.jpeg)

마이크로 프론트엔드 접근 방식은 UI 수준에서 컴포넌트를 사용하여 UI와 백엔드 서비스에서 동기적 세분성과 격리를 만들어, UI 컴포넌트와 해당 백엔드 서비스 간의 관계를 구축합니다.

마이크로 프론트엔드에 대해 더 알아보려면, Luca Mezzalira의 *Building [Micro-Frontends](https://learning.oreilly.com/library/view/building-micro-frontends-2nd/9781098170776/)*, 2nd Edition (O'Reilly, 2025) 책을 권장합니다.

### **통신 (Kommunikation)**

마이크로서비스에서 아키텍트와 개발자들은 데이터 격리와 통신 모두에 영향을 미치는 올바른 서비스 세분성을 위해 노력합니다. 올바른 통신 스타일은 팀들이 서비스를 분리된 상태로 유지하면서도 의미 있게 조정하는 데 도움을 줍니다.

기본적으로 아키텍트들은 *동기(synchronous)* 또는 *비동기(asynchronous)* 통신 중에서 선택해야 합니다. 동기 통신에서는 송신자가 수신자의 응답을 기다려야 합니다. 마이크로서비스 아키텍처는 일반적으로 서비스와의 통신 및 서비스 간 통신을 위해 *프로토콜 기반 이기종 상호운용성(protocol-based heterogeneous interoperability)*을 활용합니다. 이 복잡한 용어를 구성 요소로 분해하여 그것이 의미하는 바와 왜 중요한지 더 잘 이해해 봅시다:

### *프로토콜 의존적 (Protokollabhängig)*

마이크로서비스는 중앙 통합 노드를 포함하지 않으므로, 각 서비스는 다른 서비스를 호출하는 방법을 알아야 합니다. 따라서 아키텍트들은 일반적으로 특정 서비스가 서로를 호출하는 *방법*을 지정합니다: 특정 REST 수준, 메시지 큐 등. 이는 서비스가 다른 서비스를 호출하기 위해 사용해야 하는 프로토콜을 알아야(또는 찾아야) 한다는 것을 의미합니다.

### *이기종 (Heterogenes)*

마이크로서비스는 분산 아키텍처이므로, 각 서비스는 다른 기술 스택으로 작성될 수 있습니다. *이기종(heterogeneous)*은 마이크로서비스가 다른 서비스가 다른 플랫폼을 사용하는 다국어(polyglot) 환경을 완전히 지원한다는 것을 의미합니다.

### *상호운용성 (Interoperabilität)*

서로를 호출하는 서비스를 설명합니다. 마이크로서비스의 아키텍트들이 트랜잭션 메서드 호출을 피하려고 시도하는 동안, 서비스들은 협업하고 정보를 교환하기 위해 네트워크를 통해 다른 서비스를 자주 호출합니다.

#### **강제된 이기종성 (ERZWUNGENE HETEROGENITÄT)**

마이크로서비스 스타일의 선구자였던 한 유명한 아키텍트는 모바일 장치용 개인 정보 관리 소프트웨어를 개발하는 스타트업의 수석 아키텍트였습니다. 모바일 장치가 매우 빠르게 변화하는 문제 영역이었기 때문에, 아키텍트는 개발 팀 중 어느 팀도 독립적으로 움직이는 능력을 방해할 수 있는 결합 지점을 실수로 만들지 않도록 보장하고 싶었습니다. 팀들이 광범위한 기술 능력을 가지고 있다는 것이 밝혀졌으므로, 아키텍트는 새로운 규칙을 만들었습니다: 각 개발 팀은 *다른* 기술 스택을 사용해야 합니다. 한 팀이 Java로, 다른 팀이 .NET으로 작업하면, 그들이 실수로 클래스를 공유하는 것이 불가능했습니다!

이 접근 방식은 단일 기술 스택의 표준화를 주장하는 대부분의 기업 정책과 정반대입니다. 마이크로서비스의 세계에서는 가능한 한 복잡한 생태계를 만드는 것이 아니라, 문제의 좁은 범위에 대한 올바른 기술을 선택하는 것입니다. 모든 서비스가 대형 관계형 데이터베이스를 필요로 하는 것은 아니며, 작은 팀에게 그것을 강요하면 도움이 되기보다는 속도를 늦출 가능성이 높습니다. 이 개념은 마이크로서비스의 높은 분리를 활용합니다.

비동기 통신을 위해 아키텍트들은 종종 [15장](#page--1-0)에서 설명한 이벤트 기반 아키텍처와 유사하게 이벤트와 메시지를 사용합니다.

### **안무와 오케스트레이션 (Choreografie und Inszenierung)**

*안무(choreography)*는 EDA와 동일한 통신 스타일을 사용합니다. 안무 아키텍처는 중앙 조정자가 없으며, 이는 제한된 컨텍스트의 철학을 존중하고 서비스 간에 분리된 이벤트를 구현하는 것을 자연스럽게 만듭니다.

안무에서는 각 서비스가 중앙 중재자 없이 필요에 따라 다른 서비스를 호출합니다. 예를 들어, [그림](#page-26-0) 18-7에 표시된 시나리오를 고려하십시오. 사용자가 다른 사용자의 위시리스트에 대한 세부 정보를 요청합니다. CustomerWishList 서비스가 필요한 모든 정보를 포함하지 않기 때문에, CustomerDemographics를 호출하여 누락된 정보를 검색한 다음 결과를 사용자에게 반환합니다.

<span id="page-26-0"></span>![](_page_26_Picture_0.jpeg)

그림 18-7. 조정을 위한 마이크로서비스에서 안무 사용

마이크로서비스 아키텍처가 다른 서비스 지향 아키텍처와 달리 글로벌 중재자를 포함하지 않기 때문에, 여러 서비스를 조정해야 하는 아키텍트는 자체 로컬 중재자(일반적으로 *오케스트레이션 서비스(orchestration service)*라고 함)를 만들 수 있습니다.

[그림](#page-28-0) 18-8에서 개발자들은 호출을 조정하는 것이 유일한 작업인 서비스를 만듭니다. 예를 들어, 사용자는 ReportCustomerInformation 중재자를 호출하고, 이는 원하는 정보를 얻기 위해 필요한 모든 다른 서비스를 호출합니다.

![](_page_28_Picture_0.jpeg)

소프트웨어 아키텍처의 첫 번째 법칙은 이러한 솔루션 중 어느 것도 완벽하지 않다고 말합니다 - 각각 트레이드오프가 있습니다. 안무는 마이크로서비스의 고도로 분리된 철학을 보존하여 최대 이점을 활용합니다. 그러나 오류 처리 및 조정과 같은 일반적인 문제를 더 복잡하게 만듭니다.

더 복잡한 워크플로우를 가진 예를 고려해 봅시다. [그림](#page-30-0) 18-9에서 첫 번째로 호출된 서비스는 다양한 다른 서비스를 조정해야 하며, 기본적으로 다른 작업 외에도 중재자 역할을 합니다. 이것은 *프론트 컨트롤러 패턴(Front Controller Pattern)*이라고 불리며, 명목상 안무된 서비스가 문제에 대한 더 복잡한 중재자가 됩니다. 이 패턴의 단점은 여러 역할을 수행하는 서비스가 복잡성을 증가시킨다는 것입니다.

<span id="page-30-0"></span>![](_page_30_Picture_0.jpeg)

그림 18-9. 복잡한 비즈니스 프로세스에 안무 사용

또는 아키텍트는 [그림](#page-32-0) 18-10에 표시된 것처럼 복잡한 비즈니스 프로세스에 오케스트레이션을 사용할 수 있습니다. 아키텍트는 비즈니스 워크플로우를 조정하기 위해 중재 서비스를 만듭니다. 이것은 이러한 서비스 간에 결합을 생성하지만, 아키텍트는 조정을 단일 서비스에 집중시킬 수 있어 다른 서비스들은 덜 영향을 받습니다. 도메인의 워크플로우가 종종 본질적으로 결합되어 있기 때문에, 아키텍트의 작업은 도메인과 아키텍처의 목표를 가능한 한 잘 지원하는 방식으로 이 결합을 표현하는 방법을 찾는 것입니다.

![](_page_32_Picture_0.jpeg)

## **트랜잭션과 사가 (Transaktionen und Sagen)**

아키텍트들은 마이크로서비스에서 극단적인 분리를 추구하지만, 서비스 간에 트랜잭션을 조정하는 방법에 대한 문제에 자주 부딪힙니다. 마이크로서비스가 아키텍처와 동일한 수준의 분리를 데이터베이스에서도 촉진하기 때문에, 모놀리식 애플리케이션에서 자명했던 원자성(atomicity)이 분산 애플리케이션에서는 문제가 됩니다.

서비스 경계를 넘어 트랜잭션을 구축하는 것은 마이크로서비스의 핵심 분리 원칙을 위반하고, *값의 결합도(Connascence of Values)*라는 최악의 동적 결합도를 생성합니다(["Connascence"](#page--1-3) 참조). 서비스 간 트랜잭션을 수행하려는 아키텍트들에게 줄 수 있는 최선의 조언은: *하지 마십시오!* 대신 서비스의 세분성을 수정하십시오. 마이크로서비스 아키텍처를 트랜잭션으로 연결해야 한다는 것을 발견하면, 이는 설계가 너무 세분화되어 있다는 신호입니다.

#### **팁 (TIPP)**

여러 마이크로서비스에 걸쳐 있는 트랜잭션을 피하십시오 - 대신 서비스의 세분성을 수정하십시오!

"상황에 따라 다릅니다" 규칙에 따라 항상 예외가 있습니다. 예를 들어, 두 개의 서로 다른 서비스가 다른 서비스 경계를 필요로 하는 매우 다른 아키텍처 특성을 필요로 하지만, 여전히 트랜잭션 조정이 필요한 상황이 발생할 수 있습니다. 이 경우, 아키텍트는 트레이드오프를 신중하게 고려한 후 특정 트랜잭션 패턴을 사용하여 트랜잭션을 오케스트레이션할 수 있습니다.

마이크로서비스의 분산 트랜잭션은 일반적으로 *사가 패턴(Saga Pattern)*이라고 불리는 것으로 처리됩니다. 문학에서 *사가(saga)*는 영웅적인 결말로 이어지는 긴 일련의 사건을 설명하는 서사시입니다. 따라서 이 트랜잭션 패턴의 이름입니다.

[그림](#page-35-0) 18-11에서 서비스는 트랜잭션을 조정하기 위해 여러 서비스 호출 사이에서 중재자 역할을 합니다. 중재자는 트랜잭션의 각 부분을 호출하고, 성공 또는 실패를 등록하며, 결과를 조정합니다. 모든 것이 계획대로 진행되면, 서비스와 그 안에 포함된 데이터베이스의 모든 값이 동기적으로 업데이트됩니다. 오류가 발생하고 트랜잭션의 일부가 실패하면, 중재자는 트랜잭션의 어떤 부분도 성공하지 않도록 보장해야 합니다. [그림](#page-37-0) 18-12에 표시된 상황을 고려하십시오.

![](_page_35_Picture_0.jpeg)

트랜잭션의 첫 번째 부분이 성공하지만 두 번째 부분이 실패하면, 중재자는 성공한 트랜잭션의 모든 다른 참여 서비스에 요청을 보내고 이전 요청을 취소하도록 요청해야 합니다. 이러한 유형의 트랜잭션 조정을 *보상 트랜잭션 프레임워크(compensating transaction framework)*라고 합니다. 일반적으로 개발자들은 중재자가 전체 성공을 나타낼 때까지 각 중재자 요청을 보류 상태로 전환하여 이 패턴을 구현합니다. 그러나 비동기 요청을 처리하는 것은 매우 복잡해질 수 있으며, 특히 보류 중인 트랜잭션 상태에 의존하는 새로운 요청이 나타나는 경우 더욱 그렇습니다. 사용된 프로토콜에 관계없이, 보상 트랜잭션은 네트워크 수준에서 높은 조정 오버헤드를 발생시킵니다.

![](_page_37_Picture_0.jpeg)

#### **팁 (TIPP)**

때때로 일부 트랜잭션이 서비스 간에 걸쳐 있어야 할 필요가 있습니다. 그러나 이것이 아키텍처의 주요 특성이라면, 마이크로서비스가 아마도 올바른 선택이 아닐 것입니다!

마이크로서비스에서 트랜잭션을 관리하는 것은 복잡하며, 훨씬 더 깊이 파고들 수 있습니다. 우리는 다양한 시나리오를 해결하기 위해 8가지 다른 트랜잭션 사가 패턴을 식별했으며, 이는 Pramod Sadalage 및 Zhamak Dehghani와 함께 저술한 책 *[Software Architecture: The Hard Parts](https://www.amazon.com/Software-Architecture-Trade-Off-Distributed-Architectures/dp/1492086894)* (O'Reilly, 2021)의 12장에서 찾을 수 있습니다.

## **데이터 토폴로지 (Daten-Topologien)**

이 장에서 이미 논의한 바와 같이, 데이터는 마이크로서비스 아키텍처에서 중요한 역할을 합니다. 실제로 마이크로서비스는 아키텍트들에게 데이터를 분해하도록 *요구하는* 유일한 아키텍처 스타일입니다. 다른 분산 아키텍처에서는 모놀리식 데이터베이스를 사용하는 것이 *가능하지만*(항상 효과적이지는 않음), 마이크로서비스에서는 단순히 옵션이 아닙니다. ["데이터](#page--1-4) 토폴로지"와 ["데이터](#page--1-5) 토폴로지"에서 논의한 것처럼 도메인 데이터베이스도 마찬가지입니다. 이는 마이크로서비스의 세분성, 제한된 컨텍스트, 그리고 대부분의 마이크로서비스 생태계에서 발견되는 많은 수의 서비스 때문입니다.

모놀리식 데이터베이스가 마이크로서비스에서 실행 가능하지 않은 이유를 설명하기 위해, 60개의 서비스가 동일한 데이터베이스를 사용하는 시나리오를 고려해 봅시다. 첫 번째 문제는 아키텍처 내 변경 제어입니다. [그림](#page-40-0) 18-13에서 보듯이, 데이터베이스 구조의 변경(예: 열 이름 변경 또는 테이블 삭제)은 해당 데이터를 사용하는 모든 60개 서비스에 해당 변경을 요구합니다. 5다스의 별도로 배포된 서비스의 유지보수, 테스트 및 릴리스를 조정하면서 동시에 데이터베이스 변경을 릴리스해야 한다고 상상해 보십시오! 이 작업은 최소한으로 말해도 어려울 것이며, 아마도 재앙으로 끝날 것입니다.

<span id="page-40-0"></span>![](_page_40_Picture_0.jpeg)

그림 18-13. 모놀리식 데이터베이스로 변경을 제어하는 것은 매우 어려운 작업입니다

마이크로서비스와 모놀리식 데이터 토폴로지를 결합할 때 가장 큰 문제는 물리적으로 제한된 컨텍스트의 개념이 더 이상 작동하지 않는다는 것입니다. 제한된 컨텍스트는 특정 비즈니스 기능이나 하위 도메인을 실행하는 데 필요한 *모든* 기능을 포함합니다 - *데이터베이스와 해당 데이터 구조를 포함하여*.

각 서비스가 동일한 데이터베이스와 동일한 데이터 구조를 사용하면, 제한된 컨텍스트가 사라집니다.

모놀리식 데이터의 또 다른 문제는 확장성과 탄력성입니다. 많은 운영 도구와 제품이 동시 부하를 자동으로 모니터링하고 그에 따라 서비스 인스턴스 수를 조정하는 반면, 그에 따라 확장할 수 있는 데이터베이스는 많지 않습니다. 이러한 불균형은 응답성 문제와 요청 시간 초과로 이어질 수 있습니다. 일반적으로 각 *서비스 인스턴스*에 있는 데이터베이스 연결 관리는 또 다른 문제입니다. 서비스와 서비스 인스턴스 수가 증가함에 따라, 서비스는 빠르게 데이터베이스 연결이 부족해질 수 있으며, 이는 추가 대기 시간과 시간 초과로 이어집니다.

충돌, 예정된 유지보수 또는 백업으로 인해 데이터베이스를 사용할 수 없는 경우, 모놀리식 데이터베이스가 있는 모든 아키텍처와 마찬가지로 전체 마이크로서비스 생태계가 중단됩니다. 도메인 기반 데이터베이스 토폴로지는 그렇게 극단적이지는 않지만, 확장성, 데이터베이스 연결 풀 관리, 가용성 및 내결함성과 동일한 문제를 겪을 수 있습니다.

이러한 이유로 마이크로서비스의 표준 데이터베이스 토폴로지는 *서비스별 데이터베이스 패턴(Database-per-Service Pattern)*입니다. 이 데이터베이스 토폴로지에서 각 마이크로서비스는 별도의 데이터베이스나 스키마에 테이블로 포함된 자체 데이터를 소유합니다([그림](#page-42-0) 18-14 참조).

<span id="page-42-0"></span>![](_page_42_Figure_0.jpeg)

그림 18-14. 서비스별 데이터베이스 패턴은 마이크로서비스의 일반적인 데이터베이스 토폴로지입니다

이 토폴로지는 제한된 컨텍스트를 보존하고 아키텍트가 변경을 제어하기 쉽게 만듭니다. 데이터가 필요한 다른 서비스는 일종의 계약을 통해 소유 서비스에서 데이터를 요청해야 하므로, 데이터의 내부 구조에서 분리됩니다. 데이터베이스 구조의 변경은 제한된 컨텍스트 내의 자체 서비스에만 영향을 미칩니다. 이것은 아키텍트에게 다른 서비스에 영향을 주지 않고 데이터베이스 유형을 변경할 자유를 줍니다(예: 관계형 데이터베이스에서 문서 데이터베이스로). 다른 팀들은 구현 세부사항에 간섭할 수 없습니다.

서비스별 데이터베이스 토폴로지는 또한 모놀리식 또는 도메인 기반 데이터베이스 토폴로지에서 어려움을 겪는 아키텍처 특성인 우수한 확장성, 탄력성, 가용성 및 내결함성을 제공합니다. 또한 제한된 컨텍스트 내에서 데이터베이스 연결 관리는 모놀리식 또는 도메인 기반 데이터베이스보다 훨씬 쉽습니다.

서비스별 데이터베이스 토폴로지는 마이크로서비스에서 자주 사용되지만 단점도 있습니다. 예를 들어, 두 개 이상의 서비스가 동일한 데이터베이스 테이블에 쓰는 경우는 어떻게 될까요? 제한된 컨텍스트 외부의 서비스가 성능상의 이유로 데이터베이스를 직접 쿼리해야 하는 경우는 어떻게 될까요? 이러한 경우(상당히 자주 발생함)에는 [그림](#page-44-0) 18-15에 표시된 것처럼 여러 서비스가 데이터베이스를 공유할 수 있습니다. 단일 데이터베이스(또는 스키마)를 5~6개 이하의 서비스가 공유하는 것을 권장합니다. 5~6개 이상의 서비스의 경우, 변경 제어, 확장성, 탄력성, 가용성, 내결함성 등과 동일한 문제가 발생합니다.

<span id="page-44-0"></span>![](_page_44_Picture_0.jpeg)

그림 18-15. 여러 마이크로서비스 간에 데이터를 공유하는 것이 가능합니다

[그림](#page-44-0) 18-15의 서비스와 데이터베이스 주변의 틀은 제한된 컨텍스트를 나타냅니다. 서비스가 데이터베이스를 공유한다고 해서 제한된 컨텍스트가 없다는 의미는 아닙니다; 단지 아키텍트가 *더 넓은* 제한된 컨텍스트를 형성했다는 것을 의미합니다. 예를 들어, 결제 처리를 다른 결제 유형(예: 신용카드, 기프트 카드, PayPal, 리워드 포인트 등)으로 분리하는 좋은 이유가 있을 수 있지만, 이러한 개별 서비스는 여전히 동일한 데이터를 업데이트하고 액세스해야 합니다. 마찬가지로 아키텍트는 단일 배송 서비스를 각 배송 유형에 대한 다른 서비스로 분리할 수 있지만, 이러한 서비스는 여전히 동일한 데이터를 업데이트하고 액세스해야 합니다.

더 넓은 컨텍스트에서 마이크로서비스 간에 데이터를 공유할 때의 가장 중요한 트레이드오프는 데이터베이스 변경 제어입니다. 데이터베이스 스키마가 변경되면, 아키텍트는 이제 여러 서비스의 변경과 배포를 조정해야 하므로 데이터베이스 변경이 더 위험하고 덜 민첩해집니다. 비즈니스 문제와 상황에 따라, 이는 확장성, 탄력성 및 내결함성에도 부정적인 영향을 미칠 수 있습니다.

# **클라우드 고려사항 (Überlegungen zur Cloud)**

마이크로서비스는 특히 [Kubernetes](https://kubernetes.io/) 및 [Cloud Foundry](https://cloudfoundry.org/)와 같은 서비스 오케스트레이션 플랫폼의 인기와 함께 온프레미스 시스템에서도 배포될 수 있지만, 이 아키텍처 스타일은 클라우드 기반 구현에 특히 적합합니다 - 마이크로서비스가 때때로 "클라우드 네이티브(cloud-native)" 아키텍처로도 불릴 정도로 적합합니다. 클라우드 환경(예: AWS)에서 가상 머신, 컨테이너 및 데이터베이스의 온디맨드 프로비저닝과 서비스 기반 접근 방식의 조합은 마이크로서비스 아키텍처 스타일과 잘 맞습니다.

주의 깊은 독자는 왜 우리가 [서버리스(Serverless)](https://oreil.ly/Oltzv)를 아키텍처 스타일로 포함하지 않았는지 궁금해할 수 있습니다. *서버리스*는 함수가 요청 시 트리거되고 필요한 머신 리소스가 호출 기반으로 할당되는 클라우드 컴퓨팅 모델을 의미합니다. 서버리스 함수에는 AWS [Lambdas](https://aws.amazon.com/lambda), Google Cloud [Functions](https://cloud.google.com/functions) 및 Azure Cloud [Functions](https://oreil.ly/wzcp3)와 같은 아티팩트가 포함됩니다. 우리는 서버리스가 아키텍처 스타일이 아니라 마이크로서비스 아키텍처 스타일의 *배포 모델(deployment model)*이라고 믿습니다.

이 장의 앞부분에서 언급했듯이, *마이크로서비스*는 *단일* 목적만 수행하는 별도로 배포된 소프트웨어 단위로 정의됩니다(따라서 *마이크로* 접두사). 따라서 마이크로서비스는 일반적으로 다른 아키텍처 스타일의 서비스보다 상대적으로 더 세분화되어 있습니다. 이것은 본질적으로 *서버리스 함수*도 설명하므로, 우리는 서버리스를 마이크로서비스의 일부로 간주합니다.

그러나 클라우드 환경의 마이크로서비스가 반드시 서버리스 함수로 배포될 *필요는* 없으며, 컨테이너화된 서비스로 구현될 수도 있습니다. 대부분의 클라우드 제공업체는 Kubernetes(또는 Kubernetes 플랫폼의 한 형태)를 도입했으므로, 개발자들은 서버리스 서비스만큼 쉽게 컨테이너에 마이크로서비스를 배포할 수 있습니다.

## 공통 위험 (Gemeinsame Risiken)

마이크로서비스의 가장 큰 위험 중 하나는 서비스를 *너무* 작게 만드는 것입니다. 2016년에 여러분의 저자 중 한 명(Mark)은 해변의 모래알처럼 서비스를 너무 세밀하게 만드는 행동 패턴에 *모래알(Grains of Sand)*이라는 이름을 붙였습니다. 이미 언급했듯이, 마이크로서비스의 *마이크로*는 서비스가 *무엇을* 하는지를 의미하며, 얼마나 *크냐*는 의미가 아닙니다. 서비스의 세분성은 마이크로서비스의 매우 중요한 측면이므로, 우리는 *[Software Architecture: The Hard Parts](https://www.amazon.com/Software-Architecture-Trade-Off-Distributed-Architectures/dp/1492086894)* 책의 전체 7장을 이에 할애했습니다.

마이크로서비스의 또 다른 일반적인 위험은 서비스 간에 너무 많은 통신이 발생하는 것입니다. 제한된 컨텍스트가 밀접하게 결합된 마이크로서비스의 세밀한 특성으로 인해 마이크로서비스 생태계 내의 서비스들은 필연적으로 서로 통신해야 합니다. 이 통신은 워크플로우 처리(예: 안무 또는 서버리스 마이크로서비스용 AWS 스텝 함수) 또는 다른 서비스의 데이터가 필요하여(각 서비스와 그 데이터 내의 제한된 컨텍스트 때문에) 발생할 수 있습니다. 이유에 관계없이 서비스 간에 너무 많은 동적 결합과 통신을 피하도록 주의해야 합니다. 이것도 종종 너무 세밀한 서비스의 결과이며, 서비스를 더 조밀한 마이크로서비스로 결합하여 해결할 수 있습니다.

마이크로서비스의 또 다른 위험은 데이터 공유를 과도하게 하는 것입니다. 마이크로서비스에서 데이터를 공유하는 것이 가능하고(때로는 필요하다고) 이미 언급했지만, 데이터 공유가 너무 많으면 변경 제어, 확장성, 내결함성 및 시스템의 전반적인 민첩성이 위협받습니다 - 마이크로서비스가 특히 잘하는 모든 것들입니다(["스타일](#page-53-0) 특성" 참조). 데이터를 공유해야 할 때와 서비스 통합을 통해 데이터 공유를 방지해야 할 때를 인식하십시오.

마이크로서비스 아키텍처에서 종종 간과되는 마지막 위험은 코드 재사용과 기능 공유입니다. 코드 재사용은 소프트웨어 개발의 필수적인 부분입니다. 그러나 코드와 기능의 재사용은 마이크로서비스의 원칙과 직접 모순되므로, 이 장의 앞부분에서 설명한 "공유하지 않는(Share Nothing)" 아키텍처라는 용어가 있습니다. 아키텍트가 사용자 정의 라이브러리(예: JAR 파일 또는 DLL)를 통해 서비스 간에 공통 기능을 공유하면, 제한된 컨텍스트의 일부가 무너집니다. 다시 말해: 재사용된 코드는 여러 제한된 컨텍스트에 분산되어 있으며, 이는 특정 기능이나 하위 도메인에 대한 *모든* 기능이 제한된 컨텍스트에 포함되어 있지 않다는 것을 의미하므로, 공유 코드의 변경이 다른 제한된 컨텍스트의 서비스를 방해할 수 있습니다. 버전 관리가 이 문제를 해결하는 데 도움이 되지만, 코드 공유는 마이크로서비스 생태계를 상당히 복잡하게 만듭니다.

## 거버넌스 (Governance)

마이크로서비스에서 사용되는 많은 거버넌스 규칙과 기술은 이전 섹션에서 설명한 일반적인 위험을 목표로 합니다. 마이크로서비스 아키텍처의 거버넌스는 무엇보다도 구조적 붕괴를 방지하는 것입니다.

무엇보다도 아키텍트들은 서비스 간의 정적 및 동적 결합을 모니터링하고 제어해야 합니다. [7장](#page--1-0)을 기억하십시오: 정적 결합은 마이크로서비스가 사용자 정의 라이브러리나 타사 라이브러리를 공유할 때, 그리고 서비스가 서로 통신해야 할 때 계약의 형태로 발생합니다. 계약은 특히 중요합니다: 아키텍트들이 비동기 통신 프로토콜을 사용하여 서비스를 *동적으로* 분리할 수 있지만, 그들 사이에 사용되는 계약에 의해 여전히 *정적으로* 결합될 수 있습니다(통신 유형에 관계없이).

소프트웨어 BOM(Bill of Materials), 배포 스크립트 및 종속성 관리 도구는 아키텍트가 서비스 간에 교환되는 아티팩트의 수를 더 잘 이해하고 제어하는 데 도움이 될 수 있습니다. 얼마나 많은 정적 결합이 *너무 많은지* 정확하게 규정할 수는 없지만, 서비스 간의 결합을 최소화하는 것이 좋습니다.

동적 결합의 규제는 정적 결합의 규제보다 훨씬 어렵습니다. 적절한 메트릭을 수집하려면 약간의 창의성과 일관성이 필요합니다. 제어를 위한 일반적인 방법은 로그를 사용하여 다른 서비스에 대한 호출을 식별하는 것입니다. 서비스가 내부 서비스나 타사 서비스를 호출할 때, 이러한 서비스는 어떤 서비스가 호출되는지, 어떤 프로토콜이 사용되는지 등에 대한 정보와 함께 상호작용을 기록합니다. 아키텍트들은 피트니스 함수를 사용하여 이 정보를 분석하여 마이크로서비스 생태계 전체의 동적 결합을 더 잘 이해할 수 있습니다. 그러나 이 접근 방식은 각 서비스가 로깅을 통해 이 정보를 일관된 방식으로 노출하도록 보장하기 위한 엄격한 제어가 필요합니다. 사용자 정의 라이브러리(예: JAR 파일 또는 DLL)는 모든 서비스가 컴파일 타임에 바인딩하여 일관된 로깅을 보장할 수 있는 통합 API를 제공하는 한 가지 방법입니다.

마이크로서비스에서 동적 결합 데이터를 캡처하는 또 다른 방법은 레지스트리 항목입니다. 서비스의 첫 번째 인스턴스가 시작되면, 이 서비스는 일종의 계약(예: JSON)을 통해 사용자 정의 구성 서비스 또는 Apache [ZooKeeper](https://zookeeper.apache.org/)와 같은 구성 서버에 서비스 간 호출을 등록합니다. 그런 다음 아키텍트는 구성 서버를 쿼리하여 마이크로서비스 생태계 전체의 모든 서비스 간 호출에 대한 맵을 얻을 수 있으며, 이를 통해 서비스 간 통신을 규제하고 제어할 수 있습니다.

# **팀 토폴로지 고려사항 (Überlegungen zur Team-Topologie)**

마이크로서비스 아키텍처는 도메인으로 분할되므로, 팀도 도메인 영역으로 조직될 때 가장 잘 작동합니다(예: 전문화된 기능 간 팀). 도메인 관련 요구사항이 발생하면, 도메인 관련 기능 간 팀이 다른 팀이나 서비스에 영향을 주지 않고 특정 도메인 서비스 내에서 해당 기능에 공동으로 작업할 수 있습니다. 반대로 기술적으로 분할된 팀(예: UI 팀, 백엔드 팀, 데이터베이스 팀 등)은 도메인 분할로 인해 이 아키텍처 스타일과 잘 작동하지 않습니다. 도메인 요구사항을 기술적으로 조직된 팀에 할당하려면 대부분의 조직에서 어렵다고 입증된 수준의 팀 간 통신 및 협업이 필요합니다.

다음은 ["팀](#page--1-6) 토폴로지와 아키텍처"에서 설명한 특정 팀 토폴로지와 마이크로서비스 아키텍처를 조정하려는 아키텍트를 위한 몇 가지 고려사항입니다:

#### *스트림 정렬 팀 (Auf den Strom ausgerichtete Teams)*

도메인 경계가 올바르게 정렬되면, 스트림에 정렬된 팀은 이 아키텍처 스타일과 잘 작동하며, 특히 스트림이 특정 도메인에 정렬된 경우 더욱 그렇습니다. 그러나 마이크로서비스 아키텍처는 스트림이 특정 하위 도메인이나 도메인 외부의 여러 제한된 컨텍스트와 서비스를 포함하는 팀에게는 더 어려워집니다. 이 경우, 컨텍스트와 마이크로서비스의 세분성을 분석하고 스트림에 다시 정렬하거나 다른 아키텍처 스타일을 선택하는 것이 좋습니다.

### *지원 팀 (Teams befähigen)*

지원 팀은 특수하거나 교차 관심사를 위한 공유 서비스를 활용할 수 있을 때 마이크로서비스 아키텍처에서 가장 효과적입니다. 마이크로서비스의 높은 모듈성으로 인해, 지원 팀은 스트림 팀과 독립적으로 작업하여 방해하지 않고 추가 전문 및 공유 기능을 제공할 수 있습니다. 플랫폼 팀과 협력하여, 서비스 메시를 형성하는 사이드카 컴포넌트 생성을 도울 수도 있습니다(["운영](#page-10-0) 재사용" 참조).

#### *복잡한 하위 시스템 팀 (Teams mit komplizierten Subsystemen)*

복잡한 하위 시스템을 다루는 팀은 이 아키텍처 스타일의 서비스 수준 모듈성을 활용하여 다른 팀 구성원(및 서비스)과 독립적으로 복잡한 도메인이나 하위 도메인 처리에 집중할 수 있습니다.

#### *플랫폼 팀 (Plattform-Teams)*

마이크로서비스에서 발견되는 높은 수준의 모듈성은 스트림 팀이 공통 도구, 서비스, API 및 작업을 사용하여 플랫폼 팀 토폴로지의 이점을 활용하는 데 도움이 됩니다. 많은 경우, 플랫폼 팀(때로는 지원 팀과 협력하여)은 사이드카에서 발견되는 교차 운영 기능(["운영](#page-10-0) 재사용" 참조)과 서비스 메시의 생성 및 유지 관리에 집중하여, 스트림 정렬 팀을 이러한 운영 작업에서 해방시킵니다.

## **스타일 특성 (Stilmerkmale)**

마이크로서비스 아키텍처 스타일은 [그림](#page-54-0) 18-16에 표시된 표준 평가 척도에서 여러 극단을 제공합니다. 1점 등급은 특정 아키텍처 특성이 아키텍처에서 잘 지원되지 않음을 의미하며, 5점 등급은 아키텍처 특성이 아키텍처 스타일의 가장 강력한 특성 중 하나임을 의미합니다. 스코어카드에 언급된 각 특성의 정의는 [4장](#page--1-0)에서 찾을 수 있습니다.

마이크로서비스는 자동화된 배포 및 테스트 가능성과 같은 현대적인 개발 관행에 대한 매우 높은 지원을 제공합니다. 마이크로서비스는 운영 관행의 자동화를 향한 끊임없는 진전을 가진 DevOps 혁명 없이는 불가능했을 것입니다.

|             | 아키텍처 특성 (Architectural characteristic) | 별점 (Star rating)                      |
|-------------|-------------------------------|------------------------------------|
|             | 전체 비용 (Overall cost)      | $$$$$                              |
| 구조적 (Structural) | 분할 유형 (Partitioning type) | 도메인 (Domain)                     |
|             | 퀀텀 수 (Number of quanta)    | 1에서 다수까지 (1 to many)           |
|             | 단순성 (Simplicity)           | ★                                  |
|             | 모듈성 (Modularity)           | ★★★★★                              |
| 엔지니어링 (Engineering) | 유지보수성 (Maintainability) | ★★★                                |
|             | 테스트 가능성 (Testability)   | ★★★★★                              |
|             | 배포 가능성 (Deployability)   | ★★★★★                              |
|             | 진화 가능성 (Evolvability)    | ★★★★★                              |
| 운영적 (Operational) | 응답성 (Responsiveness)      | ★                                  |
|             | 확장성 (Scalability)          | ★★★★★                              |
|             | 탄력성 (Elasticity)           | ★★★★★                              |
|             | 내결함성 (Fault tolerance)    | ★★★★★                              |

이 아키텍처 스타일의 서비스들의 독립적이고 목적이 있는, 따라서 세밀한 특성은 일반적으로 높은 내결함성으로 이어지므로, 이 특성에 대한 높은 등급을 받습니다.

이 아키텍처의 추가 강점은 확장성, 탄력성 및 진화 가능성입니다. 지금까지 개발된 가장 확장 가능한 시스템들 중 일부는 마이크로서비스를 매우 성공적으로 사용했습니다. 이러한 유형의 아키텍처가 자동화 및 운영과의 지능적인 통합에 크게 의존하기 때문에, 아키텍트들은 탄력성도 구축할 수 있습니다. 이 아키텍처가 증분 수준에서 높은 분리를 선호하기 때문에, 아키텍처 수준에서도 진화적 변화의 현대적 비즈니스 관행을 지원합니다. 현대 기업은 빠르게 진화하며, 소프트웨어 개발은 이를 따라잡기 어렵습니다. 극도로 작고 고도로 분리된 배포 단위를 가진 아키텍처는 더 빠른 변화율을 지원할 수 있습니다.

성능은 종종 마이크로서비스에서 문제입니다. 분산 아키텍처는 작업을 완료하기 위해 많은 네트워크 호출을 해야 하며, 이는 높은 성능 오버헤드를 초래합니다. 또한 각 엔드포인트에 대한 신원 및 액세스를 확인하기 위해 보안 확인을 수행해야 하므로, 추가 지연 시간이 발생합니다. 마이크로서비스는 또한 *데이터 지연*으로 고통받습니다: 요청이 여러 서비스에 의해 조정되어야 하는 경우, 이는 여러 데이터베이스 호출을 의미합니다.

이러한 이유로 마이크로서비스의 세계에는 지능형 데이터 캐싱 및 복제와 같이 성능을 향상시키는 많은 아키텍처 패턴이 있어 과도한 네트워크 호출을 피할 수 있습니다. 성능은 마이크로서비스가 종종 오케스트레이션 대신 안무를 사용하는 또 다른 이유입니다: 결합이 적을수록 더 빠른 통신과 더 적은 병목 현상이 가능합니다.

마이크로서비스는 분명히 도메인 분할 아키텍처이며, 각 서비스 경계는 도메인에 해당해야 합니다. 제한된 컨텍스트 덕분에, 모든 현대 아키텍처 중 가장 뚜렷한 퀀텀을 가지고 있습니다 - 여러 면에서 퀀텀 측정이 평가하는 것을 설명합니다. 극단적인 분리의 철학은 골치 아프지만, 잘 구현되면 엄청난 이점을 가져옵니다. 모든 아키텍처와 마찬가지로, 아키텍트들은 규칙을 지능적으로 깨기 위해 규칙을 이해해야 합니다.

# 예제와 사용 사례 (Beispiele und Anwendungsfälle)

높은 수준의 기능적 및 데이터 관련 모듈성을 나타내는 시스템은 마이크로서비스 아키텍처의 좋은 후보입니다. 이 스타일의 강력함을 보여주는 좋은 예는 환자의 바이탈 사인을 모니터링하는 의료 모니터링 시스템입니다: 심박수, 혈압, 산소 수준 등. 시스템이 모니터링하는 각 바이탈 사인은 자체 데이터를 관리하는 별도의 독립적인 기능으로, 이 아키텍처 스타일과 제한된 컨텍스트 개념에 잘 맞습니다. 이 환자 모니터링 시스템은 환자 모니터링 장치에서 입력을 읽고, 바이탈 값을 기록하며, 문제나 불일치에 대해 이러한 바이탈 값을 분석하고, 문제를 발견하면 의료진에게 경고합니다. 각 바이탈 사인은 다른 서비스 및 데이터와 크게 독립적인 자체 마이크로서비스로 표현될 수 있습니다. 그러나 이 독립성에 대한 예외는 특정 바이탈 사인(예: 심박수)이 경고나 문제에 대한 바이탈 사인을 분석하기 위해 다른 바이탈 사인(예: 수면 모니터링 서비스)의 추가 정보가 필요한 경우입니다.

[그림](#page-58-0) 18-17은 마이크로서비스 아키텍처를 사용하여 이 시스템을 어떻게 설계할 수 있는지 보여줍니다. 각 바이탈 사인은 바이탈 사인 값과 과거 데이터에 대한 자체 데이터 저장소를 유지하는 별도의 마이크로서비스로 구현되었습니다.

모든 바이탈 사인 서비스에 공통적인 경고 기능은 Alert Staff라는 *공유 서비스(shared service)*로 표현됩니다. 이것은 특정 서비스가 값에 문제가 있음을 발견할 때 간호사나 의사에게 알립니다. 각 서비스는 Display Vital Signs라는 공유 서비스로 표현되는 환자실의 모니터에 최신 바이탈 값을 비동기적으로 전송합니다.

<span id="page-58-0"></span>![](_page_58_Figure_0.jpeg)

그림 18-17. 마이크로서비스 아키텍처로 구현된 의료 환자 모니터링 시스템

이 예제는 마이크로서비스 아키텍처의 몇 가지 강점과 이점을 보여줍니다. 예를 들어 *내결함성*: 바이탈 사인 서비스 중 하나가 실패하거나 응답하지 않으면, 다른 모든 바이탈 사인 모니터링 서비스는 완전히 작동합니다. 이것은 의료 모니터링에 특히 중요합니다. 또 다른 슈퍼파워는 *테스트 가능성*입니다. 개발자가 혈압 모니터링 서비스에서 일부 유지보수를 수행하는 경우, 테스트 범위가 너무 작아서 이 특정 바이탈 사인이 완전히 테스트되었고 유지보수가 다른 바이탈 사인 서비스에 영향을 미치지 않는다고 확신할 수 있습니다. 마지막으로, *진화 가능성*(마이크로서비스의 또 다른 슈퍼파워)의 표시로, 아키텍트는 다른 서비스에 영향을 주지 않고 다른 바이탈 사인 모니터를 쉽게 추가할 수 있습니다.

이 장에서 마이크로서비스 아키텍처의 많은 중요한 측면을 다루었으며, 더 많이 배우는 데 사용할 수 있는 많은 훌륭한 리소스가 있습니다. 마이크로서비스에 대한 더 깊은 통찰을 위해 다음을 권장합니다:

- *Building [Microservices](https://learning.oreilly.com/library/view/building-microservices-2nd/9781492034018/)*, 2nd Edition, Sam Newman 저 (O'Reilly, 2021)
- *Building [Micro-Frontends](https://learning.oreilly.com/library/view/building-micro-frontends-2nd/9781098170776/)*, 2nd Edition, Luca Mezzalira 저 (O'Reilly, 2025)
- *Microservices [vs. Service-Oriented](https://learning.oreilly.com/library/view/microservices-vs-service-oriented/9781491975657) Architecture*, Mark Richards 저 (O'Reilly, 2016)
- *[Microservices](https://learning.oreilly.com/library/view/microservices-antipatterns-and/9781492042716) AntiPatterns and Pitfalls*, Mark Richards 저 (O'Reilly, 2016)
