---
lang: ko
format:
  html:
    toc: true
    embed-resources: true
    theme: cosmo
---

# 17장. 오케스트레이션 기반 서비스 지향 아키텍처 (Kapitel 17. Orchestrierungsgesteuerte Serviceorientierte Architektur)

이 작업은 AI를 사용하여 번역되었습니다. 피드백과 의견을 환영합니다: [translation-feedback@oreilly.com](mailto:translation-feedback@oreilly.com)

아키텍처 스타일은 생성된 시대의 맥락에서 아키텍트에게 의미가 있지만, 마치 예술 사조처럼 이후 시대에는 그 중요성이 감소합니다. *오케스트레이션 기반 서비스 지향 아키텍처* (Service-Oriented Architecture, SOA)는 이러한 경향을 보여주는 예시입니다. 아키텍처 결정에 자주 영향을 미치는 외부 요인과 논리적이지만 궁극적으로는 재앙적인 조직 철학의 조합이 이 아키텍처를 무의미하게 만들었습니다. 그러나 이것은 특정 조직적 아이디어가 논리적으로는 타당해 보일 수 있지만 개발 프로세스의 가장 중요한 부분을 방해할 수 있다는 좋은 예입니다. 이는 우리의 첫 번째 법칙을 무시할 때의 위험 중 하나를 명확히 보여줍니다: *소프트웨어 아키텍처의 모든 것은 트레이드오프입니다*.

## 토폴로지 (Topologie)

[오케스트레이션 기반](#page-2-0) SOA의 토폴로지는 그림 17-1에 나타나 있습니다.

이러한 유형의 아키텍처의 모든 예가 정확히 이러한 계층을 가지고 있는 것은 아니지만, 모두 동일한 아이디어를 따릅니다. 즉, 아키텍처 내에서 서비스의 분류 체계(taxonomy)를 만들고, 각 계층이 특정하고 명확하게 정의된 책임을 갖도록 하는 것입니다.

서비스 지향 아키텍처는 분산 아키텍처입니다. 정확한 경계는 [그림](#page-2-0) 17-1에 표시되지 않았는데, 이는 조직과 도구에 따라 다르기 때문입니다. 분류 체계의 일부는 애플리케이션 서버 내에 존재할 수 있습니다.

오케스트레이션 기반 SOA는 특정 서비스 분류 체계에 초점을 맞추며, 아키텍처 내에서 서로 다른 기술적 책임과 특정 계층에 할당된 역할을 가집니다.

<span id="page-2-0"></span>![](_page_2_Figure_0.jpeg)

그림 17-1. 오케스트레이션 기반 서비스 지향 아키텍처의 토폴로지

### 스타일 특성 (Stil Besonderheiten)

오케스트레이션 기반 SOA는 오늘날의 아키텍트에게는 주로 역사적 관심사이지만, 이러한 아키텍처를 구축하면서 배운 교훈은 이 분야 발전의 중요한 부분입니다. 그럼에도 불구하고, 일부 통합 아키텍처(integration architecture) 시나리오에서는 아키텍트에게 여전히 의미가 있습니다.

서비스 지향 아키텍처는 1990년대 후반에 등장했는데, 당시 모든 종류의 소규모 기업들이 급속도로 대기업으로 성장하고, 더 작은 회사들과 합병하며, 이러한 성장을 관리하기 위해 더 정교한 IT가 필요했습니다. 그러나 컴퓨팅 리소스는 부족하고, 귀중하며, 상용적이었습니다. 분산 컴퓨팅(distributed computing)은 막 가능해지고 필요하게 되었으며, 많은 기업들은 확장성과 다른 유익한 특성을 필요로 했습니다.

많은 외부 요인들이 이 시기의 아키텍트들을 상당한 시스템 제약을 가진 분산 아키텍처로 강제했습니다. 오픈소스 운영체제가 진지한 작업에 충분히 신뢰할 수 있다고 간주되기 전에는, 운영체제는 비쌌고 컴퓨터당 라이선스가 부여되었습니다. 상용 데이터베이스 서버도 복잡한 라이선싱 시스템을 가지고 있어서, 때로는 애플리케이션 서버 공급업체(데이터베이스 연결 풀링을 제공하는)가 데이터베이스 공급업체와 충돌하기도 했습니다. 대규모에서 많은 리소스가 비쌌기 때문에, 아키텍트들은 가능한 한 많이 재사용하는 철학을 추구했습니다.

이러한 기술적 우려는 정보와 워크플로우의 중복에 대한 조직적 우려와 결합되었습니다. 빈번한 합병과 성장으로 인해 기업들은 핵심 사업 단위 간의 다양성과 불일치와 싸우고 있었습니다. 이것이 SOA의 목표를 매력적으로 만들었습니다. 결과적으로, 아키텍트들은 *재사용*을 모든 형태에서 이 아키텍처의 지배적인 철학으로 만들었으며, 그 부작용은 ["재사용](#page-12-0)...과 결합(coupling)" 섹션에서 다룹니다. 이 아키텍처 스타일은 또한 아키텍트들이 기술적 분할(technical partitioning) 아이디어를 얼마나 멀리까지 밀어붙일 수 있는지를 보여주는 예입니다. 좋은 동기를 가질 수 있지만, 극단으로 치달으면 나쁜 결과를 초래합니다.

#### **왜 그렇게 많은 서비스 이름이 있는가? (WARUM SO VIELE SERVICENAMEN?)**

아키텍트들은 소프트웨어 아키텍처에서 *서비스(services)*라고 불리는 다양한 것들 때문에 종종 혼란스러워합니다. 이 책에서는 세 가지 다른 종류의 "서비스"를 다룹니다: 이 장의 SOA, [18장](#page--1-0)의 마이크로서비스(Microservices), 그리고 [14장](#page--1-0)의 서비스 기반 아키텍처(service-based architectures). 문제의 일부는 아키텍처를 설명하는 언어의 비유연성입니다. 다른 부분은 소프트웨어 개발 생태계의 지속적인 진화에 있습니다. *서비스*는 무언가를, 즉 서비스를 제공하는 것에 대한 좋은 일반적인 이름이므로, 아키텍트들은 이 이름을 계속 사용하는 경향이 있습니다. 스타일이 진화함에 따라, 우리는 *서비스*로 의미하는 것도 바뀝니다. 예를 들어, 오케스트레이션 기반 SOA의 *엔티티 서비스(Entity Service)*는 마이크로서비스 아키텍처의 서비스(서비스 기반 아키텍처와는 다릅니다)와는 사실상 모든 면에서 다릅니다. 짜증나는 일이지만, 아키텍트들은 이름에 *서비스*라는 단어가 나타날 때 종종 맥락을 분석해야 합니다. 이 용어 자체는 [의미론적](https://oreil.ly/9oQNq) 확산(semantic diffusion)으로 고통받고 있습니다.

### 분류 체계 (Taxonomie)

이 아키텍처의 추진 철학은 특정 종류의 추상화와 기업 수준의 재사용입니다. 많은 대기업들은 소프트웨어를 끊임없이 다시 작성해야 하는 것에 좌절했습니다. 그들은 명확히 정의된 계층과 해당 책임을 가진 엄격한 *서비스 분류 체계*를 생성함으로써 이 문제를 점진적으로 해결하는 것처럼 보이는 전략을 취했습니다. 분류 체계의 각 계층은 궁극적인 추상화와 재사용이라는 두 가지 목표를 지원합니다.

#### 비즈니스 서비스 (Dienstleistungen für Unternehmen)

*비즈니스 서비스(Business Services)*는 이 SOA의 최상위에 있으며 비즈니스 프로세스의 진입점을 형성합니다. 예를 들어, ExecuteTrade 또는 PlaceOrder와 같은 서비스는 이러한 서비스에 적절한 행동 범위를 나타냅니다. 당시 일반적인 리트머스 테스트는 다음과 같았습니다: 아키텍트가 이러한 각 서비스에 대해 "우리는 ...할 수 있는가?"라는 질문에 "예"라고 대답할 수 있는가? 그렇다면, 서비스는 올바른 세분성 수준에 있는 것입니다. 개발자는 ExecuteTrade와 같은 비즈니스 프로세스를 실행하기 위해 CreateCustomer와 같은 메서드가 필요할 수 있지만, CreateCustomer는 비즈니스 서비스에 대한 잘못된 추상화 수준에 있습니다. 비즈니스는 고객을 생성하는 *업무*를 가지고 있지 않지만, 거래를 하기 위해 고객을 생성해야 합니다.

이러한 서비스 정의는 코드를 포함하지 않고, 입력, 출력, 때로는 스키마 정보만 포함합니다. 비즈니스 사용자 및/또는 분석가가 이러한 서비스 시그니처를 정의하므로, *비즈니스 서비스*라는 이름이 붙었습니다.

#### 엔터프라이즈 서비스 (Unternehmensdienstleistungen)

*엔터프라이즈 서비스(Enterprise Services)*는 세분화된 공유 구현을 포함합니다. 일반적으로 개발 팀은 CreateCustomer 또는 CalculateQuote와 같은 특정 비즈니스 영역에 대한 원자적 동작과 Customer, Order, Lineitem과 같은 트랜잭션 엔티티를 생성합니다. 이러한 엔터프라이즈 서비스는 오케스트레이션 엔진을 통해 서로 연결되어 비즈니스 서비스를 구성하는 빌딩 블록입니다.

비즈니스 서비스와 엔터프라이즈 서비스 간의 추상화 차이에 주목할 가치가 있습니다. 비즈니스 서비스는 상당히 조악한 반면, 엔터프라이즈 서비스는 세분화되어 있으며 다양한 종류의 추상화, 워크플로우 및 엔티티를 캡처하도록 설계되었습니다. 엔터프라이즈 서비스를 개발할 때 아키텍트의 목표는 격리된 비즈니스 기능을 가진 완벽하게 캡슐화된 빌딩 블록을 생성하여 더 복잡한 비즈니스 워크플로우로 자유롭게 구성할 수 있도록 하는 것입니다.

이는 칭찬할 만한 목표이지만, 아키텍트들은 이 모든 힘들 사이에서 추상화의 이상적인 스위트 스팟을 찾는 것이 기껏해야 어렵고 수많은 경쟁하는 트레이드오프 때문에 아마도 불가능하다는 것을 발견합니다. 궁극적으로, 이 아키텍처는 다른 기술적으로 분할된 아키텍처처럼, 재사용 요구사항에서 비롯된 엄격한 책임 분리를 시도합니다. 그 이면의 생각은 개발자가 올바른 세분성 수준에서 세분화된 엔터프라이즈 서비스를 생성할 수 있다면, 기업은 비즈니스 워크플로우의 이 부분을 다시 작성할 필요가 없다는 것입니다. 점진적으로 기업은 재사용 가능한 엔터프라이즈 서비스 형태의 재사용 가능한 리소스 컬렉션을 구축할 것입니다 - 적어도 이론적으로는.

불행히도, 현실의 동적인 특성과 소프트웨어 개발 생태계의 진화적 영향은 이러한 시도에 저항합니다. 비즈니스 구성 요소는 수십 년 동안 지속되는 솔루션을 가진 건축 자재와 같지 않습니다. 시장, 기술 변화, 기술 관행 및 다양한 다른 요인들이 소프트웨어 세계에 안정성을 부여하려는 시도를 무산시킵니다.

#### 애플리케이션 서비스 (Anwendungsdienste)

아키텍처의 모든 서비스가 엔터프라이즈 서비스와 동일한 수준의 세분성이나 재사용을 요구하는 것은 아닙니다. *애플리케이션 서비스(Application Services)*는 한 번만 구현되는 일회성 서비스입니다. 예를 들어, 애플리케이션이 지오로케이션(geolocation)이 필요할 수 있지만, 기업은 이 서비스를 재사용 가능하게 만드는 데 시간과 노력을 투자하고 싶지 않을 수 있습니다. 일반적으로 단일 애플리케이션 팀이 운영하는 애플리케이션 서비스가 이 문제를 해결합니다.

### 인프라 서비스 (Infrastrukturdienste)

*인프라 서비스(Infrastructure Services)*는 모니터링, 로깅, 인증, 권한 부여 등과 같은 운영상의 우려사항을 처리합니다. 이러한 서비스는 일반적으로 운영과 긴밀히 협력하는 공통 인프라 팀이 담당하는 구체적인 구현입니다. 이 아키텍처를 구축할 때 아키텍트의 철학은 기술적 분할을 중심으로 돌아가므로, 별도의 인프라 서비스를 구축하는 것이 합리적입니다.

### 오케스트레이션 엔진과 메시지 버스 (Orchestrierungs-Engine und Nachrichtenbus)

*오케스트레이션 엔진(Orchestration Engine)*은 이 분산 아키텍처의 심장을 형성합니다. 오케스트레이션을 사용하여 엔터프라이즈 서비스의 구현을 결합하고, 트랜잭션 조정 및 메시지 변환과 같은 기능을 제공합니다. 오케스트레이션 엔진은 비즈니스 서비스와 엔터프라이즈 서비스 간의 관계, 그들이 서로 어떻게 연결되는지, 그리고 트랜잭션 경계가 어디에 있는지를 정의합니다. 또한 통합 허브로 작동하여 아키텍트가 사용자 정의 코드를 패키지 및 레거시 소프트웨어 시스템에 통합할 수 있게 합니다. 이러한 기능의 조합은 엔터프라이즈 서비스 버스(Enterprise Service Bus, ESB)와 같은 도구의 현대적 사용을 명확히 보여줍니다. 대부분의 아키텍트는 ESB를 중심으로 전체 아키텍처를 구축하는 것이 나쁜 아이디어라고 생각하지만, 통합 집약적인 환경에서는 매우 유용합니다. 아키텍트가 통합 허브와 오케스트레이션 엔진을 결합해야 한다면, 왜 이미 둘 다 포함하는 도구를 사용하지 않겠습니까? (이것은 아키텍트로서 개발해야 할 또 다른 중요한 능력을 보여줍니다 - 도구의 진정한 가치를 인식하고 그 주변의 과대 광고와 구별하는 능력).

메시지 버스가 아키텍처의 중심을 형성하기 때문에, Conway의 법칙(["Conway's](#page--1-1) Law" 참조)은 이 엔진을 담당하는 통합 아키텍트 팀이 조직 내에서 정치적 세력이 되는 경향이 있으며, 결국 관료적 병목 지점이 된다고 정확하게 예측합니다.

이 중앙 집중식, 분류 체계적 접근 방식은 매력적으로 들릴 수 있지만, 실제로는 대부분 재앙으로 판명되었습니다. 트랜잭션 동작을 오케스트레이션 도구로 아웃소싱하는 것은 좋게 들리지만, 아키텍트들은 올바른 세분성을 찾는 데 어려움을 겪습니다. 분산 트랜잭션으로 래핑된 몇 개의 서비스를 구축할 수 있지만, 아키텍처는 점점 더 복잡해집니다. 엔티티가 수많은 워크플로우에 포함될 때 개발자는 서비스 간의 올바른 트랜잭션 경계가 어디에 있는지 파악해야 합니다. 관리자들이 기업이 성공적으로 트랜잭션 빌딩 블록을 엔터프라이즈 서비스로 구축할 수 있을 것이라고 예측하고 희망했지만, 이는 실제로 어려운 것으로 판명되었습니다.

#### 메시지 흐름 (Nachrichtenfluss)

모든 요청은 이 아키텍처의 로직이 위치한 오케스트레이션 엔진을 거칩니다. 따라서 메시지 흐름은 내부 호출에서도 엔진을 거치며, 이는 [그림](#page-11-0) 17-2에 나타나 있습니다.

![](_page_11_Figure_0.jpeg)

[그림](#page-11-0) 17-2에서 비즈니스 수준 서비스 CreateQuote는 워크플로우를 정의하는 서비스 버스를 호출합니다. 워크플로우는 각각 애플리케이션 서비스도 호출하는 CreateCustomer 및 CalculateQuote 서비스 호출로 구성됩니다. 서비스 버스는 이 아키텍처 내의 모든 호출에 대한 중개자 역할을 하며, 통합 허브이자 오케스트레이션 머신으로 작동합니다.

### <span id="page-12-0"></span>재사용...과 결합 (Wiederverwendung...und Kopplung)

이 아키텍처를 처음 배치한 아키텍트의 주요 목표 중 하나는 서비스 수준에서의 재사용, 즉 시간이 지남에 따라 반복해서 사용할 수 있는 비즈니스 동작을 점진적으로 구축할 수 있는 능력이었습니다. 그들은 가능한 한 공격적으로 재사용 기회를 찾도록 지시받았습니다.

예를 들어, [그림](#page-13-0) 17-3에 나타난 상황을 고려해 봅시다: 아키텍트는 보험 회사의 6개 부서 각각이 Customer라는 개념을 가지고 있음을 발견합니다.

<span id="page-13-0"></span>

그림 17-3. 서비스 지향 아키텍처에서 재사용 기회 찾기

따라서 올바른 SOA 전략은 Customer의 부분을 재사용 가능한 서비스로 추출한 다음 원래 서비스가 정규 Customer 서비스를 참조할 수 있도록 하는 것입니다. 이는 [그림](#page-14-0) 17-4에서 볼 수 있습니다: 여기서 아키텍트는 모든 고객 동작을 단일 Customer 서비스에 격리하여 명백한 재사용 목표를 달성했습니다.

<span id="page-14-0"></span>![](_page_14_Figure_1.jpeg)

그림 17-4. 서비스 지향 아키텍처에서 정규 표현 구축

아키텍트들은 이 설계의 부정적인 트레이드오프를 천천히만 인식했습니다. 첫째, 팀이 주로 재사용을 기반으로 시스템을 구축하면, 구성 요소 간에 강한 결합도 발생합니다. 결국, 재사용은 *결합을 통해* 실현됩니다. 예를 들어, [그림](#page-14-0) 17-4에서 Customer 서비스에 대한 변경은 다른 모든 서비스에 영향을 미칩니다. 이는 점진적인 변경조차도 위험하게 만듭니다: 모든 변경은 잠재적으로 큰 파급 효과를 가집니다. 이는 차례로 조정된 배포, 전체적인 테스트 및 기술적 효율성에 대한 기타 장애물을 요구합니다.

한 곳에 동작을 통합하는 또 다른 부정적인 부작용: [그림](#page-14-0) 17-4에서 자동차 및 장애 보험의 경우를 고려해 봅시다. 단일 Customer 서비스를 지원하기 위해, 각 부서는 회사가 고객에 대해 아는 모든 세부 정보를 포함해야 합니다. 자동차 보험에는 운전면허증이 필요한데, 이는 차량이 아닌 사람의 속성입니다. 따라서 Customer 서비스는 장애 보험 부서가 신경 쓰지 않는 운전면허증에 대한 세부 정보를 포함해야 합니다. 그러나 장애 보험 팀은 단일 고객 정의의 추가 복잡성을 처리해야 합니다. 여러 면에서, DDD가 *전체적인* 재사용을 피하는 것을 고집하는 것은 이러한 유형의 아키텍처에 대한 경험 때문입니다.

오케스트레이션 기반 SOA에 대한 아마도 가장 해로운 깨달음은 기술적 분할에 너무 집중하는 아키텍처의 비실용성입니다. 분리와 재사용의 철학 관점에서는 이것이 합리적이지만, 실제로는 악몽입니다.

예를 들어, 개발자들은 종종 "CatalogCheckout에 새 주소 줄 추가"와 같은 작업을 수행합니다. CatalogCheckout과 같은 도메인 개념은 이 아키텍처에서 너무 얇게 분산되어 사실상 먼지로 갈려버립니다. SOA에서 이 작업은 다양한 수준의 수십 개의 서비스와 단일 데이터베이스 스키마의 변경을 포함할 수 있습니다. 그리고 현재 엔터프라이즈 서비스가 올바른 트랜잭션 세분성으로 정의되지 않은 경우, 개발자는 설계를 변경하거나 트랜잭션 동작을 변경하기 위해 거의 동일한 새 서비스를 생성해야 합니다. 재사용은 어디 갔습니까?

## 데이터 토폴로지 (Daten-Topologien)

이 책에서 논의하는 많은 다른 아키텍처와 달리, 이 스타일의 역사적 기원을 고려할 때 오케스트레이션 기반 SOA의 데이터 토폴로지는 그다지 흥미롭지 않습니다. 많은 부분으로 구성된 분산 아키텍처이지만, 1990년대 후반 모든 분산 아키텍처에서 일반적이었던 것처럼 일반적으로 단일(또는 소수의) 관계형 데이터베이스를 사용합니다.

트랜잭션 능력조차도 일반적으로 이 아키텍처로 이전되었고 데이터베이스에서 제거되었습니다: 메시지 버스는 종종 토폴로지 내의 각 엔티티에 대한 선언적 트랜잭션 상호 작용을 포함하여, 개발자, 아키텍트 또는 다른 사람들이 데이터베이스나 엔티티의 상황별 재사용과 독립적으로 트랜잭션 동작을 지정할 수 있도록 했습니다.

이 시대의 아키텍트들에게 데이터는 낯선 영역이었습니다. SOA 및 이벤트 기반 아키텍처 모두에서 시스템의 필수 구성 요소이지만, 당시에는 문제 도메인의 일부라기보다는 통합 지점으로 취급했습니다.

#### 정말? 선언적 트랜잭션?!? (WIRKLICH? DEKLARATIVE VORGÄNGE?!?)

예, 정말입니다. 오케스트레이션 기반 SOA의 전성기에 많은 애플리케이션 서버의 "기능" 중 하나는 구성 관리자가 작업하려는 트랜잭션 컨텍스트에 따라 개별 엔티티의 트랜잭션 범위를 변경할 수 있는 능력이었습니다. (물론 이것은 XML로 선언되었는데, 당시에는 장황하지만 쉽게 파싱할 수 있는 구성 형식을 선호했습니다.) 엔티티(EntityBeans라고 불리는 특수한 유형의 JavaBean) 선언의 일부는 아키텍트 자신이 트랜잭션 가능하거나 그렇지 않다고 선언한 워크플로우에 참여할 때의 트랜잭션 범위를 결정합니다. 애플리케이션 서버는 차례로 데이터베이스와 상호 작용하여 엔티티 및/또는 워크플로우의 원하는 동작에 해당하는 데이터베이스 트랜잭션을 생성하고 관리합니다.

이것은 두 가지 이유로 크게 실패했습니다. 첫째, 개발자가 런타임에 트랜잭션 동작이 어떻게 될지 모르면, 엔티티와 종속성이 상당히 더 복잡해집니다. 이는 개발자가 트랜잭션 범위에서만 다른 거의 동일한 버전의 엔티티를 생성하도록 강제합니다. 둘째, 공급업체가 메시지 버스를 아무리 정교하게 설계해도, 시스템이 트랜잭션을 깔끔하게 관리하는 것을 방해하는 수많은 실패 모드가 발생하는 가장자리가 항상 나타나며, 인간이 풀어야 할 불일치의 혼란을 만듭니다. 시스템의 일부 복잡하고 다층적인 기능(예: 트랜잭션)은 깔끔하게 추상화할 수 없습니다. 추상화에 너무 많은 누수가 있어서 신뢰할 수 없습니다.

## 클라우드 고려사항 (Überlegungen zur Cloud)

오케스트레이션 기반 SOA는 클라우드보다 수십 년 앞서 있으므로, 클라우드에서 이 아키텍처를 (원래 형태로) 구축하는 것에 대한 고려사항은 없습니다.

그러나 이 스타일의 현대적 사용은 통합되어야 하고 워크플로우에 참여해야 하는 클라우드 및 온프레미스 서비스에 대한 좋은 통합 아키텍처가 됩니다. 주로 통합 아키텍처이므로, 클라우드 기반 서비스 및 시설과 잘 작동합니다.

### 공통 위험 (Gemeinsame Risiken)

지난 세기 말과 이 세기 초에, 이 아키텍처의 주요 위험은 주로 비용, 구현 기간, 그리고 (충격적인 놀라움) 이러한 시스템을 유지 관리하고 업데이트하는 어려움이었습니다. 이러한 프로젝트의 대부분은 매우 비싸고 여러 해에 걸친 사업이었으며, 기업 계층 구조의 높은 수준에서 중요한 결정이 내려졌습니다. 이러한 프로젝트를 "실패"로 부르는 대신, 기업들은 대부분 DDD의 아이디어에 더 맞는 더 나은 경계를 가진 통합 아키텍처로 전환했습니다.

아키텍트가 현대 시스템에서 ESB를 통합 시설로 사용하는 경우, 가장 큰 위험은 ESB가 점진적으로 전체 아키텍처를 캡슐화하는 것입니다. 이것은 *우발적 SOA(Accidental SOA)*라고 불립니다: 아키텍트가 점진적으로 그리고 의도하지 않게 그것을 인식하지 못한 채 완전히 오케스트레이션된 SOA를 구축합니다. 우발적 SOA를 피하기 위해, 아키텍트는 오케스트레이션에 대한 합리적인 캡슐화 경계를 보장하고 트랜잭션 경계와 같은 주제에 주의를 기울여야 합니다.

### <span id="page-20-0"></span>거버넌스 (Governance)

이 아키텍처가 인기를 끌었을 때, 현대적인 전체적인 테스트는 드물었습니다. 팀들은 공식적인 품질 보증 계층 외부에서 SOA를 거의 테스트하지 않았으므로, 도구 및 프레임워크 개발자들은 개별 부분의 테스트를 용이하게 하는 데 거의 주의를 기울이지 않았습니다. 메시지 버스의 거대한 기계와 관련된 움직이는 부분에 대한 모의 객체(mocks)와 스텁(stubs)을 생성하는 일부 테스트 프레임워크가 있었지만, 항상 번거롭고 일관성이 없었습니다.

거버넌스는 동일한 제약으로 고통받았습니다. 아키텍처 거버넌스를 자동화한다는 아이디어는 테스트 자동화보다 더 낯설었습니다. 이 시기에 "거버넌스"는 중량급 프레임워크, 회의 및 코드 검토를 의미했으며 모두 수동이었습니다.

그럼에도 불구하고, 아키텍트들은 그들이 제공하는 특정 기능 믹스를 필요로 하는 기업에 ESB를 전략적으로 배치합니다. 특히, 많은 기업에는 더 현대적인 시스템과 상호 작용해야 하는 레거시 시스템이 있으며, 종종 결과를 결합하고 동작을 집계합니다 - 이 모든 것이 ESB의 핵심 기능을 설명합니다. 이러한 시나리오에서, 피트니스 함수(fitness functions)는 데이터 또는 제한된 컨텍스트가 나타나지 않아야 하는 생태계의 일부로 "누출"되는 것을 방지하는 데 중요한 역할을 할 수 있습니다.

예를 들어, ERP(Enterprise Resource Planning) 패키지, 온라인 판매 도구 및 더 현대적인 마이크로서비스 기반 회계 서비스 간을 조정하기 위해 ESB를 활용하는 시스템을 고려해 봅시다. 이 시나리오에서, 시스템은 ERP 및 판매 시스템에서만 읽고 회계 마이크로서비스에만 써야 합니다. 아키텍트는 먼저 모든 통신이 일관되게 로그에 기록되도록 하는 피트니스 함수를 생성한 다음 다음과 같은 피트니스 함수를 작성할 수 있습니다(여기서는 의사 코드로 표현):

```
READ logs for ERP into ERP-logs for past 24 hours
READ logs for Sales into Sales-logs for past 24 hours
FOREACH entry IN ERP-logs
   IF 'operation' is 'update' and 'target' != 'accounting' T
      raise fitness function violation
            "Invalid communication between integration point"
   END IF
FOREACH entry IN Sales-logs
    IF 'operation' is 'update' and 'target' != 'accounting' T
       raise fitness function violation
             "Invalid communication between integration point"
    END IF
```

이 피트니스 함수는 두 통합 지점의 로그 항목을 읽어 대상이 회계 시스템이 아닌 업데이트 작업이 발생하지 않는지 확인합니다.

이러한 피트니스 함수를 사용하여, 아키텍트는 ESB와 같은 도구를 전략적으로 배치하는 동시에 팀이 일반적으로 잘못 사용하는 위치 주변에 가드레일을 구축할 수 있습니다.

## 팀 토폴로지 고려사항 (Überlegungen zur Team-Topologie)

아키텍트들이 오케스트레이션 기반 SOA에 대한 데이터 토폴로지를 고려하지 않은 것처럼, 이 아키텍처 스타일이 인기를 끌었을 때 알려지지 않은 주제였던 팀 토폴로지에도 동일하게 적용됩니다.

실제로, 이 스타일의 엄격한 분류 체계는 아키텍트들이 팀 토폴로지의 원칙을 개발하도록 *유도한* 통신 패턴으로 작용합니다. 이 아키텍처의 *목표*는 책임의 극단적인 분리와 그에 따른 팀 구성원의 분리입니다. 이 아키텍처를 채택한 기업에서는 실제로 *비즈니스 서비스*를 개발하는 사람이 *엔터프라이즈 서비스*를 개발하는 사람과 대화하는 것이 드물었습니다. 그들은 계약 및 인터페이스와 같은 기술적 아티팩트를 통해 통신할 것으로 예상되었습니다. 이 스타일의 추상화 수준은 각각 다른 팀에 의해 구현되는 많은 통합 계층을 생성하며, 이들은 통신을 위해 엔터프라이즈 수준의 티켓팅 도구를 사용합니다. 이 스타일에서 기능을 개발하는 것이 개발자에게 시간이 오래 걸리는 이유를 이해하기 쉽습니다.

### 스타일 특성 (Stilmerkmale)

오늘날 아키텍처 스타일을 평가하는 데 사용하는 많은 기준은 오케스트레이션 기반 SOA가 인기를 끌었을 때 우선순위가 없었습니다. 애자일 소프트웨어 운동은 막 시작되었고 이 아키텍처를 사용할 가능성이 있는 대규모 조직에는 아직 침투하지 않았습니다.

[그림](#page-25-0) 17-5의 표에서 1점 평가는 특정 아키텍처 특성이 아키텍처에서 잘 지원되지 않음을 의미하는 반면, 5점 평가는 아키텍처 특성이 스타일의 가장 강력한 특성 중 하나임을 의미합니다. 스코어카드에 언급된 특성의 정의는 [4장](#page--1-0)에서 찾을 수 있습니다.

SOA는 아마도 시도된 가장 기술적으로 분할된 범용 아키텍처일 것입니다! 실제로, 이 구조의 단점에 대한 저항이 마이크로서비스와 같은 더 현대적인 아키텍처로 이어졌습니다. SOA는 분산 아키텍처이지만 두 가지 이유로 단일 퀀텀을 가집니다. 첫째, 일반적으로 단일 또는 소수의 데이터베이스가 사용되어 많은 다른 관심사 간에 결합 지점을 생성합니다. 둘째, 더 중요한 것은 오케스트레이션 엔진이 거대한 결합 지점으로 작용한다는 것입니다 - 아키텍처의 어떤 부분도 모든 동작을 오케스트레이션하는 중재자와 다른 특성을 가질 수 없습니다. 따라서 이 아키텍처는 모놀리식 *및* 분산 아키텍처의 단점을 결합합니다.

|             | Architectural characteristic | Star rating                      |
|-------------|------------------------------|----------------------------------|
|             | Overall cost                 | $$$$                             |
| Structural  | Partitioning type            | Technical                        |
|             | Number of quanta             | 1 to many                        |
|             | Simplicity                   | ☆                                |
|             | Modularity                   | ***                              |
| Engineering | Maintainability              | ☆                                |
|             | Testability                  | ☆                                |
|             | Deployability                | ☆                                |
|             | Evolvability                 | ☆                                |
| Operational | Responsiveness               | ☆☆                               |
|             | Scalability                  | ***                              |
|             | Elasticity                   | ***                              |
|             | Fault tolerance              | ***                              |

배포 가능성 및 테스트 가능성과 같은 현대적인 기술 목표는 이 아키텍처에서 재앙적으로 낮은 점수를 받는데, 이는 잘 지원되지 않기 때문이기도 하지만 개발 당시 이러한 목표가 중요하지 않았거나 심지어 추구되지도 않았기 때문입니다.

이 아키텍처는 탄력성 및 확장성과 같은 일부 목표를 지원하지만, 구현하기는 어렵습니다. 도구 공급업체는 애플리케이션 서버 간 세션 복제 및 기타 기술을 개발하여 이러한 시스템을 확장 가능하게 만들기 위해 엄청난 노력을 기울였습니다. 그러나 분산 아키텍처이기 때문에, 각 비즈니스 요청이 아키텍처의 많은 부분에 분산되어 있어 성능은 결코 하이라이트가 아니었습니다.

이 모든 요인으로 인해, 단순성과 비용은 대부분의 아키텍트가 선호하는 것과 반대 관계에 있습니다. 오케스트레이션 기반 SOA는 아키텍트에게 기술적 분할의 실질적인 한계를 보여주고 분산 트랜잭션이 현실 세계에서 얼마나 어려운지를 보여준 중요한 이정표였습니다.

## 예제 및 사용 사례 (Beispiele und Anwendungsfälle)

이 아키텍처의 첫 번째 예는 1990년대 후반과 2000년대 초반 많은 대기업에서 나타났습니다. 그들은 마이크로서비스와 같은 애자일하고 도메인 기반 분산 아키텍처로 점진적으로 대체되었습니다. 대기업조차도 변화가 불가피하며 소프트웨어가 정적이지 않고 시장 세력과 새로운 가능성에 따라 변경되어야 함을 인식했습니다.

아키텍트들은 대규모 조직에서 효과적인 재사용을 달성하기 위해 오케스트레이션 기반 SOA 아키텍처를 개발했지만, 결국 엄격하고 정교한 분류 체계가 일반적인 변경 및 업데이트를 구현하기 얼마나 어렵게 만드는지 깨달았습니다. 예를 들어, 도메인의 일반적인 변경은 단일 엔티티에 대한 세부 정보를 업데이트하는 것일 수 있습니다. 개발자가 운이 좋으면 엔터프라이즈 서비스 계층의 구성 요소만 변경하면 됩니다. 나쁜 날(엔터프라이즈 아키텍트 및/또는 이해 관계자가 이러한 종류의 변경을 예상하지 못한 경우), 개발자는 아키텍처의 4~5개 계층을 업데이트하고 각 계층에서 강하게 결합된 변경을 수행해야 할 수도 있습니다. 이 스타일에서 작업하는 아키텍트들은 "*변경*"이라는 단어를 듣는 것을 두려워하는데, 이는 철저한 분석이 필요하고 작업 범위가 매우 가변적이기 때문입니다.

["거버넌스"](#page-20-0)에서 언급했듯이, 아키텍트들은 특히 통합 아키텍처를 위해 오케스트레이션 기반 SOA의 빌딩 블록(ESB 등)을 여전히 사용합니다. 예를 들어, ESB는 통합 허브(통신, 프로토콜 및 계약 변환을 용이하게 함)와 오케스트레이션 엔진(아키텍트가 다양한 통합 엔드포인트 간에 워크플로우를 생성할 수 있도록 함)을 모두 포함합니다. 오케스트레이션 기반 SOA는 많은 간접 계층을 포함하므로, 아키텍트는 [그림](#page-29-0) 17-6에 나타난 것처럼 엔터프라이즈 서비스를 통합 지점, 패키지 소프트웨어 또는 맞춤형 코드로 구현할 수 있습니다.

클라이언트 요청은 메시지 버스를 사용하여 어떤 엔터프라이즈 서비스를 어떤 순서로 호출해야 하는지, 어떤 정보를 수집해야 하는지를 결정합니다. 엔터프라이즈 서비스는 차례로 API를 통해 사용자 정의 코드, 레거시 시스템 또는 패키지 소프트웨어 등과 통신합니다.

오케스트레이션 기반 SOA는 아키텍트가 생태계 내 통합 문제를 처리하는 방식에 대한 흥미로운 혁신을 나타냅니다. 예를 들어, 이 아키텍처가 인기를 끌었을 때 대부분의 기업은 아직 오픈소스 운영체제를 사용하지 않았기 때문에, 마이크로서비스와 같은 대안 아키텍처는 감당할 수 없었습니다. 아키텍트는 과거의 접근 방식에서 배워야 합니다. 우리는 여전히 의미가 있는 부분을 재사용할 수 있으며, 동시에 실패한 것과 그 이유에서 교훈을 얻을 수 있습니다.

![](_page_29_Figure_0.jpeg)

그림 17-6. 이 아키텍처 스타일의 추상화 계층은 유연한 구현을 가능하게 합니다
