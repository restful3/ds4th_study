# 오케스트레이션 기반 서비스 지향 아키텍처(SOA) 브리핑 문서

## Executive Summary

**오케스트레이션 기반 서비스 지향 아키텍처(Service-Oriented Architecture, SOA)**는 1990년대 후반에 등장한 아키텍처 스타일로, 엄격하고 기술적으로 분할된 **서비스 분류 체계(Taxonomy)**를 통해 **엔터프라이즈 수준의 재사용성**을 극대화하는 것을 목표로 했습니다. 이 아키텍처의 핵심에는 **오케스트레이션 엔진**과 통합 허브를 포함하는 **엔터프라이즈 서비스 버스(Enterprise Service Bus, ESB)**가 자리 잡고 있으며, 그 주위로 비즈니스 서비스, 엔터프라이즈 서비스, 애플리케이션 서비스, 인프라스트럭처 서비스가 계층적으로 구성됩니다.

당시 고가의 컴퓨팅 자원과 기업 합병으로 인한 정보 및 워크플로우 중복 문제를 해결하기 위해 **'모든 것을 재사용'**하려는 철학이 이 아키텍처의 등장을 촉진했습니다. 그러나 재사용에 대한 과도한 집착은 심각한 부작용을 낳았습니다. 서비스 간의 **강한 결합(coupling)**을 유발하여 사소한 변경조차 시스템 전체에 영향을 미치는 리스크를 만들었으며, 개발 주기를 늦추고 유지보수를 극도로 어렵게 만들었습니다. 결과적으로 이 아키텍처는 중앙 집중식 데이터베이스와 ESB로 인한 **단일 배포 단위(quantum)**라는 모놀리식 시스템의 단점과, 네트워크 통신 오버헤드라는 분산 시스템의 단점을 모두 갖게 되는 역설적인 상황에 이르렀습니다.

현재 완전한 형태의 오케스트레이션 기반 SOA는 거의 사용되지 않지만, 그 구성 요소인 ESB는 **레거시 시스템과 최신 서비스를 연동**하는 등 통합이 복잡한 시나리오에서 여전히 유용한 도구로 활용됩니다. 이 아키텍처는 **기술적 분할의 실용적 한계**와 **재사용성과 결합도 사이의 트레이드오프**관계를 보여주는 강력한 교훈을 남겼으며, 아키텍트는 이를 통해 아키텍처의 실패와 성공 요인을 학습할 수 있습니다.

![오케스트레이션 기반 서비스 지향 아키텍처(SOA): 재사용의 이상과 현실](unnamed.png)

--------------------------------------------------------------------------------


## 1. 개요 및 역사적 배경

오케스트레이션 기반 SOA는 특정 시대적 맥락에서 의미가 있었으나 시간이 지나며 중요성을 잃어버린 아키텍처 스타일의 대표적인 예시입니다. 이 스타일은 **소프트웨어 아키텍처의 제1법칙**인 **"모든 것은 트레이드오프다"**를 무시했을 때 발생하는 위험을 명확히 보여줍니다.

이 아키텍처는 **1990년대 후반**, 많은 기업들이 빠르게 성장하고 합병을 거듭하며 복잡한 IT 요구사항에 직면했던 시기에 등장했습니다. 당시에는 다음과 같은 외부 요인들이 아키텍처 결정에 큰 영향을 미쳤습니다.

* **고가의 컴퓨팅 자원**: 오픈 소스가 신뢰를 얻기 전이었기 때문에 운영 체제(OS)와 데이터베이스 서버는 라이선스 비용이 매우 비쌌습니다. 이로 인해 아키텍트들은 가능한 모든 것을 **재사용하여 비용을 절감**하려는 철학을 추구했습니다.
* **조직적 문제**: 잦은 합병과 성장으로 인해 기업 내 핵심 사업부 간 정보와 워크플로우가 중복되고 비일관성이 발생하는 문제가 심각했습니다.

이러한 기술적, 조직적 배경 속에서 모든 형태의 '재사용'을 최우선 목표로 삼는 오케스트레이션 기반 SOA가 매력적인 해결책으로 부상했습니다.

## 2. 아키텍처 토폴로지 및 서비스 분류 체계

이 아키텍처의 핵심 철학은 엄격한 **서비스 분류 체계(Taxonomy)**를 통해 **엔터프라이즈 수준의 추상화와 재사용**을 달성하는 것입니다. 토폴로지는 일반적으로 다음과 같은 **계층 구조**를 따릅니다.

각 계층은 명확하게 정의된 책임을 가지며, **궁극적인 추상화와 재사용**이라는 두 가지 목표를 지원합니다.

* **비즈니스 서비스(Business Services)**: 아키텍처의 최상단에 위치하며 **비즈니스 프로세스의 진입점**역할을 합니다. ExecuteTrade(거래 실행)나 PlaceOrder(주문 접수)와 같이 비즈니스 관점에서 의미 있는 거시적인 단위로 정의됩니다. 이 서비스는 **코드 구현 없이 입력, 출력, 스키마 정보만 포함**하며, 주로 비즈니스 분석가나 현업 사용자가 정의합니다.
* **엔터프라이즈 서비스(Enterprise Services)**: 비즈니스 서비스를 구성하는 **재사용 가능한 세분화된 구현체**입니다. CreateCustomer(고객 생성)나 CalculateQuote(견적 계산)와 같이 특정 비즈니스 도메인을 위한 **원자적(atomic)인 행위**를 구현합니다. 완벽하게 캡슐화된 이 서비스들을 조합하여 더 복잡한 비즈니스 워크플로우를 만드는 것이 목표였습니다.
* **애플리케이션 서비스(Application Services)**: 재사용성이 중요하지 않은 **특정 애플리케이션만을 위한 일회성 서비스**입니다. 예를 들어, 특정 애플리케이션에만 필요한 지리 위치(geolocation) 서비스가 이에 해당합니다.
* **인프라스트럭처 서비스(Infrastructure Services)**: 모니터링, 로깅, 인증/인가와 같은 **운영 관련 공통 기능**을 제공합니다. 일반적으로 중앙 인프라팀이 관리합니다.

## 3. 핵심 구성요소: 오케스트레이션 엔진과 ESB

**오케스트레이션 엔진**과 이를 포함하는 **엔터프라이즈 서비스 버스(ESB)**는 이 아키텍처의 **심장부**역할을 합니다.

* **핵심 기능**:
  * **워크플로우 조합**: 여러 엔터프라이즈 서비스를 엮어 비즈니스 서비스의 워크플로우를 정의하고 실행합니다.
  * **트랜잭션 조정 및 메시지 변환**: 분산된 서비스 간의 트랜잭션을 관리하고 데이터 형식을 변환합니다.
  * **통합 허브**: 레거시 시스템이나 패키지 소프트웨어와 같은 외부 시스템을 연동하는 중심점 역할을 합니다.
* **메시지 흐름**: 모든 요청은 내부 서비스 간 호출을 포함하여 **반드시 ESB를 통과**합니다. ESB는 모든 호출의 **중재자**로서 워크플로우를 통제합니다. 예를 들어 CreateQuote라는 비즈니스 서비스 요청이 들어오면, ESB는 워크플로우에 따라 CreateCustomer와 CalculateQuote 엔터프라이즈 서비스를 순차적으로 호출합니다.
* **콘웨이의 법칙(Conway's Law)**: ESB가 아키텍처의 중심이 되면서, 이를 관리하는 통합 아키텍트팀이 조직 내에서 **정치적 권력의 중심**이 되거나 **관료적인 병목 지점**으로 전락하는 경향이 있었습니다.

## 4. 재사용의 함정: 강한 결합도

이 아키텍처의 주된 목표는 **서비스 수준의 재사용**이었지만, 이는 심각한 부작용을 낳았습니다. **재사용은 본질적으로 컴포넌트 간의 결합(coupling)을 통해 실현**되기 때문입니다.

* **예시**: 한 보험사에 자동차, 생명, 상업 등 6개의 사업부가 있고 각자 **'고객(Customer)' 개념** 을 사용한다고 가정해 봅시다. SOA 전략에 따라 이들을 **Customer라는 단일 표준 서비스** 로 통합합니다.



* **부정적 결과**:
  1. **강한 결합**: 중앙의 Customer 서비스를 변경하면, 이를 사용하는 6개 사업부 모두가 영향을 받습니다. 이로 인해 작은 변경조차도 리스크가 커지고, 전체 시스템에 대한 **테스트와 조정된 배포**가 필요해져 민첩성이 크게 저하됩니다.
  2. **불필요한 복잡성 증가**: 단일 Customer 서비스는 모든 사업부에서 요구하는 모든 데이터를 포함해야 합니다. 예를 들어, 자동차 보험에 필요한 '운전면허증' 정보가 장애 보험 사업부에는 불필요함에도 불구하고 Customer 서비스에 포함되어야 합니다. 이는 특정 **도메인 컨텍스트**를 중시하는 **도메인 주도 설계(DDD)**가 이러한 통합적 재사용을 피하라고 권고하는 주된 이유가 되었습니다.
  3. **기술적 분할의 악몽**: '카탈로그 결제에 주소 필드 추가'와 같은 간단한 요구사항 변경도 비즈니스 서비스, 엔터프라이즈 서비스, 데이터베이스 스키마 등 수많은 계층에 걸쳐 수십 개의 서비스를 수정해야 하는 복잡한 작업으로 변질되었습니다.

## 5. 아키텍처 특성 분석

오케스트레이션 기반 SOA의 특성을 **현대적인 기준**으로 평가하면 다음과 같습니다.

아키텍처 특성	구분	별점 평가
전체 비용 (Overall cost)		
분할 유형 (Partitioning type)	구조적	기술적 (Technical)
퀀텀 수 (Number of quanta)	구조적	1 to many
단순성 (Simplicity)	구조적	★☆☆☆☆
모듈성 (Modularity)	구조적	★★★★☆
유지보수성 (Maintainability)	엔지니어링	★☆☆☆☆
테스트 용이성 (Testability)	엔지니어링	★☆☆☆☆
배포 용이성 (Deployability)	엔지니어링	★☆☆☆☆
발전 가능성 (Evolvability)	엔지니어링	★☆☆☆☆
응답성 (Responsiveness)	운영	★★☆☆☆
확장성 (Scalability)	운영	★★★★☆
탄력성 (Elasticity)	운영	★★★☆☆
장애 허용성 (Fault tolerance)	운영	★★★★☆

* **종합 평가**: 이 아키텍처는 **극단적인 기술적 분할**을 시도했지만, 중앙 ESB와 단일 데이터베이스로 인해 전체 시스템이 하나의 배포 단위(quantum)처럼 움직이는 **모놀리식의 단점**과, **분산 아키텍처의 성능 저하**라는 단점을 동시에 갖게 되었습니다. 유지보수성, 테스트 용이성, 발전 가능성과 같은 현대적 엔지니어링 목표에서는 최악의 평가를 받습니다.
* **데이터 및 팀 토폴로지**:
  * **데이터 토폴로지**: 일반적으로 **단일 관계형 데이터베이스**를 사용했습니다. 트랜잭션 관리는 데이터베이스가 아닌 ESB에서 선언적으로 처리하도록 시도되었으나, 추상화의 한계로 인해 실패하고 **데이터 불일치**를 유발했습니다.
  * **팀 토폴로지**: 엄격한 계층 구조는 **팀 간의 사일로(silo)**를 강화했습니다. 다른 계층의 팀원들은 직접 소통하는 대신 기술적 문서나 티켓팅 시스템을 통해 소통하여 기능 개발 속도를 현저히 저하시켰습니다.

## 6. 현대적 적용 및 교훈

* **역사적 의의**: 오케스트레이션 기반 SOA는 그 자체로는 **실패한 아키텍처**로 평가받지만, **기술적 분할의 실용적 한계**와 **분산 트랜잭션의 어려움**을 명확히 보여준 중요한 이정표였습니다. 이러한 경험은 **마이크로서비스**와 같은 현대적인 아키텍처의 탄생에 영향을 미쳤습니다.
* **현대적 활용 사례**: 아키텍처 스타일 전체가 아닌, ESB와 같은 핵심 구성 요소는 오늘날에도 특정 목적을 위해 전략적으로 사용됩니다. 특히 **클라우드 서비스, 온프레미스 애플리케이션, 레거시 시스템이 혼재**하는 환경에서 이들을 연동하고 워크플로우를 조율하는 **통합 아키텍처**로 유용합니다.
* **'우발적 SOA(Accidental SOA)'의 위험**: ESB를 통합 목적으로 사용하다가 점차 비즈니스 로직과 오케스트레이션 역할이 비대해져 의도치 않게 전체 아키텍처가 오케스트레이션 기반 SOA로 변질되는 위험을 경계해야 합니다.
* **피트니스 함수를 통한 거버넌스**: 현대적인 시스템에서는 **아키텍처 피트니스 함수(fitness function)**를 도입하여 ESB의 역할을 제한하는 **'가드레일'**을 만들 수 있습니다. 예를 들어, 특정 시스템이 회계 마이크로서비스에 데이터를 '쓰기'만 가능하고 다른 시스템은 수정할 수 없도록 강제하는 규칙을 코드로 자동 검증할 수 있습니다.

결론적으로, 오케스트레이션 기반 SOA는 과거의 접근 방식에서 실패 원인을 배우고, 여전히 유효한 부분(예: 통합 허브로서의 ESB)은 선별적으로 활용하며 더 나은 아키텍처를 설계하는 데 중요한 교훈을 제공합니다.
