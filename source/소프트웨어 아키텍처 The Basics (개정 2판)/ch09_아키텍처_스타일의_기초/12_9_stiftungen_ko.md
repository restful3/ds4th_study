# 9장. 기초 (Kapitel 9. Fundamente)

이 작업은 AI의 도움으로 번역되었습니다. 피드백과 의견을 환영합니다: [translation-feedback@oreilly.com](mailto:translation-feedback@oreilly.com)

아키텍처 스타일과 패턴에 대한 세부 사항으로 넘어가고 싶겠지만, 먼저 이후 장에 적절한 맥락을 제공하기 위해 몇 가지 기본적이고 정의적인 내용을 다루어야 합니다.

# 패턴이 아닌 스타일

먼저 *아키텍처 스타일(Architekturstile)*과 *아키텍처 패턴(Architekturmuster)*을 구별해야 하는데, 이 둘은 혼동하기 쉽습니다.

아키텍처 스타일은 다음과 같은 아키텍처의 다양한 특성을 설명합니다:

#### *컴포넌트 토폴로지(Komponententopologie)*

아키텍처 스타일은 컴포넌트와 그 의존성이 어떻게 구성되는지를 정의합니다. 예를 들어, 계층화 아키텍처(Schichtenarchitektur)에서는 컴포넌트가 기술적 능력에 따라 구조화되는 반면, 모듈형 모놀리스(modularer Monolith)에서는 컴포넌트가 도메인에 따라 정렬됩니다("아키텍처 [파티셔닝"](#architectural-partitioning) 참조).

#### *물리적 아키텍처(Physikalische Architektur)*

스타일은 종종 물리적 아키텍처의 유형, 즉 모놀리식 또는 분산형을 지시합니다. 예를 들어, 모듈형 모놀리스는 일반적으로 단일 데이터베이스를 가진 모놀리식 아키텍처인 반면, 이벤트 기반 아키텍처(ereignisgesteuerte Architektur)는 항상 분산되어 있습니다.

#### *배포(Einsatz)*

시스템의 세분성과 배포 빈도는 종종 아키텍처 스타일과 연결되어 있습니다. 모놀리식 아키텍처는 일반적으로 단일 관계형 데이터베이스와 함께 단일 구현으로 배포됩니다. 반면 마이크로서비스와 같은 고도로 민첩한 분산 아키텍처는 자동화된 통합, 자동화된 배포, 때로는 자동화된 제공을 특징으로 하며, 일반적으로 점진적으로 훨씬 더 빠른 속도로 배포됩니다.

#### *통신 스타일(Kommunikationsstil)*

아키텍처 스타일은 또한 컴포넌트가 서로 통신하는 방식을 결정합니다. 모놀리식 아키텍처는 모놀리스 내에서 메서드 호출을 수행할 수 있는 반면, 분산 아키텍처는 REST나 메시지 큐와 같은 네트워크 프로토콜을 통해 통신합니다.

#### *데이터 토폴로지(Datentopologie)*

컴포넌트 토폴로지와 마찬가지로 시스템의 데이터 토폴로지도 종종 아키텍처 스타일에 의해 결정됩니다.

모놀리식 아키텍처는 일반적으로 모놀리식 데이터베이스를 가지는 반면, 분산 아키텍처에서는 아키텍처 스타일의 철학에 따라 때때로 데이터가 분리됩니다.

스타일에 이름을 붙이는 것은 이러한 복잡한 일련의 요소를 설명하는 간결한 방법을 제공합니다. 각 이름은 풍부한 세부사항을 요약합니다 - 이것이 디자인 패턴의 목적 중 하나입니다. 그러나 패턴이 문맥적 솔루션을 설명하는 반면, 스타일은 아키텍처에 더 특정적이며 위에서 언급한 측면을 설명합니다. 아키텍처 스타일은 아키텍처의 토폴로지와 그 가정된 및 기본 속성(유리한 것과 불리한 것 모두)을 설명합니다. [20장](#page--1-0)에서는 몇 가지 일반적인 현대 아키텍처 패턴에 대해 다룰 것입니다. 아키텍트는 시스템의 공통 구성 요소를 나타내는 몇 가지 기본 스타일에 익숙해야 합니다.

#### **아키텍처 스타일은 어디에서 오는가?**

일반적인 믿음과는 달리, 상아탑에서 만나 다음에 어떤 새로운 아키텍처 스타일이 올지 결정하는 공식적인 아키텍트 위원회는 없습니다. 오히려 새로운 스타일은 아키텍트가 일하는 끊임없이 진화하는 생태계에서 나타납니다.

영리한 아키텍트가 생태계에 막 등장한 새로운 기능이 자신을 괴롭히는 특정 문제를 해결한다는 것을 발견했다고 가정해 봅시다. 그는 그것을 새로운 것과 오래된 것 여러 가지와 결합하기로 결정합니다. 다른 아키텍트들이 이 영리한 솔루션을 보고 복사합니다. 그것이 너무 일상화되어서 이름을 붙이면 더 쉽게 이야기할 수 있게 됩니다.

마이크로서비스 아키텍처는 이러한 현상의 좋은 예입니다. 새로운 DevOps 기능, 신뢰할 수 있는 오픈 소스 운영 체제, 도메인 중심 설계 철학의 출현으로 아키텍트들이 확장성과 같은 문제를 해결하기 위해 새로운 방식으로 시스템을 구축할 수 있게 되었습니다. *마이크로서비스(Microservices)*라는 이름은 당시 일반적이었던 대규모 서비스와 광범위한 오케스트레이션을 제공하는 아키텍처 스타일에 대한 반응으로 생겨났습니다. 마이크로서비스는 설명이 아니라 명칭입니다. 팀에게 가능한 한 가장 작은 서비스를 구축하라는 명령이 아니라 아키텍처 스타일의 명칭입니다.

# 기본 패턴

소프트웨어 아키텍처의 역사에서 일부 기본 패턴은 계속해서 나타나는데, 이는 일반적으로 코드, 구현 또는 아키텍처의 다른 측면을 구성하는 데 유용한 관점을 제공하기 때문입니다. 예를 들어, 기능에 기반하여 다양한 관심사를 분리하는 계층(Schichten) 개념은 소프트웨어만큼이나 오래되었습니다. 그럼에도 불구하고 계층은 (스타일과 패턴 모두에서) [10장](#page--1-0)에서 논의할 현대적 변형을 포함하여 다양한 형태로 계속 나타납니다.

불행히도 아키텍처의 부재로 인해 발생하는 또 다른 일반적인 패턴이 있습니다: Big Ball of Mud입니다.

### **Big Ball of Mud (거대한 진흙 덩어리)**

아키텍트들은 인식할 수 있는 아키텍처 구조의 부재를 *Big Ball of Mud*라고 부르는데, 이는 Brian Foote와 Joseph Yoder가 1997년 Patterns Languages of Programs 컨퍼런스에서 발표한 논문에서 정의한 안티패턴의 이름을 따온 것입니다.

*Big Ball of Mud는 무계획적으로 구조화되고, 광범위하게 퍼지며, 엉성한 스파게티 코드 정글로, 테이프와 와이어로 함께 묶여 있습니다. 이러한 시스템은 통제되지 않은 성장과 반복적이고 즉흥적인 수리의 명백한 징후를 보입니다. 정보는 시스템의 먼 요소들 사이에서 무분별하게 교환되며, 종종 거의 모든 중요한 정보가 전역적이거나 중복되는 정도까지 이릅니다.*

*시스템의 전체 구조는 결코 정확하게 정의되지 않았을 수 있습니다.*

*만약 그랬다면, 알아볼 수 없을 정도로 침식되었을 수 있습니다. 아키텍처적 감각이 있는 프로그래머들은 이러한 늪지대를 피합니다. 아키텍처에 관심이 없고 실패하는 제방의 구멍을 매일 패치하는 관성에 개의치 않는 사람들만이 그러한 시스템에서 기꺼이 일합니다.*

오늘날 *Big Ball of Mud*는 실제 내부 구조가 없는 간단한 스크립트 애플리케이션으로, 이벤트 핸들러가 데이터베이스 호출과 직접 연결되어 있을 수 있습니다. 많은 사소한 애플리케이션이 이렇게 시작하여 성장하면서 다루기 어려워집니다.

일반적으로 이러한 유형의 아키텍처는 반드시 피해야 합니다. 구조의 부재는 변경을 점점 더 어렵게 만듭니다. 이러한 아키텍처는 배포, 테스트 가능성, 확장성 및 성능 문제로도 어려움을 겪습니다. 이러한 시스템이 커질수록

아키텍처 부재로 인한 문제가 더 악화됩니다.

불행히도 이러한 행동 패턴은 실제로 상당히 자주 발생합니다. 혼란을 만들려는 의도를 가진 아키텍트는 거의 없지만, 많은 프로젝트가 의도치 않게 혼란을 만들어냅니다. 주로 코드 품질과 구조에 대한 통제 부족 때문입니다. 예를 들어, Neal은 [그림](#big-ball-of-mud-diagram) 9-1에 표시된 구조를 가진 고객 프로젝트에서 작업했습니다.

고객(명백한 이유로 이름은 밝히지 않음)은 몇 년 동안 가능한 한 빨리 Java 기반 웹 애플리케이션을 만들었습니다. [그림](#big-ball-of-mud-diagram) 9-1의 기술적 시각화는 결합을 보여줍니다: 원의 가장자리에 있는 각 점은 클래스를 나타내며, 각 선은 클래스 간의 연결을 나타내고, 더 굵은 선은 더 강한 연결을 나타냅니다. 이 코드베이스에서 클래스가 변경되면 다른 클래스에 미치는 영향을 예측하기 어려워 변경이 두려운 일이 됩니다.

<span id="big-ball-of-mud-diagram"></span>![](_page_7_Picture_0.jpeg)

그림 9-1. 실제 코드베이스를 기반으로 시각화된 Big Ball of Mud 아키텍처. (이제 중단된 Eclipse 플러그인 XRay라는 도구로 생성)

Big Ball of Mud 아키텍처의 문제는 단순히 구조의 부재만이 아닙니다. 모든 것이 모든 것과 연결되어 있기 때문에 변경은 종종 예측하기 어려운 부작용을 가져옵니다. 이 문제는 개발자들이 새로운 기능을 작업하는 대신 버그와 그 부작용을 쫓는 데 모든 시간을 보내는 임계점에 도달할 수 있습니다.

## **통합 아키텍처(Einheitliche Architektur)**

처음에는 컴퓨터와 그 위에서 실행되는 소프트웨어만 있었습니다. 둘은 처음에는 하나였고, 점점 더 정교한 기능이 필요해짐에 따라 개발 과정에서 분리되었습니다. 예를 들어, 메인프레임은 처음에는 단일 시스템이었고, 그 후 데이터가 점차 별도의 시스템 유형으로 분리되었습니다. 개인용 컴퓨터(PC)의 개발도 처음에는 개별 장치에 중점을 두었습니다. PC 네트워킹이 확립되면서 분산 시스템(클라이언트/서버 같은)이 등장했습니다.

### **클라이언트/서버(Client/Server)**

임베디드 시스템 및 기타 고도로 제한된 환경을 제외하고는 통합 아키텍처가 거의 없습니다. 일반적으로 소프트웨어 시스템은 시간이 지남에 따라 더 많은 기능을 추가하는 경향이 있으므로 성능 및 확장성과 같은 아키텍처 속성을 유지하기 위해 영역의 분리가 필요합니다.

많은 아키텍처 스타일은 시스템의 부분을 효율적으로 분리하는 방법을 다룹니다. 기본 아키텍처 스타일은 프론트엔드와 백엔드 간의 기술적 기능을 분리합니다: 이를 *2계층(zweistufig)* 또는 *클라이언트/서버 아키텍처(Client/Server-Architektur)*라고 합니다. 시스템의 시대와 컴퓨팅 능력에 따라 다양한 변형이 있습니다.

### **데스크톱과 데이터베이스 서버(Desktop und Datenbankserver)**

초기 PC 아키텍처는 개발자들이 Windows와 같은 사용자 인터페이스에서 광범위한 데스크톱 애플리케이션을 작성하고 별도의 데이터베이스 서버에 데이터를 저장하도록 장려했습니다. 이 아키텍처는 표준 네트워크 프로토콜을 통해 연결될 수 있는 독립형 데이터베이스 서버의 출현과 일치했습니다. 이를 통해 프레젠테이션 로직을 데스크톱에 배치하고 더 계산 집약적인 작업(범위와 복잡성 측면 모두에서)을 더 견고한 데이터베이스 서버에서 수행할 수 있었습니다.

#### **브라우저와 웹 서버(Browser und Webserver)**

현대 웹 개발이 등장하면서 아키텍처를 웹 서버에 연결된 웹 브라우저로 분할하는 것이 일반화되었습니다(웹 서버는 다시 데이터베이스 서버에 연결됨). 이러한 책임의 분리는 데스크톱 변형과 유사했지만 브라우저로서 훨씬 더 얇은 클라이언트로, 방화벽 내부와 외부 모두에서 더 광범위한 배포를 가능하게 했습니다. 데이터베이스가 웹 서버와 분리되어 있더라도 많은 아키텍트들은 웹 서버와 데이터베이스 서버가 운영 센터의 한 클래스의 컴퓨터에서 실행되는 반면 사용자 인터페이스는 사용자의 브라우저에서 실행되기 때문에 이 아키텍처를 여전히 2계층으로 간주합니다.

### **단일 페이지 JavaScript 애플리케이션(Einseitige JavaScript-Anwendungen)**

인터넷의 응답성이 향상됨에 따라 브라우저의 JavaScript 구현도 개선되었습니다. 그것은

클라이언트/서버 스타일의 애플리케이션 제품군이 등장했는데, 이는 원래의 데스크톱 변형과 유사했지만 리치 클라이언트가 데스크톱 애플리케이션이 아니라 브라우저에서 JavaScript로 작성되었습니다.

이 섹션이 보여주듯이, 애플리케이션의 요구사항과 플랫폼의 가능성에 따라 아키텍처의 다른 부분을 분리하는 계층은 항상 존재할 것입니다.

#### **3계층(Dreistufig)**

1990년대 후반, *3계층 아키텍처(dreistufige Architektur)*가 대중화되어 계층 간의 더욱 강력한 분리를 가능하게 했습니다. Java 및 .NET의 애플리케이션 서버와 같은 도구가 중요해지면서 기업들은 토폴로지에 더 많은 계층을 추가하기 시작했습니다. 시스템은 강력한 데이터베이스 서버가 있는 데이터베이스 계층, 애플리케이션 서버가 관리하는 애플리케이션 계층, HTML과 점점 더 JavaScript로 프로그래밍된 프론트엔드로 구성될 수 있습니다(가능성이 많을수록).

3계층 아키텍처는 분산 아키텍처 구축을 용이하게 하기 위해 CORBA(Common Object Request Broker [Architecture](https://www.corba.org/))와 DCOM(Distributed [Component](https://oreil.ly/1TEqv) Object Model)과 같은 네트워크 수준 프로토콜에 해당했습니다.

오늘날 개발자들이 TCP/IP와 같은 네트워크 프로토콜이 어떻게 작동하는지 생각하지 않는 것처럼(단순히

작동하기 때문에), 대부분의 아키텍트는 분산 아키텍처에서 이러한 종류의 배관 작업에 대해 생각할 필요가 없습니다. 당시 도구가 제공한 가능성은 오늘날 도구(메시지 큐와 같은) 또는 [아키텍처 패턴](#page--1-0)(15장에서 다루는 이벤트 기반 아키텍처와 같은)으로 존재합니다.

#### **3계층 아키텍처, 언어 설계 및 장기적 영향**

1990년대 Java 언어가 개발될 때 3계층 컴퓨팅이 최신 유행이었습니다. 미래에는 모든 시스템이 3계층 아키텍처를 가질 것이라고 가정했습니다. 당시 C++과 같은 기존 언어의 가장 일반적인 어려움 중 하나는 네트워크를 통해 시스템 간에 객체를 일관되게 이동하는 것이 매우 번거롭다는 것이었습니다. 따라서 Java 개발자들은 *직렬화(Serialisierung)*라는 메커니즘으로 이 기능을 언어의 핵심에 구축하기로 결정했습니다.

모든 Java 객체는 직렬화를 지원하는 인터페이스를 구현합니다. 개발자들은 3계층 아키텍처가 영원히 지속될 것이라고 생각했고 그것을 언어에 내장하는 것이 매우 편리할 것이라고 생각했습니다. 물론 이 아키텍처 스타일은 왔다가 사라졌지만 그 잔재는 오늘날까지 Java에 남아 있습니다. 거의 아무도 직렬화를 더 이상 사용하지 않지만, 새로운 Java 기능은 하위 호환성 이유로 이를 지원해야 하므로 언어 개발자들을 매우 좌절시킵니다.

설계 결정의 장기적 영향을 이해하는 것은 소프트웨어 개발뿐만 아니라 다른 기술 분야에서도 항상 우리를 회피해 왔습니다. 간단한 디자인을 선호하라는 끊임없는 조언은 여러 면에서 미래 보장 전략입니다.

# <span id="architectural-partitioning"></span>아키텍처 파티셔닝(Architektur Partitionierung)

소프트웨어 아키텍처의 첫 번째 법칙은 소프트웨어의 모든 것이 절충안이라고 말하며, 여기에는 아키텍트가 아키텍처에서 컴포넌트를 분할하는 방식도 포함됩니다. 컴포넌트는 일반적인 경계 메커니즘이므로 아키텍트는 원하는 대로 분할할 수 있습니다. 다양한 절충안을 포함하는 몇 가지 일반적인 스타일이 있습니다. 특정 유형의 컴포넌트 배열이 특히 큰 영향을 미칩니다: *최상위 수준 파티셔닝(Partitionierung auf oberster Ebene)*.

[그림](#partitioning-comparison) 9-2에 표시된 두 가지 아키텍처 스타일 중 하나는 많은 사람들에게 익숙할 것입니다: *계층형 모놀리스(Schichtenmonolith)* ([10장](#page--1-0)에서 자세히 다룸). 다른 하나는 *모듈형 모놀리스(modularer Monolith)*라고 하는데, Simon [Brown](https://simonbrown.je/)이 개발한 아키텍처 스타일로, 데이터베이스에 연결된 단일 배포 단위로 구성되며 기술적 능력이 아닌 도메인에 따라 분할됩니다([11장](#page--1-0) 참조). 이 두 스타일은 최상위 수준 파티셔닝의 다른 방법을 나타냅니다. 두 변형 모두에서 각 최상위 계층 또는 컴포넌트는 다른 컴포넌트를 포함할 가능성이 높습니다. 최상위 수준 파티셔닝은 기본 아키텍처 스타일과 코드를 분할하는 유형을 정의하기 때문에 아키텍트에게 특히 중요합니다.

<span id="partitioning-comparison"></span>![](_page_14_Picture_0.jpeg)

그림 9-2. 두 가지 유형의 최상위 수준 파티셔닝: 기술적(계층화 아키텍처와 같은)과 도메인(모듈형 모놀리스와 같은)

계층형 모놀리스 스타일이 하듯이 기술적 능력에 기반하여 아키텍처를 구성하는 것은 *기술적 최상위 수준 파티셔닝(technische Partitionierung auf höchster Ebene)*을 나타냅니다.

일반적인 버전은 [그림](#technical-partitioning) 9-3에서 볼 수 있는데, 여기서 아키텍트는 시스템의 기능을 *기술적* 능력으로 나눴습니다: 프레젠테이션, 비즈니스 규칙, 서비스, 지속성 등. 이러한 방식으로 코드베이스를 구성하는 것은 완전히 합리적입니다. 모든 지속성 코드가 한 계층에 있으므로 개발자가 지속성 관련 코드를 쉽게 찾을 수 있습니다. 계층화 아키텍처의 기본 개념이 수십 년 동안 알려져 있었지만, Model-View-Controller 디자인 패턴(Eric Freeman과 Elisabeth Robson의 *Head First Design [Patterns](https://www.oreilly.com/library/view/head-first-design/9781492077992)* (O'Reilly, 2020)의 기본 패턴 중 하나)이 이 아키텍처 패턴에 맞기 때문에 개발자가 이해하기 쉽습니다. 따라서 많은 기업에서 표준 아키텍처입니다.

<span id="technical-partitioning"></span>![](_page_16_Picture_0.jpeg)

그림 9-3. 아키텍처에서 최상위 수준 파티셔닝의 두 가지 유형

지배적인 계층화 아키텍처의 흥미로운 부작용은 기업이 종종 다양한 프로젝트 역할에 따라 사무실의 좌석 배치를 구성한다는 것입니다. Conway의 법칙 때문에 계층화 아키텍처를 사용하면 모든 백엔드 개발자를 한 부서에, DBA를 다른 부서에, 프레젠테이션 팀을 또 다른 부서에 모으는 것이 합리적입니다.

[그림](#technical-partitioning) 9-3의 다른 아키텍처 변형은 *도메인 파티셔닝(Domänenpartitionierung)*으로, 복잡한 소프트웨어 시스템을 분해하는 모델링 기법으로, 컴포넌트가 기술적 능력이 아닌 도메인에 따라 구성됩니다. 도메인 파티셔닝은 Eric Evans의 책 *Domain-Driven Design*에서 영감을 받았습니다. DDD에서 아키텍트는 독립적이고 서로 분리된 도메인 또는 워크플로를 식별합니다. 마이크로서비스 아키텍처 스타일은 이 철학에 기반합니다.

모듈형 모놀리식 아키텍처는 기술적 능력이 아닌 도메인 또는 워크플로에 따라 분할됩니다. 컴포넌트가 종종 중첩되기 때문에 [그림](#technical-partitioning) 9-3에 표시된 도메인별로 분할된 아키텍처의 각 컴포넌트(예: CatalogCheckout)는 지속성 라이브러리를 사용하고 비즈니스 규칙을 위한 별도의 계층을 가질 수 있지만 최상위 파티셔닝은 여전히 도메인을 중심으로 이루어집니다.

#### **Conway의 법칙(CONWAY'S GESETZ)**

1960년대 후반, Melvin [Conway](https://oreil.ly/qo59i)는 *Conway의 법칙(Conway's Law)*으로 알려진 관찰을 했습니다:

*시스템을 설계하는 조직은 해당 조직의 통신 구조를 반영하는 설계를 만들 수밖에 없습니다.*

이 법칙은 사람들의 그룹이 기술적 인공물을 설계할 때 그들의 설계 구조가 이러한 사람들이 통신하는 방식을 반영한다고 말합니다. 모든 수준의 조직에 있는 사람들은 이 법칙이 작동하는 것을 보고 때때로 이를 기반으로 결정을 내립니다. 예를 들어, 기업이 직원을 기술적 능력에 따라 나누는 것은 일반적이지만, 이것은 협업을 방해할 수 있는 인위적인 공통 관심사 분리입니다.

Thoughtworks의 Jonny Leroy가 만든 관련 관찰은 *역 Conway [기동(Inverse Conway Manöver)](https://oreil.ly/9EYd6)*으로, 원하는 아키텍처를 촉진하기 위해 팀과 조직의 구조를 공동으로 개발할 것을 제안합니다. 이 고려 사항은 이제 일반적으로 *팀 토폴로지(Teamtopologien)*로 알려져 있습니다.

기업들은 팀 토폴로지가 소프트웨어 아키텍처를 포함하여 비즈니스의 많은 중요한 측면에 상당한 영향을 미칠 수 있다는 것을 인식했습니다. 개별 스타일을 다루는 다음 장에서는 각 아키텍처 스타일이 이러한 팀 유형에 미치는 영향에 대해 논의할 것입니다.

최상위 수준 파티셔닝의 유형은 아키텍처 패턴 간의 기본적인 구별 중 하나입니다. 각 패턴이 지원하는 최상위 수준 파티셔닝의 유형입니다. 스타일별 장에서는 각 개별 패턴에 대한 이러한 구별을 다룰 것입니다. 최상위 수준 파티셔닝은 아키텍트가 컴포넌트를 기술적으로 먼저 식별할지 도메인별로 식별할지 결정하는 데도 큰 영향을 미칩니다.

기술적 파티셔닝을 사용하는 아키텍트는 시스템의 컴포넌트를 기술적 능력에 따라 구성합니다: 프레젠테이션, 비즈니스 규칙, 지속성 등. 계층화 아키텍처의 조직 원칙 중 하나는 *기술적 관심사의 분리(Trennung der technischen Belange)*로, 유용한 분리 수준을 만듭니다. 예를 들어, 서비스 계층이 아래의 지속성 계층과 위의 비즈니스 규칙 계층에만 연결되어 있다면 지속성의 변경은 이러한 계층에만 영향을 미칩니다. 이러한 분리는 종속 컴포넌트에 대한 부작용의 위험을 줄입니다.

기술적 파티셔닝을 사용하여 시스템을 구성하는 것은 확실히 논리적이지만, 소프트웨어 아키텍처의 모든 것과 마찬가지로 여기에도 일부 절충안이 있습니다. 기술적 파티셔닝에 의해 강제된 분리는 개발자가 능력에 따라 구성되어 있기 때문에 코드베이스의 특정 카테고리를 빠르게 찾을 수 있게 합니다.

[그림](#domain-vs-technical) 9-4에 표시된 기술적으로 분할된 아키텍처에서 CatalogCheckout의 일반적인 비즈니스 워크플로를 고려합니다. 기술적으로 분할된 아키텍처에서 CatalogCheckout을 처리하는 코드는 모든 계층에 나타납니다. 다시 말해: 도메인이 기술적 계층에 분산되어 있습니다.

<span id="domain-vs-technical"></span>그림 9-4. 기술적으로 분할된 아키텍처와 도메인별로 분할된 아키텍처에서 도메인/워크플로가 나타나는 위치

대조적으로, [그림](#domain-vs-technical) 9-4에 표시된 도메인별로 분할된 아키텍처에서는 아키텍트가 최상위 컴포넌트를

워크플로와 도메인을 중심으로 구축했습니다. 각 컴포넌트는 계층을 포함한 하위 컴포넌트를 가질 수 있지만 최상위 파티셔닝은 도메인에 집중하며, 이는 프로젝트에서 가장 자주 발생하는 변경 유형을 더 잘 반영합니다.

이러한 스타일 중 어느 것도 다른 것보다 더 옳지 않습니다. (소프트웨어 아키텍처의 첫 번째 법칙 참조.) 그럼에도 불구하고 우리는 최근 몇 년 동안 모놀리식 아키텍처와 분산 아키텍처(예: 마이크로서비스) 모두에서 도메인 파티셔닝으로의 업계의 명확한 추세를 관찰했습니다. 우리가 이미 확인했듯이, 이것은 아키텍트가 내려야 하는 첫 번째 결정 중 하나입니다.

### **Kata: Silicon Sandwiches - 파티셔닝**

예제 kata 중 하나인 ["Kata:](#page--1-1) Silicon Sandwiches"의 경우를 고려해 봅시다. 먼저 Silicon Sandwiches의 두 가지 옵션 중 첫 번째를 살펴보겠습니다: [그림](#silicon-sandwiches-domain) 9-5에 표시된 도메인 파티셔닝.

<span id="silicon-sandwiches-domain"></span>![](_page_23_Figure_0.jpeg)

그림 9-5. Silicon Sandwiches를 위한 도메인별로 분할된 설계

[그림](#silicon-sandwiches-domain) 9-5에서 아키텍트는 도메인(워크플로)을 설계하고 Purchase, Promotion, MakeOrder, ManageInventory, Recipes, Delivery 및 Location에 대한 개별 컴포넌트를 만들었습니다. 이러한 컴포넌트 중 많은 것 내에는 일반적인 조정과 로컬 조정을 모두 할 수 있는 하위 컴포넌트가 있습니다.

<span id="silicon-sandwiches-technical"></span>![](_page_24_Picture_0.jpeg)

그림 9-6. Silicon Sandwiches를 위한 기술적으로 분할된 설계

대안적인 설계는 [그림](#silicon-sandwiches-technical) 9-6에 표시된 것처럼 공통 및 로컬 부분을 자체 파티션으로 격리합니다. Common과 Local은 최상위 컴포넌트를 나타내고 Purchase와 Delivery는 워크플로용으로 남습니다.

어느 것이 더 나은가요? 그것은 상황에 따라 다릅니다! 각 유형의 파티셔닝은 다양한 장단점을 제공합니다.

#### **도메인 파티셔닝(Domänenaufteilung)**

도메인별로 분할된 아키텍처는 워크플로 및/또는 도메인에 따라 최상위 컴포넌트를 분리합니다.

#### *장점*

- 구현 세부 사항보다 비즈니스가 작동하는 방식에 더 가깝습니다
- 특정 영역에 대한 기능 횡단 팀을 구성하기가 더 쉽습니다
- 모듈형 모놀리스 및 마이크로서비스 아키텍처와 더 강력하게 연계됩니다
- 메시지 흐름이 문제 영역에 해당합니다
- 데이터와 컴포넌트를 분산 아키텍처로 쉽게 마이그레이션할 수 있습니다

#### *단점*

사용자 정의 코드가 여러 위치에 나타납니다

#### **기술적 파티셔닝(Technische Aufteilung)**

기술적으로 분할된 아키텍처는 개별 워크플로가 아닌 기술적 능력에 따라 최상위 컴포넌트를 분리합니다. 이것은 Model-View-Controller 분리를 기반으로 한 계층 형태로 나타나거나 다른 기술적 임시 파티셔닝 형태로 나타날 수 있습니다. [그림](#silicon-sandwiches-technical) 9-6에 표시된 아키텍처는 사용자 정의를 기반으로 컴포넌트를 분리합니다.

#### *장점*

- 사용자 정의 코드를 명확하게 분리합니다.
- 계층화 아키텍처 패턴에 더 해당합니다.

#### *단점*

- 더 높은 정도의 전역 결합. Common 또는 Local 컴포넌트의 변경은 다른 모든 컴포넌트에도 영향을 미칠 가능성이 높습니다.
- 개발자가 공통 계층과 로컬 계층 모두에서 도메인 개념을 복제해야 할 수 있습니다.
- 일반적으로 데이터 수준의 결합이 더 높습니다. 그러한 시스템에서 애플리케이션 아키텍트와 데이터 아키텍트는 사용자 정의 및

도메인을 포함하는 단일 데이터베이스를 만들기 위해 협력할 것입니다. 이는 차례로 아키텍트가 나중에 이 아키텍처를 분산 시스템으로 전환하려고 할 때 데이터 관계를 풀기 어렵게 만들 것입니다. 아키텍처 스타일 선택에는 [Part](#page--1-0) II에서 설명하는 많은 다른 요소가 작용합니다.

# 모놀리식 대 분산 아키텍처

Part I에서 배웠듯이, 아키텍처는 두 가지 주요 유형으로 나눌 수 있습니다: *모놀리식(monolithische)* (전체 코드에 대한 단일 배포 단위)과 *분산(verteilte)* (원격 액세스 프로토콜을 통해 연결된 여러 배포 단위). 완벽한 분류 체계는 없지만, 분산 아키텍처는 모놀리식 아키텍처에서 발생하지 않는 일련의 공통적인 과제와 문제를 가지고 있으므로 이 분류 체계는 다양한 아키텍처 간의 좋은 구별을 나타냅니다.

이 책의 Part II에서는 다음 아키텍처 스타일을 자세히 설명합니다:

#### *모놀리식*

- 계층화 아키텍처[\(10장](#page--1-0))
- 파이프라인 아키텍처[\(12장](#page--1-0))

마이크로커널 아키텍처[\(13장](#page--1-0))

#### *분산*

- 서비스 기반 아키텍처[\(14장](#page--1-0))
- 이벤트 기반 아키텍처[\(15장](#page--1-0))
- 공간 기반 아키텍처[\(16장](#page--1-0))
- 서비스 지향 아키텍처[\(17장](#page--1-0))
- 마이크로서비스 아키텍처[\(18장](#page--1-0))

분산 아키텍처는 성능, 확장성 및 가용성 측면에서 모놀리식 아키텍처보다 훨씬 강력하지만 상당한 절충안도 가지고 있습니다. 모든 분산 아키텍처가 직면하는 첫 번째 문제 그룹은 1994년 L. Peter Deutsch와 Sun Microsystems의 다른 동료들이 처음 나열한 ["분산 컴퓨팅의 오류(Trugschlüssen des verteilten Rechnens)"](https://oreil.ly/fVAEY)에 설명되어 있습니다. *오류(Trugschluss)*는 누군가가 사실이라고 믿거나 가정하는 잘못된 것입니다. 분산 컴퓨팅의 8가지 오류 모두 오늘날 분산 아키텍처에 적용됩니다. 다음 섹션에서는 각 오류를 설명합니다.

**오류 #1: 네트워크는 신뢰할 수 있다**

<span id="fallacy-1"></span>![](_page_29_Picture_0.jpeg)

그림 9-7. 네트워크는 신뢰할 수 없습니다

개발자와 아키텍트는 네트워크가 신뢰할 수 있다고 가정하지만 그렇지 않습니다. 네트워크가 시간이 지남에 따라 더 신뢰할 수 있게 되었지만, 사실 일반적으로 여전히 신뢰할 수 없습니다. 이것은 모든 유형의 분산 아키텍처에 중요한데, 이들은 서비스로, 서비스에서, 서비스 간에 통신하기 위해 네트워크에 의존하기 때문입니다. [그림](#fallacy-1) 9-7에서 볼 수 있듯이, Service B는 완전히 건강할 수 있지만 Service A는 네트워크 문제로 인해 도달할 수 없습니다. 더 나쁜 것은 Service A가 Service B에 데이터 처리를 요청했지만 네트워크 문제로 인해 응답을 받지 못하는 경우입니다. 이것이 서비스 간에 타임아웃과 회로 차단기와 같은 것이 있는 이유입니다. 시스템이 네트워크에 더 많이 의존할수록

(마이크로서비스 아키텍처의 경우처럼), 신뢰할 수 없게 될 위험이 더 큽니다.

### **오류 #2: 지연 시간은 0이다**

<span id="fallacy-2"></span>![](_page_30_Picture_2.jpeg)

그림 9-8. 지연 시간은 0이 아닙니다

[그림](#fallacy-2) 9-8이 보여주듯이, 메서드 또는 함수 호출을 통해 다른 컴포넌트에 로컬 호출을 할 때 해당 컴포넌트에 액세스하는 시간( t\_local )은 나노초 또는 마이크로초로 측정됩니다. 그러나 동일한 호출이

원격 액세스 프로토콜(REST, 메시징 또는 RPC와 같은)을 통해 이루어지면 시간( t\_remote )은 밀리초로 측정되므로 항상 t\_local보다 큽니다. 모든 분산 아키텍처에서 지연 시간은 0이 아닙니다 - 그럼에도 불구하고 대부분의 아키텍트는 이 오류를 무시하고 빠른 네트워크를 가지고 있다고 주장합니다. 스스로에게 물어보십시오: 프로덕션 환경에서 RESTful 호출의 평균 지연 시간이 얼마인지 아십니까? 60밀리초입니까? 500밀리초입니까?

아키텍트가 분산 아키텍처, 특히 마이크로서비스의 배포를 고려할 때 이 평균 지연 시간을 알아야 합니다. 이것이 서비스의 세분성과 서비스 간 통신 범위로 인해 분산 아키텍처가 실현 가능한지 판단하는 유일한 방법입니다.

예를 들어, 요청당 평균 지연 시간이 100ms라고 가정해 봅시다. 특정 비즈니스 기능을 수행하기 위해 서비스 호출을 체인으로 연결하면 요청이 1,000ms 더 연장됩니다! 평균 지연 시간을 아는 것이 중요하지만 95-99번째 백분위수 지연 시간을 아는 것이 더 중요합니다. 시스템의 평균 지연 시간이 60ms에 불과할 수 있지만(좋음), 95번째 백분위수는 400ms일 수 있습니다! 일반적으로 분산 아키텍처에서 성능을 무효화하는 것은 이 "롱테일" 지연 시간입니다. 대부분의 경우 네트워크 관리자가 지연 시간 값을 제공할 수 있습니다("오류 #6: 관리자는 한 [명"](#fallacy-6) 참조).

### **오류 #3: 대역폭은 무한하다**

<span id="fallacy-3"></span>![](_page_32_Picture_1.jpeg)

그림 9-9. 대역폭은 무한하지 않습니다

모놀리식 아키텍처에서 대역폭은 일반적으로 문제가 아닙니다. 비즈니스 요청이 모놀리스에 들어오면 처리를 위해 대역폭이 거의 또는 전혀 필요하지 않기 때문입니다. 그러나 시스템이 마이크로서비스와 같은 분산 아키텍처에서 더 작은 배포 단위(서비스)로 분할되면 [그림](#fallacy-3) 9-9에 표시된 것처럼 이러한 서비스로의 통신과 서비스 간의 통신에 상당한 대역폭이 필요합니다. 이것은 네트워크를 느리게 하고 지연 시간(오류 #2) 및 신뢰성(오류 #1)에 영향을 미칩니다.

이 오류의 중요성을 설명하기 위해 [그림](#fallacy-3) 9-9에 표시된 두 서비스를 고려하십시오. Service A가

웹사이트의 위시리스트를 관리하고 Service B가 고객 프로필을 관리한다고 가정해 봅시다. 위시리스트에 대한 요청이 Service A에 도착하면 Service A는 위시리스트 응답 계약에 대한 고객 이름이 필요합니다. 이름을 얻기 위해 Service B에 서비스 간 호출을 해야 합니다. Service B는 45개의 속성, 총 500KB를 Service A에 반환하는데, Service A는 이름(200바이트)만 필요합니다. 많이 들리지 않을 수 있지만 위시리스트 항목에 대한 요청은 초당 약 2,000번 발생합니다. 즉, Service A가 초당 2,000번 Service B를 호출한다는 의미입니다. 요청당 500KB에서 *각* 서비스 간 호출은 1GBps의 대역폭을 소비합니다!

이러한 형태의 결합, 소위 *스탬프 결합(Stempelkopplung)*은 분산 아키텍처에서 상당한 양의 대역폭을 소비합니다. Service B가 Service A가 필요로 하는 200바이트의 데이터*만* 반환한다면 총 400Kbps만 소비할 것입니다.

스탬프 결합은 다음을 통해 해결될 수 있습니다:

- 프라이빗 RESTful API 엔드포인트 생성
- 계약에서 필드 선택기 사용
- [GraphQL](https://graphql.org/)을 사용하여 계약 분리
- 소비자 중심 계약과 함께 가치 중심 계약 사용
- 내부 메시징 엔드포인트 사용

사용된 기술과 관계없이 분산 아키텍처에서 이 오류를 가장 잘 해결하는 방법은

서비스 또는 시스템이 필요한 데이터만 전송하도록 하는 것입니다.

### **오류 #4: 네트워크는 안전하다**

<span id="fallacy-4"></span>![](_page_34_Picture_2.jpeg)

그림 9-10. 네트워크는 안전하지 않습니다

대부분의 아키텍트와 개발자는 가상 사설망(VPN), 신뢰할 수 있는 네트워크 및 방화벽을 사용하는 데 너무 익숙해져서 이 분산 컴퓨팅 오류를 잊어버립니다 - *네트워크는 안전하지 않습니다*. [그림](#fallacy-4) 9-10에 표시된 것처럼, 각 분산 배포 단위의 모든 단일 엔드포인트는 알려지지 않거나 악의적인 요청에 대해 보호되어야 합니다. 위협 및 공격에 대한 공격 표면은

모놀리식에서 분산 아키텍처로 전환할 때 여러 배로 증가하여 보안을 상당히 어렵게 만듭니다. 서비스 간 통신에서도 각 엔드포인트를 보호하는 것은 마이크로서비스 및 서비스 기반 아키텍처와 같은 동기식, 고도로 분산된 아키텍처에서 성능이 느려지는 경향이 있는 또 다른 이유입니다.

## **오류 #5: 토폴로지는 절대 변경되지 않는다**

<span id="fallacy-5"></span>![](_page_35_Picture_2.jpeg)

그림 9-11. 네트워크 토폴로지는 지속적으로 변경됩니다

[그림](#fallacy-5) 9-11에 표시된 오류 #5는 모든 라우터, 허브, 스위치, 방화벽, 네트워크 및 장치를 포함한 전체 네트워크 토폴로지를 나타냅니다. 아키텍트는 토폴로지가 고정되어 있고 절대 변경되지 않는다고 가정합니다. *물론 변경됩니다.* 항상 변경됩니다. 이 오류의 의미는 무엇입니까?

월요일 아침 출근했는데 프로덕션의 서비스가 계속 실패하기 때문에 모두가 미친 듯이 뛰어다니고 있다고 가정해 봅시다. 팀과 협력하여 그 이유를 필사적으로 알아내려고 노력합니다. 주말 동안 새로운 서비스가 배포되지 않았습니다. 무엇이 원인일 수 있습니까? 몇 시간 후, 새벽 2시에 "작은" 네트워크 업그레이드가 시스템의 모든 지연 시간 가정을 무효화하여 타임아웃 및 회로 차단을 초래했다는 것을 발견합니다.

아키텍트는 이러한 놀라움을 피하기 위해 조정을 할 수 있도록 운영 및 네트워크 관리자와 무엇이 언제 변경되는지에 대해 지속적으로 소통해야 합니다. 이것은 명백하고 간단해 보일 수 있지만 그렇지 않습니다. 실제로 이 오류는 다음 오류로 직접 이어집니다.

<span id="fallacy-6"></span>**오류 #6: 관리자는 한 명이다**

<span id="fallacy-6-image"></span>![](_page_37_Picture_0.jpeg)

그림 9-12. 한 명이 아니라 많은 네트워크 관리자가 있습니다

아키텍트는 반복적으로 이 오류에 빠집니다: 한 명의 관리자와만 협력하고 소통하면 된다고 가정합니다. [그림](#fallacy-6-image) 9-12가 보여주듯이, 일반적인 대기업에는 수십 명의 네트워크 관리자가 있습니다. 아키텍트가 지연 시간이나 토폴로지 변경에 대해 누구와 이야기해야 합니까? 이 오류는 분산 아키텍처의 복잡성과 모든 것이 올바르게 작동하도록 하는 데 필요한 높은 수준의 조정을 강조합니다. 단일 배포 단위를 가진 모놀리식 애플리케이션에서는 그러한 수준의 통신과 협업이 필요하지 않습니다.

# **오류 #7: 전송 비용은 0이다**

<span id="fallacy-7"></span>![](_page_39_Picture_0.jpeg)

그림 9-13. 원격 액세스에는 비용이 듭니다

많은 소프트웨어 아키텍트가 [그림](#fallacy-7) 9-13에 표시된 이 오류를 오류 #2(지연 시간은 0)와 혼동합니다. *전송 비용*은 여기서 지연 시간이 아니라 "간단한 RESTful 호출"에 대한 실제 *금전적 비용*을 나타냅니다. 아키텍트는 간단한 RESTful 호출을 수행하거나 모놀리식 애플리케이션을 분해하는 데 필요하고 충분한 인프라가 이미 존재한다고 잘못 가정합니다. *일반적으로 그렇지 않습니다.* 분산 아키텍처는 모놀리식 아키텍처보다 훨씬 더 많은 비용이 듭니다. 특히 하드웨어, 서버, 게이트웨이, 방화벽, 새 서브넷, 프록시 등에 대한 수요 증가로 인해.

우리는 분산 아키텍처를 구축하려는 아키텍트들이 이 오류로 인해 놀라지 않도록 용량, 대역폭, 지연 시간 및 보안 영역 측면에서 현재 서버 및 네트워크 토폴로지를 분석하도록 권장합니다.

### **오류 #8: 네트워크는 동질적이다**

<span id="fallacy-8"></span>![](_page_40_Picture_2.jpeg)

그림 9-14. 네트워크는 동질적이지 않습니다

대부분의 아키텍트와 개발자는 [그림](#fallacy-8) 9-14에 표시된 것처럼 네트워크가 동질적이라고 가정합니다 - 한 제조업체의 네트워크 하드웨어로만 구성되어 있다고. 진실과는 거리가 멀 것입니다. 대부분의 기업 인프라는 여러 네트워크 하드웨어 공급업체로 구성됩니다.

그래서 뭐? 이 오류의 의미는 이러한 이질적인 하드웨어 공급업체가 모두 잘 협력하지 않는다는 것입니다. Juniper Networks의 하드웨어가 Cisco의 하드웨어와 원활하게 통합됩니까

Systems와? 대부분 작동하며, 네트워크 표준이 수년에 걸쳐 발전하여 이것이 덜 문제가 되었습니다. 그러나 모든 상황, 부하 및 상황이 완전히 테스트되지 않았으므로 때때로 네트워크 패킷이 손실될 수 있습니다. 이는 차례로 네트워크의 신뢰성과 지연 시간 및 대역폭에 대한 가정과 주장에 영향을 미칩니다. 다시 말해: 이 오류는 다른 모든 오류와 연결되어 네트워킹 처리(분산 아키텍처에서 불가피함)에서 혼란과 좌절의 무한 루프를 형성합니다.

### **기타 오류**

이전에 나열된 8가지 오류는 유명한 일련의 관찰입니다 - 모든 아키텍트는 Deutsch의 목록에서 또는 경력 동안 하나씩 어렵게 배웁니다. 저자들도 이 유명한 목록에 대한 보완으로 제공하는 몇 가지 고통스럽고 거의 보편적인 교훈을 배웠습니다.

#### **오류 #9. 버전 관리는 쉽다**

두 서비스가 서로 통신해야 할 때 통신에 필요한 정보를 포함하는 *계약(Vertrag)*으로 정보를 전달합니다. 종종 서비스의 내부 구현은 시간이 지남에 따라 발전하고 서비스가 수락하고 다른 서비스에 전달하는 필드를 변경합니다. 이 문제를 해결하는 한 가지 방법은 계약을 버전화하는 것입니다. 즉, 다른 정보를 가진 이전 계약과 새 계약에 대해 다른 버전을 만드는 것입니다. 그러나 이 겉보기에 간단한 결정은 일련의 절충안으로 이어집니다:

- 팀이 개별 서비스 수준에서 작업해야 합니까 아니면 전체 시스템에서 작업해야 합니까?
- 버전 관리가 얼마나 멀리 도달해야 합니까? 아키텍처의 어느 부분이 이를 지원해야 합니까?
- 팀이 특정 시점에 몇 개의 버전을 지원해야 합니까? (일부 팀은 우연히 다양한 목적으로 수십 개의 다른 버전을 사용합니다).
- 팀이 시스템 수준에서 또는 각 개별 서비스에 대해 이전 버전을 폐기해야 합니까?

버전 관리는 서비스 간 통신을 발전시키기 위한 합리적인 접근 방식이지만 아키텍트가 예상해야 하는 일련의 절충안을 가져옵니다.

### **오류 #10. 보상 업데이트는 항상 작동한다**

*보상 업데이트(Kompensierende Aktualisierungen)*는 메커니즘(예: Orchestrator 서비스)이 여러 관련 서비스가 함께 업데이트되도록 하는 아키텍처 패턴입니다. 그렇지 않으면 Orchestrator가 업데이트를 롤백합니다. *보상 업데이트*는 이전 상태를 복원하기 위해 역방향 작업을 수행하는 Orchestrator에서 나옵니다.

이것은 대부분의 아키텍트가 무심코 항상 작동한다고 가정하는 일반적인 패턴입니다... 하지만 그렇지 않습니다. 보상 업데이트가 실패하면 어떻게 됩니까? 아키텍트가 마이크로서비스와 같은 분산 아키텍처에서 복잡한 상호 작용이 어떻게 작동하는지 보여줄 때 보상 업데이트가 어떻게 작동하는지도 보여주어야 합니다. 따라서 마이크로서비스에서 트랜잭션 워크플로를 설계하는 아키텍트는 "정상" 보상 워크플로를 고려해야 하지만 업데이트와 보상 업데이트(또는 일부) *모두* 실패할 때 복구가 어떻게 작동하는지도 고려해야 합니다.

### **오류 #11. 관찰 가능성은 선택 사항이다 (분산 아키텍처의 경우)**

아키텍트가 분산 아키텍처에서 중요시하는 일반적인 아키텍처 특성은 *관찰 가능성(Beobachtbarkeit)*입니다: 모니터나 로그로 캡처된 각 서비스의 다른 서비스 및 생태계와의 상호 작용을 관찰할 수 있는 능력. 로깅이 모놀리식 아키텍처에서 유용한 반면, 분산 아키텍처에서는 *매우 중요합니다*

*의미*: 포괄적인 상호 작용 프로토콜 없이는 문제 해결이 어려운 많은 통신 오류가 발생합니다.

# 팀 토폴로지와 아키텍처

아키텍트와 팀은 우리가 이미 논의한 아키텍처 파티셔닝의 영향을 넘어 아키텍처와 팀 토폴로지의 중첩에 대해 많이 연구했습니다. 매우 영향력 있는 책 *Team [Topologies](https://oreil.ly/aPB3u)*의 Matthew Skelton과 Manuel Pais(IT Revolution Press, 2019)는 소프트웨어 아키텍처와 중첩되는 다양한 팀 유형을 정의합니다:

#### *스트림 정렬 팀(Auf den Strom ausgerichtete Teams)*

팀 토폴로지 용어에서 *스트림(Stream)*은 특정 비즈니스 영역이나 능력에 맞춰진 작업 흐름입니다. *스트림 정렬 팀*은 제품, 서비스 또는 특정 수의 기능과 같은 단일 작업 흐름에 집중합니다.

스트림 정렬 팀의 목표는 비즈니스에 특별한 가치를 제공하기 때문에 가능한 한 빠르게 진행하는 것입니다. 따라서 다른 팀 유형은 스트림 정렬 팀을 방해할 수 있는 마찰을 줄이도록 설계되었습니다.

#### *활성화 팀(Teams befähigen)*

*활성화 팀(Enabling Team)*은 특정 능력의 격차를 메우고 중요하지만 긴급하지 않은 필요한 연구, 학습 및 기타 작업을 위한 장소를 제공합니다. 전문 영역의 지식과 리소스를 제공하여 스트림 정렬 팀을 지원합니다. 좋은 활성화 팀은 매우 협력적이고 능동적입니다.

#### *복잡한 하위 시스템 팀(Teams mit komplizierten Subsystemen)*

많은 시스템은 유사하게 전문화된 능력을 요구하는 고도로 전문화된 시스템이나 부품을 포함합니다. *복잡한 하위 시스템 팀* 구성원은 복잡한 하위 시스템이나 도메인을 완전히 이해하고 스트림 정렬 팀이 이를 적용하는 데 도움을 줄 수 있습니다. 그들의 목표는 다른 팀의 인지 부하를 줄이는 것입니다.

#### *플랫폼 팀(Plattform-Teams)*

*플랫폼 팀*은 솔루션을 위한 내부 서비스와 구성 요소를 제공합니다. Evan [Botcher](https://oreil.ly/ieO_7)의 정의에 따르면 플랫폼은

*설득력 있는 내부 제품으로 설계된 셀프 서비스 API, 도구, 서비스, 지식 및 지원의 기반입니다. 자율적인 배송 팀은 플랫폼을 사용하여 더 빠른 속도로 덜 조정하여 제품 기능을 제공할 수 있습니다.*

플랫폼 팀은 품질과 보안과 같은 문제에 대한 필요한 통제를 보장하면서 불필요한 마찰을 피하려고 노력하여 다른 팀을 지원합니다.

# 특정 스타일로 계속

절충안 분석을 수행하기 위해 아키텍트는 다양한 아키텍처 스타일을 이해해야 합니다. 각 스타일은 다른 일련의 아키텍처 특성을 지원합니다. 각 스타일에는 가장 잘 마스터하는 "스위트 스팟"이 있습니다. 아키텍트가 다양한 스타일과 그 기초가 되는 철학을 알면 스타일이 가장 잘(또는 가장 덜 나쁘게) 작동하는 시기를 더 잘 이해할 수 있습니다.