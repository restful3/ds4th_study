# ch09 아키텍처 스타일의 기초

## 요약

이 브리핑 문서는 소프트웨어 아키텍처의 핵심 기초 개념을 종합적으로 분석합니다. 주요 내용은 아키텍처 스타일과 패턴의 근본적인 차이점, 피해야 할 대표적인 안티패턴인 '진흙 덩어리(Big Ball of Mud)', 그리고 아키텍처 설계의 가장 중요한 초기 결정인 파티셔닝 전략입니다. 특히 시스템을 기술적 기능으로 나누는 기술적 파티셔닝과 비즈니스 도메인을 중심으로 구성하는 도메인 파티셔닝의 장단점을 비교하며, 최근 업계가 도메인 파티셔닝으로 기우는 경향을 조명합니다.

또한, 아키텍처의 두 가지 주요 유형인 모놀리식과 분산 시스템을 대조하며, 분산 아키텍처를 채택할 때 반드시 고려해야 할 **'분산 컴퓨팅의 8가지 오류'** 를 심도 있게 다룹니다. 이 오류들은 네트워크 신뢰성, 지연 시간, 대역폭 등 개발자들이 흔히 간과하는 잘못된 가정을 지적하며, 이를 무시할 경우 시스템에 치명적인 문제가 발생할 수 있음을 경고합니다. 마지막으로, 아키텍처와 조직 구조 간의 상호작용을 설명하는 콘웨이의 법칙과 이를 현대적으로 적용한 팀 토폴로지 개념을 소개하여 성공적인 아키텍처 구축을 위한 조직적 고려사항을 제시합니다.

![아키텍처 스타일의 기초 인포그래픽](unnamed.png)

--------------------------------------------------------------------------------

## 1. 아키텍처 스타일과 패턴의 이해

### 1.1. 스타일 대 패턴

**아키텍처 스타일**과 **패턴** 은 종종 혼용되지만, 명확히 구분되는 개념입니다.

* **아키텍처 스타일 (Architecture Style)**: 아키텍처의 전반적인 특징과 구조를 설명하는 광범위한 개념입니다. 스타일은 다음과 같은 여러 측면을 규정합니다.
  * **컴포넌트 토폴로지**: 컴포넌트와 그 의존성이 어떻게 구성되는지 정의합니다 (예: 계층형 아키텍처는 기술적 기능별로, 모듈형 모놀리스는 도메인별로 구성).
  * **물리적 아키텍처**: 모놀리식(단일 배포 단위) 또는 분산형(다중 배포 단위) 구조를 결정합니다.
  * **배포**: 시스템의 세분성 (granularity) 과 배포 빈도에 영향을 줍니다. 모놀리스는 보통 단일 단위로 배포되지만, 마이크로서비스와 같은 분산 아키텍처는 훨씬 더 빠르고 조각화된 배포가 특징입니다.
  * **통신 스타일**: 컴포넌트 간 통신 방식을 정의합니다 (예: 모놀리스는 내부 메소드 호출, 분산 시스템은 REST나 메시지 큐 같은 네트워크 프로토콜 사용).
  * **데이터 토폴로지**: 데이터베이스의 구조를 결정합니다. 모놀리식 아키텍처는 보통 단일 데이터베이스를, 분산 아키텍처는 데이터 분리를 고려할 수 있습니다.
* **아키텍처 패턴 (Architecture Pattern)**: 특정 맥락에서 발생하는 문제에 대한 구체적인 해결책을 설명합니다. 스타일이 아키텍처의 전반적인 청사진이라면, 패턴은 그 안에서 사용되는 개별적인 설계 기법에 가깝습니다.

### 1.2. 아키텍처 스타일의 기원

아키텍처 스타일은 공식적인 위원회에서 결정되는 것이 아니라, 아키텍트가 일하는 **생태계**가 진화하면서 자연스럽게 발생합니다. 예를 들어, **마이크로서비스 아키텍처**는 새로운 DevOps 기능, 신뢰성 있는 오픈소스 운영체제, **도메인 주도 설계 (DDD)** 철학의 등장으로 가능해졌습니다. 이는 확장성 같은 특정 문제를 해결하기 위해 시스템을 구축하는 새로운 방법을 제시했고, 기존의 거대한 서비스와 오케스트레이션 중심 스타일과 구별하기 위해 '마이크로서비스'라는 이름이 붙여졌습니다.

## 2. 피해야 할 안티패턴: 진흙 덩어리 (Big Ball of Mud)

**'진흙 덩어리'** 는 식별 가능한 아키텍처 구조가 없는 상태를 지칭하는 용어로, 1997년 Brian Foote와 Joseph Yoder가 정의한 **안티패턴**에서 유래했습니다.

"진흙 덩어리는 되는대로 구조화되고, 마구잡이로 뻗어 나가며, 지저분하고, 테이프와 전선으로 간신히 뭉쳐 있는 스파게티 코드 정글이다. 이러한 시스템은 통제되지 않은 성장과 반복적인 임시방편 수리의 명백한 징후를 보인다. 정보는 시스템의 멀리 떨어진 요소들 사이에서 마구 공유되며, 종종 거의 모든 중요 정보가 전역적이거나 중복되는 지경에 이른다."

이러한 구조는 변경 사항이 다른 클래스에 미치는 영향을 예측하기 어렵게 만듭니다. 아래 그림 9-1은 실제 코드베이스의 클래스 간 **결합도**를 시각화한 것으로, 모든 것이 다른 모든 것과 연결된 '진흙 덩어리'의 복잡성을 명확히 보여줍니다.

 그림 9-1. 진흙 덩어리 아키텍처 시각화

이러한 아키텍처는 구조 부재로 인해 배포, 테스트 용이성, 확장성, 성능 등에서 심각한 문제를 겪으며, 시스템이 커질수록 문제는 악화됩니다.

## 3. 아키텍처 파티셔닝: 핵심적인 첫 결정

아키텍처를 구성하는 컴포넌트를 나누는 방식, 즉 **최상위 파티셔닝(Top-Level Partitioning)** 은 아키텍트가 내려야 하는 가장 근본적인 결정 중 하나입니다. 이는 시스템의 기본 구조와 코드 분할 방식을 정의합니다.

### 3.1. 기술적 파티셔닝 (Technical Partitioning)

시스템의 컴포넌트를 기술적 기능을 기준으로 구성하는 방식입니다. 대표적인 예는 **계층형 아키텍처(Layered Architecture)** 입니다.

* 구조: 프레젠테이션, 비즈니스 규칙, 서비스, 퍼시스턴스(영속성) 등 기술적 계층으로 나뉩니다.
* 장점: 특정 기술(예: 데이터베이스 접근)과 관련된 코드를 한곳에서 쉽게 찾을 수 있습니다. 관심사의 기술적 분리를 통해 유용한 분리 계층을 만듭니다.
* 단점: 하나의 비즈니스 도메인(예: '카탈로그 결제')과 관련된 코드가 모든 기술 계층에 흩어져 존재하게 됩니다.

### 3.2. 도메인 파티셔닝 (Domain Partitioning)

시스템의 컴포넌트를 비즈니스 도메인이나 워크플로우를 기준으로 구성하는 방식입니다. 에릭 에반스(Eric Evans)의 **도메인 주도 설계(Domain-Driven Design, DDD)** 에서 영감을 받았습니다.

* 구조: 카탈로그 결제(CatalogCheckout), 재고 업데이트(UpdateInventory), 고객 배송(ShipToCustomer) 등 독립적인 도메인으로 나뉩니다.
* 장점: 비즈니스가 작동하는 방식과 더 가깝게 정렬됩니다. 특정 도메인을 담당하는 교차 기능 팀(cross-functional team) 구성이 용이합니다. 모듈형 모놀리스나 마이크로서비스 아키텍처로의 전환이 쉽습니다.
* 단점: 커스터마이제이션 코드가 여러 도메인에 나타날 수 있습니다.

 그림 9-4. 파티셔닝 방식에 따른 도메인/워크플로우의 위치

### 3.3. 콘웨이의 법칙과 팀 토폴로지

* **콘웨이의 법칙 (Conway's Law)**: "시스템을 설계하는 조직은 그 조직의 의사소통 구조를 복제한 듯한 설계를 만들 수밖에 없다." 즉, 기술적 계층으로 팀이 나뉘어 있으면 (백엔드팀, 프론트엔드팀, DBA팀), 결과물인 아키텍처도 기술적 계층 구조를 따를 가능성이 높습니다.
* **역 콘웨이 전략 (Inverse Conway Maneuver)**: 원하는 아키텍처를 장려하기 위해 팀과 조직의 구조를 의도적으로 바꾸는 전략입니다. 이는 현재 **팀 토폴로지 (Team Topologies)** 라는 개념으로 널리 알려져 있습니다.

## 4. 모놀리식 아키텍처 대 분산 아키텍처

아키텍처는 크게 두 가지 유형으로 분류할 수 있습니다.

* **모놀리식 (Monolithic)**: 전체 코드가 단일 배포 단위로 묶인 아키텍처입니다. (예: 계층형, 파이프라인, 마이크로커널 아키텍처)
* **분산 (Distributed)**: 여러 배포 단위가 원격 접속 프로토콜을 통해 연결된 아키텍처입니다. (예: 서비스 기반, 이벤트 기반, 마이크로서비스 아키텍처)

분산 아키텍처는 성능, 확장성, 가용성 측면에서 강력하지만, 모놀리식 아키텍처에는 없는 상당한 **트레이드오프**와 복잡성을 수반합니다. 이러한 복잡성은 **'분산 컴퓨팅의 오류'**라는 개념으로 잘 설명됩니다.

## 5. 분산 컴퓨팅의 8가지 오류

1994년 썬 마이크로시스템즈의 L. 피터 도이치 (L. Peter Deutsch) 등이 처음 제시한 이 오류들은, 분산 시스템을 설계할 때 개발자들이 진실이라고 믿는 **잘못된 가정**들을 지적합니다.

오류	잘못된 가정	현실

- 1	네트워크는 신뢰할 수 있다	네트워크는 항상 불안정하며, 언제든 실패할 수 있습니다. 서비스 간 통신은 **타임아웃 (timeout)** 이나 **서킷 브레이커 (circuit breaker)** 와 같은 장애 처리 메커니즘을 반드시 포함해야 합니다.
- 2	지연 시간 (Latency) 은 0이다	로컬 메소드 호출 (나노초 단위) 과 원격 호출 (밀리초 단위) 사이에는 수백만 배의 속도 차이가 있습니다. 아키텍트는 평균 지연 시간뿐만 아니라, 성능을 저하시키는 95~99% 구간의 **'롱테일' 지연 시간**도 파악해야 합니다.
- 3	대역폭 (Bandwidth) 은 무한하다	분산 시스템에서 서비스 간 통신은 상당한 대역폭을 소모합니다. 특히 필요 이상으로 많은 데이터를 반환하는 **스탬프 결합 (stamp coupling)** 은 심각한 성능 저하를 유발할 수 있습니다.
- 4	네트워크는 안전하다	모놀리스에 비해 분산 시스템은 **공격 표면 (attack surface)** 이 훨씬 넓습니다. 서비스 간 통신을 포함한 모든 엔드포인트는 개별적으로 보안이 확보되어야 합니다.
- 5	토폴로지는 절대 변하지 않는다	**네트워크 토폴로지** (라우터, 스위치, 방화벽 등) 는 끊임없이 변합니다. 사소한 네트워크 업그레이드가 시스템 전체의 지연 시간 가정을 무너뜨려 장애를 일으킬 수 있으므로, 운영 및 네트워크 관리자와의 지속적인 소통이 필수입니다.
- 6	관리자는 한 명뿐이다	대규모 조직에는 수십 명의 네트워크 관리자가 존재합니다. 누구와 소통해야 할지 파악하는 것 자체가 복잡한 문제입니다.
- 7	전송 비용은 0이다	여기서 비용은 지연 시간이 아닌 실제 금전적 비용을 의미합니다. 분산 아키텍처는 추가 하드웨어, 서버, 게이트웨이, 방화벽 등으로 인해 모놀리식보다 훨씬 더 많은 비용이 듭니다.
- 8	네트워크는 동종이다	대부분의 기업 인프라는 여러 제조업체의 네트워크 하드웨어로 구성되어 있습니다. 서로 다른 장비 간의 호환성 문제로 인해 예기치 않게 네트워크 패킷이 손실될 수 있습니다.

## 6. 추가적인 오류: 저자들이 발견한 교훈

위의 8가지 고전적인 오류 외에, 저자들은 다음과 같은 추가적인 오류들을 지적합니다.

* **오류 #9: 버전 관리는 쉽다 (Versioning is easy)** - 서비스 간 통신 계약 (contract) 의 버전 관리는 시스템 전체에 걸쳐 지원 범위, 폐기 정책 등 수많은 트레이드오프를 수반하는 복잡한 문제입니다.
* **오류 #10: 보상 업데이트는 항상 작동한다 (Compensating updates always work)**- 분산 트랜잭션에서 여러 서비스의 업데이트가 실패했을 때 이를 되돌리는 **'보상 업데이트'** 로직 자체도 실패할 수 있습니다. 아키텍트는 보상 로직의 실패 시나리오까지 고려해야 합니다.
* **오류 #11: 관찰 가능성은 선택 사항이다 (Observability is optional)**- 분산 아키텍처에서 서비스 간 상호작용을 모니터링하고 로그를 남기는 **'관찰 가능성'** 은 선택이 아닌 필수입니다. 이것 없이는 복잡한 통신 장애를 해결하기가 거의 불가능합니다.

## 7. 아키텍처와 팀 구조: 팀 토폴로지

매튜 스켈튼 (Matthew Skelton) 과 마누엘 파이스 (Manuel Pais) 의 저서 『팀 토폴로지』는 아키텍처와 팀 구조의 상호작용을 설명하며 다음과 같은 팀 유형을 정의합니다.

* **스트림 정렬팀 (Stream-aligned Teams)**: 특정 비즈니스 영역이나 제품에 맞춰진 작업 흐름 (stream) 에 집중하는 팀입니다. 이들의 목표는 비즈니스 가치를 최대한 빨리 전달하는 것입니다.
* **활성화팀 (Enabling Teams)**: 특정 기술 영역의 격차를 해소하고, 스트림 정렬팀을 돕기 위해 전문 지식과 자원을 제공하는 팀입니다.
* **복잡한 하위 시스템팀 (Complicated-subsystem Teams)**: 고도의 전문성이 필요한 하위 시스템을 전담하여 다른 팀의 **인지 부하** 를 줄여주는 팀입니다.
* **플랫폼팀 (Platform Teams)**: 다른 팀들이 더 높은 속도로 제품 기능을 제공할 수 있도록 셀프서비스 API, 도구, 서비스 등의 기반을 제공하는 내부 제품 팀입니다.

이러한 팀 구조는 스트림 정렬팀이 겪는 **마찰** 을 줄이고, 조직 전체가 원하는 아키텍처를 향해 나아갈 수 있도록 돕는 것을 목표로 합니다.
