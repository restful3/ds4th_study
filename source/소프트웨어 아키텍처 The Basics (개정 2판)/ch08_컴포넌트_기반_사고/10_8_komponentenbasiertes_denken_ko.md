---
lang: ko
format:
  html:
    toc: true
    embed-resources: true
    theme: cosmo
---

# 8장. 컴포넌트 기반 사고 (Kapitel 8. Komponentenbasiertes Denken)

이 작업은 AI를 활용해 번역되었습니다. 여러분의 피드백과 의견을 환영합니다: [translation-feedback@oreilly.com](mailto:translation-feedback@oreilly.com)

[3장](#page--1-0)에서 우리는 서로 연관된 코드를 모아 두는 *모듈(Modul)* 개념을 소개했습니다. 이번 장에서는 해당 개념을 훨씬 더 깊이 탐구하고, 시스템의 *구성 요소(Bausteine)*인 *논리적 컴포넌트(logische Komponenten)* 형태로 모듈성을 건축적 관점에서 살펴봅니다.

논리적 컴포넌트를 식별하고 관리하는 일은 [2장](#page--1-0)에서 다룬 *아키텍처적 사고(architektonisches Denken)*의 일부이며, 우리는 이 활동을 *컴포넌트 기반 사고(Komponentenbasiertes Denken)*라고 부릅니다. 컴포넌트 기반 사고란 시스템의 구조를 특정 비즈니스 기능을 수행하기 위해 함께 작동하는 논리적 컴포넌트들의 집합으로 바라보는 것입니다. 이 수준(클래스 수준이 아닌)에서 아키텍트는 시스템을 "바라봅니다".

이 장에서는 소프트웨어 아키텍처에서 논리적 컴포넌트가 무엇인지, 어떻게 식별하는지, 그리고 이른바 *코헤전(Kohäsion)* 분석을 통해 적절한 세분성을 확보하는 방법을 정의합니다. 또한 컴포넌트 간 *결합도(Kopplung)*에 대해 살펴보고, 느슨하게 결합된 시스템을 만들어야 하는 이유와 방법을 다룹니다.

## 논리적 컴포넌트 정의하기 (Logische Komponenten definieren)

[그림](#page-1-0) 8-1과 같이 전형적인 서구식 주택의 평면도를 떠올려 보세요. 평면도는 각각 특정 목적을 수행하는 여러 개의 방(부엌, 침실, 욕실, 거실, 서재 등)으로 구성됩니다. 이 방들이 바로 집의 구성 요소, 즉 *컴포넌트*입니다.

<span id="page-1-0"></span>![Abbildung 8-1: 집 평면도에서 방을 컴포넌트로 나타냄](_page_1_Picture_2.jpeg)

그림 8-1. 서로 다른 방이 집의 컴포넌트를 나타낸다

동일한 방식으로, 시스템의 주요 기능은 [그림](#page-2-0) 8-2에서처럼 시스템의 컴포넌트를 형성합니다. 집의 방들이 각자 특정 역할을 수행하듯, 각 컴포넌트는 재고 관리, 주문 배송, 결제 처리 등 특정 기능을 담당합니다. 이들이 모여 전체 시스템을 형성하며, 각 컴포넌트는 해당 비즈니스 기능을 구현하는 소스 코드를 보유합니다.

<span id="page-2-0"></span>![Abbildung 8-2: 시스템의 주요 기능이 컴포넌트를 구성함](_page_2_Picture_1.jpeg)

그림 8-2. 다양한 핵심 기능이 시스템의 컴포넌트가 된다

소프트웨어 아키텍처에서 논리적 컴포넌트는 대개 해당 기능을 구현하는 소스 코드를 담은 네임스페이스나 디렉터리 구조로 드러납니다. 일반적으로 소스 코드를 담고 있는 디렉터리 또는 네임스페이스의 *리프 노드(Blattknoten)*가 아키텍처의 논리적 컴포넌트를 나타내며, 상위 디렉터리나 네임스페이스 노드는 시스템의 도메인과 서브도메인을 표현합니다. [그림](#page-4-0) 8-3의 디렉터리 구조에서 `order_entry/ordering/payment` 경로는 Payment Processing 컴포넌트를, `order_entry/processing/fulfillment` 경로는 Order Fulfillment 컴포넌트를 의미합니다. 해당 디렉터리 아래의 소스 코드가 이러한 논리적 컴포넌트를 구현합니다.

<span id="page-4-0"></span>![Abbildung 8-3: 디렉터리 리프 노드가 컴포넌트를 나타냄](_page_4_Figure_0.jpeg)

그림 8-3. 디렉터리의 리프 노드가 시스템의 컴포넌트를 표현한다

아키텍트는 소프트웨어 시스템의 디렉터리 구조나 네임스페이스를 분석하여 시스템의 내부 구조, 즉 *논리적 아키텍처(logische Architektur)*를 이해할 수 있습니다. 논리적 아키텍처와 물리적 아키텍처의 차이는 다음 절에서 설명합니다.

## 논리적 아키텍처 대 물리적 아키텍처 (Logische versus physische Architektur)

*논리적 아키텍처*는 시스템의 논리적 컴포넌트(구성 요소)와 상호작용 방식을 포함합니다. 일반적으로 다양한 *액터(Akteure)*(시스템과 상호작용하는 사용자)와의 상호작용을 표시하며, 컴포넌트 간 데이터가 어디에서 사용되거나 전달되는지 보여 주기 위해 저장소(데이터베이스가 아닌)도 표기할 수 있습니다. [그림](#page-6-0) 8-4는 논리적 아키텍처의 예를 보여 줍니다.

<span id="page-6-0"></span>![Abbildung 8-4: 논리적 아키텍처 다이어그램](_page_6_Picture_0.jpeg)

그림 8-4. 논리적 아키텍처 다이어그램

논리적 아키텍처 다이어그램에는 일반적으로 사용자 인터페이스, 데이터베이스, 서비스 등 물리적 산출물이 표시되지 않습니다. 대신, 코드가 조직된 디렉터리 구조와 네임스페이스와 일치해야 하는 논리적 컴포넌트와 그 상호작용을 보여 줍니다.

반면에 *물리적 아키텍처*는 서비스, 사용자 인터페이스, 데이터베이스와 같은 물리적 산출물을 포함합니다. [그림](#page-8-0) 8-5는 물리적 아키텍처 다이어그램의 예입니다.

<span id="page-8-0"></span>![Abbildung 8-5: 물리적 아키텍처 다이어그램](_page_8_Picture_0.jpeg)

그림 8-5. 물리적 아키텍처 다이어그램

물리적 아키텍처는 서비스, 사용자 인터페이스, 데이터베이스, 다른 시스템 지점, 메시지 브로커, 컨테이너 등과 같은 실제 산출물을 나타냅니다. 또한 컴포넌트가 서로 어떻게 상호작용하는지, 그리고 시스템의 다양한 물리적 측면과 어떻게 통합되는지도 보여 줍니다.

시스템의 물리적 아키텍처는 이 책 [II부](#page--1-0)에서 설명하는 수많은 아키텍처 스타일—마이크로서비스, 레이어드 아키텍처, 이벤트 기반 아키텍처 등—중 하나(또는 그 조합)와 일치해야 합니다.

많은 아키텍트가 논리적 아키텍처를 만드는 단계를 건너뛰고 곧바로 물리적 아키텍처를 정의하고 싶어 하지만, 우리는 그렇게 하지 말라고 권합니다. 물리적 아키텍처만으로는 시스템의 기능이 어디에 위치하고 어떻게 조합되는지 명확히 드러나지 않는 경우가 많습니다. 예를 들어 결제 처리 기능이 여러 서비스에 분산되어 있으면, 물리적 다이어그램만 보고서는 이 기능이 다른 시스템 부분과 어떻게 연결되는지 파악하기 어렵습니다. 또한 물리적 아키텍처는 개발 팀에게 모놀리식 또는 분산형 시스템을 구축하거나 코드를 조직하는 방법에 대한 단서를 제공하지 못하는 경우가 많아, 유지보수·테스트·배포가 어려운 무질서한 아키텍처가 생기곤 합니다.

일반적으로 시스템의 논리적 아키텍처는 물리적 아키텍처와 독립적입니다. 다시 말해 논리적 아키텍처를 만들 때 초점은 시스템이 수행하는 기능이 무엇인지, 그 기능을 어떻게 경계 지을지, 기능적 부분들이 어떻게 협력할지에 맞춰져 있으며, 물리적 구조를 먼저 결정할 필요는 없습니다. 예를 들어 [그림](#page-6-0) 8-4와 같은 논리적 아키텍처를 만든 아키텍트는 해당 컴포넌트를 하나의 배포 단위인 모놀리스로 둘지, 별도의 서비스로 분리할지 아직 결정하지 않은 상태일 수 있습니다.

다시 강조하자면, 논리적 아키텍처 다이어그램과 물리적 아키텍처 다이어그램은 서로 다릅니다. 둘 다 아키텍처 문서화와 분석에 필요하며, 서로 다른 통찰을 제공합니다.

## 논리적 아키텍처 만들기 (Erstellen einer logischen Architektur)

논리적 아키텍처를 만들려면 논리적 컴포넌트를 지속적으로 식별하고 필요에 따라 재구성해야 합니다. *컴포넌트 식별*은 [그림](#page-10-0) 8-6에서처럼 반복적인 피드백 루프로 수행하는 것이 가장 효과적입니다. 후보 컴포넌트를 정의한 뒤, 피드백을 받아가며 지속적으로 다듬습니다.

<span id="page-10-0"></span>![Abbildung 8-6: 컴포넌트 식별과 리팩터링 순환](_page_10_Figure_2.jpeg)

그림 8-6. 컴포넌트 식별 및 리팩터링 순환

아키텍트는 먼저 핵심 컴포넌트를 식별하고, 그다음 사용자 스토리나 요구사항을 해당 컴포넌트에 할당합니다. 이후 각 컴포넌트의 역할과 책임을 분석하여 할당이 타당한지 확인하고, 시스템이 지원해야 하는 아키텍처 특성을 고려해 리팩터링이 필요한지 결정합니다. 마지막으로 이러한 분석을 바탕으로 컴포넌트를 정제합니다. 이 과정은 사실상 끝나지 않는 피드백 루프입니다.

이 워크플로는 신규 시스템뿐 아니라 기존 시스템에 기능이 추가되거나 변경될 때도 동일하게 사용할 수 있습니다. 예를 들어, 주문 시스템에 매장 픽업 기능을 도입하려면 일정 예약 기능을 추가하고 기존 주문 프로세스를 수정해야 합니다. 이 변경은 새로운 컴포넌트가 필요하거나 기존 컴포넌트의 책임을 조정할 것을 요구할 수 있으며, 그에 따라 코드 리팩터링이나 새로운 컴포넌트 정의가 뒤따릅니다.

이제 논리적 컴포넌트를 식별하고 정제하는 단계들을 차례대로 살펴보겠습니다.

### **핵심 컴포넌트 식별 (Identifizierung von Kernkomponenten)**

핵심 컴포넌트를 식별한다는 것은 전체 시스템에 필수적인 주요 기능 영역을 찾아내는 일입니다. 일반적으로 디렉터리 구조나 네임스페이스의 최상위 폴더(예: `order_entry`, `warehousing`, `inventory`)가 이러한 영역을 나타냅니다. 이후 각 영역을 더 세분화하여 논리적 컴포넌트를 도출하게 됩니다.

새로운 논리적 아키텍처를 시작하거나 기존 아키텍처에 큰 변화를 줄 때 많은 아키텍트가 처음부터 완벽한 컴포넌트 집합을 만들려고 애쓰곤 하지만, 이는 오히려 역효과를 낳습니다. 시스템의 핵심 기능을 기반으로 "가장 그럴듯한" 초기 컴포넌트를 빠르게 정의한 다음, [그림](#page-10-0) 8-6의 워크플로에 따라 반복적으로 다듬는 편이 훨씬 낫습니다. 시스템과 요구사항에 대해 거의 아는 것이 없을 때 완벽을 추구하는 것보다, 학습을 통해 컴포넌트를 계속 재작업하는 방법이 훨씬 효율적입니다.

대부분의 경우 논리적 컴포넌트를 정의하기 전에 모든 요구사항이나 명세를 알 필요가 없습니다. 초기 핵심 컴포넌트는 사용자가 수행하는 가장 중요한 작업이나 시스템의 주요 처리 흐름을 기준으로 하는 경우가 많습니다.

우리는 초기 핵심 컴포넌트를 비어 있는 양동이에 비유합니다. 아키텍트가 사용자 스토리나 요구사항을 컴포넌트에 할당해 "채워 넣기" 전까지는 아무 기능도 하지 못합니다. [그림](#page-13-0) 8-7에서 볼 수 있듯, 컴포넌트 이름은 제안된 역할과 책임을 암시하지만, 사용자 스토리가 할당되기 전까지는 단지 후보일 뿐입니다.

<span id="page-13-0"></span>![Abbildung 8-7: 초기 컴포넌트는 사용자 스토리를 기다리는 빈 버킷과 같다](_page_13_Picture_1.jpeg)

그림 8-7. 초기 컴포넌트는 사용자 스토리를 기다리는 빈 버킷과 같다

다음 절에서 소개할 두 가지 접근법(워크플로와 액터/액션)은 이러한 초기 버킷을 찾는 데 유용하지만, 세 번째 접근법인 엔티티 함정은 피해야 합니다.

### **워크플로 접근법 (Der Workflow-Ansatz)**

아키텍트가 초기 핵심 컴포넌트를 식별할 때 자주 사용하는 방법이 *워크플로 접근법*입니다. 이름에서 알 수 있듯, 사용자가 시스템을 통해 거치는 주요 정상 동작 흐름(또는 요청을 처리하는 핵심 워크플로)을 따라가며 각 단계에 해당하는 컴포넌트를 정의합니다. 전체 흐름을 파악한 뒤, 단계별로 컴포넌트를 도출할 수 있습니다.

예를 들어 새로운 주문 접수 시스템을 만든다고 가정해 봅시다. 아직 구체적인 요구사항은 모르지만, 새 주문을 처리하는 일반적인 워크플로는 알고 있습니다. 그러면 워크플로 각 단계를 컴포넌트에 매핑할 수 있습니다.

1. 사용자가 상품 카탈로그를 탐색한다 → Item Browser
2. 사용자가 주문을 입력한다 → Order Placement
3. 사용자가 주문 대금을 지급한다 → Order Payment
4. 주문 내역을 이메일로 전송한다 → Customer Notification
5. 주문을 준비한다 → Order Fulfillment
6. 주문을 배송한다 → Order Shipment
7. 주문이 배송되었음을 고객에게 이메일로 알린다 → Customer Notification
8. 배송 상태를 추적한다 → Order Tracking

워크플로 접근법을 사용한다고 해서 각 단계마다 새로운 컴포넌트가 생기는 것은 아닙니다. 위 예에서 단계 4와 7 모두 Customer Notification 컴포넌트를 사용합니다. 아키텍트는 가능한 한 많은 주요 워크플로나 사용자 여정을 모델링하고, 각 단계에 해당하는 컴포넌트를 식별합니다.

다시 말하지만, 이는 논리적 아키텍처가 어떻게 생길지에 대한 "가장 그럴듯한" 추정일 뿐이며, 이 단계에서 도출된 컴포넌트는 아직 책임이 없는 빈 버킷입니다. 개발이 진행되면서 자연스럽게 변경될 것이며, 이는 [그림](#page-10-0) 8-6의 반복적 특성을 보여 줍니다. 시스템의 모든 워크플로를 모델링하려고 애쓰기보다, 가장 중요한 워크플로에 집중하고 나머지는 시스템을 더 잘 이해하고 사용자 스토리를 수집하면서 채워 나가세요.

### **액터/액션 접근법 (Der Akteur/Aktionsansatz)**

액터/액션 접근법은 시스템과 상호작용하는 주요 액터(사용자 유형 또는 외부 시스템)를 식별하고, 각 액터가 수행하는 핵심 액션을 나열한 뒤, 이를 기반으로 컴포넌트를 정의하는 방식입니다. 이때 시스템 자체도 청구서 발행이나 재고 보충과 같은 자동화된 기능을 수행하는 하나의 액터로 취급합니다.

액터/액션 접근법을 적용하면 다음과 같은 액터들을 도출할 수 있습니다.

### *고객 액터 (Kunde Schauspieler)*

- 상품을 검색한다 → Item Search
- 상품의 세부 정보를 확인한다 → Item Details
- 주문을 생성한다 → Order Placement
- 주문을 취소한다 → Order Cancel
- 신규 고객으로 등록한다 → Customer Registration
- 고객 정보를 갱신한다 → Customer Profile

#### *주문 포장 담당 액터 (Packer Schauspieler bestellen)*

- 상자 크기를 선택한다 → Order Fulfillment
- 주문을 배송 준비 완료 상태로 표시한다 → Order Fulfillment
- 주문을 고객에게 발송한다 → Order Shipment

#### *시스템 액터 (Systemakteur)*

- 재고를 조정한다 → Inventory Management
- 공급업체에 추가 재고를 주문한다 → Supplier Ordering
- 결제를 적용한다 → Order Payment

워크플로 접근법과 마찬가지로, 액터/액션 접근법에서도 각 액션마다 새로운 컴포넌트를 만들 필요는 없습니다. 예컨대 박스 크기 선택과 배송 준비 완료 표시라는 두 액션은 모두 Order Fulfillment 컴포넌트가 담당합니다.

액터/액션 접근법은 아키텍트가 모델링하려는 워크플로 수에 따라 워크플로 접근법보다 더 많은 컴포넌트를 만들어 내는 경향이 있습니다. 그럼에도 이 방법을 사용하면 세부 요구사항이나 명세를 받기 전이라도, 초기 핵심 컴포넌트와 그 사이의 상호작용을 미리 파악할 수 있습니다.

이러한 액터와 액션을 컴포넌트에 연결하면, 각 컴포넌트가 담당해야 할 기능을 명확히 정의할 수 있습니다.

### **엔티티 함정 (Die Entitätsfalle)**

컴포넌트를 식별할 때 흔히 빠지는 함정 중 하나는 *엔티티 함정(Entity Trap)*입니다. 이는 시스템의 물리적 또는 논리적 엔티티(예: 주문, 고객, 제품) 이름을 그대로 따서 컴포넌트를 정의하고, 해당 엔티티와 관련된 모든 기능을 하나의 컴포넌트에 몰아넣는 패턴입니다.

엔티티 함정에 빠지면 세 가지 문제가 발생합니다. 첫째, 컴포넌트 이름이 해당 컴포넌트의 역할을 설명하지 않습니다. 예를 들어 `Order Manager`라는 컴포넌트 이름은 "주문을 관리한다"는 모호한 답변 밖에 주지 못하며, 시스템에서 어떤 구체적인 책임을 지는지 알려 주지 않습니다. 반면 `Validate Order`와 같은 이름은 컴포넌트의 역할이 명확하게 전달됩니다. `Manager`, `Supervisor`, `Controller`, `Handler`, `Engine`, `Processor`와 같은 접미사가 붙은 컴포넌트 이름은 엔티티 함정에 빠졌다는 강력한 신호입니다.

둘째, 컴포넌트가 도메인 기능의 덤프 장소가 됩니다. [그림](#page-19-0) 8-8에서처럼 `Order Manager`라는 엔티티 기반 컴포넌트에는 주문 검증, 주문 생성, 주문 이력, 주문 이행, 주문 배송, 주문 추적 등 모든 주문 관련 기능이 들어가게 됩니다. 이는 개발자가 한 번쯤 만들었던, 문자열·날짜·시간 계산 등 온갖 기능을 덕지덕지 붙여 둔 "싱크대" 유틸리티 클래스와 다를 바 없습니다.

셋째, 컴포넌트가 지나치게 거대해져서 본연의 목적을 잃습니다. `Validate Order` 예처럼 하나의 목적만 수행하는 세밀한 컴포넌트 대신, 엔티티 기반 컴포넌트는 방대해지고 유지보수·테스트·배포가 어려워져 신뢰성이 떨어집니다.

<span id="page-19-0"></span>![Abbildung 8-8: 엔티티 함정이 과다 책임 컴포넌트를 만듦](_page_19_Figure_0.jpeg)

그림 8-8. 엔티티 함정은 책임이 과도한 컴포넌트를 만든다

만약 아키텍트가 실제로 엔티티를 중심으로 하여 CRUD(생성, 조회, 갱신, 삭제) 작업만 수행하는 시스템을 구축한다면, 그 시스템엔 아키텍처가 아니라 CRUD 기반 프레임워크, 도구, 혹은 노-코드/로우-코드 환경이 더 적합합니다. 그러면 개발자는 해당 엔티티를 다루는 대부분의 코드를 자동 생성할 수 있습니다.

### **사용자 스토리를 컴포넌트에 할당하기 (Zuweisung von User Stories zu Komponenten)**

논리적 아키텍처를 만드는 다음 단계는 사용자 스토리나 요구사항을 논리적 컴포넌트에 할당하는 것입니다. 사용자 스토리나 요구사항은 사전에 완전히 파악되지 않은 경우가 많고, 시스템이 진화하면서 함께 발전하므로 이 작업은 반복적입니다. 이 단계의 목적은 빈칸을 채우고 컴포넌트에 구체적인 역할과 책임을 부여하는 것으로, [그림](#page-20-0) 8-9에서 볼 수 있습니다.

<span id="page-20-0"></span>![Abbildung 8-9: 사용자 스토리로 컴포넌트 역할을 채움](_page_20_Picture_1.jpeg)

그림 8-9. 사용자 스토리나 요구사항으로 빈 버킷(컴포넌트)을 채운다

사용자 스토리가 논리적 컴포넌트를 어떻게 발전시키는지 살펴보기 위해 다음 사용자 스토리를 고려해 보겠습니다.

*고객 #1*

고객으로서 주문을 제출하기 전에 모든 정보를 정확히 입력했는지 확인받고 싶습니다.

### *주문 준비 담당자*

주문을 준비하는 사람으로서 어떤 크기의 상자를 사용해야 하는지 알고 싶습니다. 그래야 최대한 효율적으로 포장할 수 있습니다.

### *고객 #2*

고객으로서 주문 상태가 바뀔 때마다 이메일을 받아 항상 상황을 알고 싶습니다.

아키텍트가 현재까지 다음과 같은 논리적 컴포넌트를 식별했다고 가정해 보겠습니다.

- Order Placement
- Order Fulfillment
- Order Shipment
- Inventory Management

첫 번째 사용자 스토리는 사용자가 주문을 제출할 때 상호작용하는 컴포넌트이기 때문에 Order Placement에 할당하는 것이 합리적입니다.

*주문 검증(고객 #1 사용자 스토리) → Order Placement*

박스 크기를 결정하는 일은 주문을 준비하고 포장하는 시스템 로직 전체를 담당하는 Order Fulfillment 컴포넌트가 수행하는 것이 타당합니다.

*상자 크기 결정(주문 준비 담당자 사용자 스토리) → Order Fulfillment*

그렇다면 세 번째 사용자 스토리는 어떨까요? 주문이 접수되었거나 배송 준비 중이거나 발송되었을 때 어떤 컴포넌트가 고객에게 이메일을 보내야 할까요? 답은 Order Placement, Order Fulfillment, Order Shipment일 수 있습니다. 하지만 사용자 스토리는 특정 디렉터리나 네임스페이스에 위치한 소스 코드로 구현되어야 합니다. 코드를 세 컴포넌트에 흩뿌리는 것은 좋지 않으므로, 아키텍트는 이 사용자 스토리를 처리할 새로운 컴포넌트를 정의해야 합니다.

*고객 이메일 전송(고객 #2 사용자 스토리) → Customer Notification (신규)*

Order Placement, Order Fulfillment, Order Shipment 컴포넌트는 새롭게 정의한 컴포넌트에게 이메일을 보내야 한다는 사실을 전달해야 합니다. 이 변경이 반영된 논리적 아키텍처는 [그림](#page-23-0) 8-10과 같습니다.

<span id="page-23-0"></span>![Abbildung 8-10: 새로운 사용자 스토리에 따라 컴포넌트가 진화함](_page_23_Figure_0.jpeg)

그림 8-10. 새로운 사용자 스토리에 따라 컴포넌트가 진화한다

### **역할과 책임 분석 (Analyse der Rollen und Verantwortlichkeiten)**

논리적 컴포넌트를 정제하는 다음 단계는 각 컴포넌트의 역할과 책임을 분석하는 것입니다. 이를 통해 해당 컴포넌트에 할당된 요구사항이나 사용자 스토리가 적절한지, 그리고 컴포넌트가 과도한 일을 하고 있지 않은지 확인할 수 있습니다. 이 단계의 핵심은 컴포넌트가 담당하는 동작들이 얼마나 밀접하게 연관돼 있는지를 나타내는 *코헤전*을 확인하는 것입니다. 시간이 지남에 따라 컴포넌트는 서로 연관된 작업만 포함하고 있어도 너무 커질 수 있습니다.

예를 들어 아키텍트가 Order Placement 컴포넌트에 다음 요구사항을 할당했다고 가정해 보겠습니다.

- 모든 필드가 정확히 채워졌는지 확인한다.
- 품목 설명, 수량, 가격이 포함된 장바구니를 표시한다.
- 올바른 배송 주소를 결정한다.
- 결제 정보를 수집한다.
- 고유한 주문 ID를 생성한다.
- 주문에 대한 결제를 처리한다.
- 주문된 품목의 재고 수량을 조정한다.
- 고객에게 주문 요약 이메일을 보낸다.

아키텍트가 이 컴포넌트의 역할과 책임을 서술한다면 다음과 같을 것입니다.

*이 컴포넌트는 주문을 검증하고 아이템 이미지·설명·수량·가격이 포함된 유효한 장바구니를 표시한다. 또한 올바른 배송 주소를 파악하고 고객의 결제 정보를 수집한다. 더불어 결제를 수행하고, 재고를 조정하며, 고객에게 주문 요약 이메일을 보낼 책임이 있다.*

이 모든 작업이 주문과 관련되어 있지만, Order Placement 컴포넌트가 결제, 재고 조정, 고객 이메일 발송까지 담당한다는 것은 분명 과도한 책임입니다. 컴포넌트가 너무 많은 일을 맡고 있는지 파악하는 한 가지 방법은 "그리고"(und), "또한"(auch), "추가로"(zusätzlich), "~뿐 아니라"(sowohl ... als auch) 같은 접속사나 쉼표가 지나치게 많이 쓰였는지 확인하는 것입니다.

앞서 언급했듯 논리적 컴포넌트는 코드 저장소의 네임스페이스나 디렉터리로 표현됩니다. Order Placement 컴포넌트의 모든 소스 코드는 `com/app/order/placement` 또는 `com.app.order.placement`와 같은 동일한 디렉터리나 네임스페이스에 위치합니다. 이는 한 디렉터리에 너무 많은 기능과 코드가 모여 있다는 뜻입니다. 따라서 결제 처리, 재고 관리, 이메일 통신을 위한 클래스 파일을 각 기능 전용 디렉터리로 분리하는 것이 타당하며, 이것이 바로 논리적 컴포넌트를 분리하는 이유입니다.

아키텍트가 결제, 재고 조정, 고객 이메일 발송 책임을 별도 컴포넌트로 옮기면, 각 컴포넌트의 책임이 줄어 유지보수·테스트·배포가 쉬워집니다. 그 결과 컴포넌트의 책임은 다음과 같이 정리됩니다.

#### *Order Placement*

- 모든 필드가 정확히 채워졌는지 주문을 검증한다.
- 품목 설명·수량·가격이 포함된 장바구니를 표시한다.
- 올바른 배송 주소를 결정한다.
- 결제 정보를 수집한다.
- 고유한 주문 ID를 생성한다.

### *Payment Processing*

결제를 수행한다.

### *Inventory Management*

주문된 품목의 재고 수량을 조정한다.

### *Customer Notification*

고객에게 주문 요약 이메일을 보낸다.

각 컴포넌트의 역할과 책임이 훨씬 명확해졌습니다.

### **아키텍처 특성 분석 (Analysieren der architektonischen Merkmale)**

마지막 분석 단계는 시스템에 필요한 *아키텍처 특성(architektonische Merkmale)*을 고려하는 것입니다. 확장성, 신뢰성, 가용성, 장애 허용성, 탄력성, 민첩성(변화에 빠르게 대응할 수 있는 능력)과 같은 일부 아키텍처 특성은 논리적 컴포넌트의 크기에 영향을 줄 수 있습니다.

예를 들어, 큰 컴포넌트를 더 작은 컴포넌트로 나누면 각각을 유지보수하고 테스트하기 쉬워져 민첩성이 향상되고, 필요에 따라 독립적으로 확장할 수 있는 여지가 커집니다. 반대로 과도하게 세분화하면 시스템 전체의 복잡성을 높여 다른 품질 속성에 부정적 영향을 줄 수도 있습니다. 따라서 컴포넌트 분해 전략을 결정할 때 필요한 아키텍처 특성을 반드시 고려해야 합니다.

아키텍트는 논리적 아키텍처를 정의하기 전에 시스템에 가장 중요한 아키텍처 특성이 무엇인지 파악해야 하므로, 이러한 분석은 일반적으로 해당 특성을 결정한 *이후에* 수행됩니다.

### **컴포넌트 리팩터링 (Komponenten der Umstrukturierung)**

요구사항과 아키텍처 특성이 밝혀지면서, 기존에 정의한 논리적 컴포넌트를 리팩터링해야 할 수도 있습니다. 이는 새로운 컴포넌트를 도입하거나, 기존 컴포넌트를 분할하거나, 책임을 재배치하는 작업이 될 수 있습니다. 리팩터링은 단 한 번으로 끝나지 않으며, 시스템이 진화함에 따라 지속해서 수행됩니다. 아키텍트는 새로운 정보가 나타나면 항상 컴포넌트 설계를 재검토하고, 논리적 아키텍처가 최신 상태를 유지하도록 해야 합니다.

소프트웨어 설계에서 피드백은 필수입니다. 아키텍트는 개발자와 긴밀하게 협업하며 컴포넌트 설계를 지속적으로 재검토해야 합니다. 소프트웨어를 구축하다 보면 예기치 못한 난관이 계속 등장하기 때문에, 컴포넌트 설계에 있어서도 반복적인 접근이 필요합니다. 애플리케이션 개발이 깊어질수록 아키텍트와 개발자는 어떤 행동과 책임이 어디에 위치해야 하는지 더 잘 이해하게 됩니다.

따라서 아키텍트는 새로운 시스템뿐 아니라 장기간 유지보수되는 제품에서도, 전체 수명 주기 동안 컴포넌트를 자주 재구성하게 될 것이라는 사실을 당연하게 받아들여야 합니다.

## 컴포넌트 결합도 (Bauteil-Kopplung)

아키텍트의 핵심 목표 중 하나는 느슨하게 결합된 시스템을 설계하는 것입니다. 컴포넌트 결합도는 두 컴포넌트가 서로에게 얼마나 의존하는지를 나타냅니다. 결합도가 높으면 변경 사항이 쉽게 전파되고, 시스템 전체의 복잡성과 위험이 증가합니다. 반대로 결합도가 낮으면 컴포넌트가 서로에게 미치는 영향이 줄어들어 유지보수성과 확장성이 향상됩니다. 심지어 직접 통신하지 않는 컴포넌트라도, 공통된 의존성이나 공유된 지식 때문에 서로 결합될 수 있습니다(그림 8-11 참조).

아키텍트는 다음 세 가지 결합도 형태를 이해하고 관리해야 합니다.

- 정적 결합도
- 시간적 결합도
- 지식 기반 결합도(데미터 법칙과 관련)

### **정적 결합도 (Statische Kopplung)**

정적 결합도는 컴파일 타임에 결정되는 컴포넌트 간 의존 관계를 의미합니다. 예를 들어 Order Placement 컴포넌트가 Payment Processing 컴포넌트를 직접 호출한다면 두 컴포넌트는 정적으로 결합되어 있습니다. 정적 결합도가 높으면 하나의 컴포넌트를 변경할 때 다른 컴포넌트도 함께 수정해야 할 가능성이 높습니다.

정적 결합도를 낮추는 방법으로는 인터페이스나 추상화를 도입하거나, 이벤트 기반 통신을 활용하거나, 의존성 역전을 통해 구체 구현에 대한 직접 참조를 줄이는 방식이 있습니다. 이러한 기법은 컴포넌트 간 계약을 명확히 하고, 구현 세부사항이 다른 컴포넌트에 누출되는 것을 방지합니다.

<span id="page-30-0"></span>![Abbildung 8-11: 컴포넌트 간 직접 참조가 만드는 정적 결합도](_page_30_Picture_0.jpeg)

그림 8-11. 컴포넌트 간 직접 참조는 정적 결합도를 높인다

정적 결합도를 이해하려면 들어오는 의존성과 나가는 의존성 모두를 살펴봐야 합니다. *구심 결합도(afferente Kopplung)*, 즉 입력 혹은 팬인 결합도는 다른 컴포넌트가 특정 컴포넌트에 얼마나 의존하는지를 나타내며, 일반적으로 *CA*로 표기합니다. [그림](#page-31-0) 8-12에서처럼 주문 확인 이메일을 보내려면 Order Placement와 Order Shipment가 모두 Customer Notification 컴포넌트에 의존하므로, Customer Notification은 구심 결합도 2를 가집니다.

<span id="page-31-0"></span>![Abbildung 8-12: Customer Notification 컴포넌트의 구심 결합도](_page_31_Figure_1.jpeg)

그림 8-12. Customer Notification 컴포넌트는 Order Placement와 Order Shipment에 의해 구심 결합된다

반대로 *원심 결합도(efferente Kopplung)*, 즉 출력 혹은 팬아웃 결합도는 해당 컴포넌트가 다른 컴포넌트에 얼마나 의존하는지를 보여 주며, 보통 *CE*라고 표기합니다. [그림](#page-32-0) 8-13에서 보듯 Order Placement는 Order Fulfillment에 의존하므로 원심 결합도 1을 가집니다.

<span id="page-32-0"></span>![Abbildung 8-13: Order Placement 컴포넌트의 원심 결합도](_page_32_Figure_1.jpeg)

그림 8-13. Order Placement 컴포넌트는 Order Fulfillment에 의존한다

정적 결합도를 완전히 없앨 수는 없지만, 시스템 전반에 걸쳐 균형 있게 분포시키고 불필요한 의존을 제거하는 것이 중요합니다.

### **시간적 결합도 (Zeitliche Kopplung)**

*시간적 결합도*는 정적인 의존성과 달리 시간 제약이나 단일 작업 단위(트랜잭션)에 기반한 의존성을 의미합니다. 예를 들어 주문을 처리할 때는 Order Placement의 기능이 Order Shipment보다 먼저 실행되어야 하므로, 두 컴포넌트는 순서에 의해 결합됩니다.

시간적 결합도는 현재 사용 가능한 도구로는 파악하기 어렵고, 대부분 설계 문서나 오류 상황을 통해 발견됩니다. 가능하다면 비동기 메시징, 큐, 이벤트 등 비차단 메커니즘을 사용해 서로 동시에 존재해야 하는 요구를 줄이고, 특정 순서가 강하게 묶여 있는 부분을 느슨하게 만드는 것이 좋습니다.

### **데미터 법칙 (Das Gesetz der Demeter)**

아키텍트는 시스템을 설계할 때 느슨한 결합을 추구하라는 말을 끊임없이 듣습니다. 컴포넌트나 서비스 간 결합도가 낮을수록 시스템은 유지보수가 쉽고, 테스트가 간단하며, 변경과 장애에 따른 위험도 줄어듭니다.

느슨한 결합을 달성하는 기법 중 하나가 *데미터 법칙(Gesetz der Demeter)*, 혹은 *최소 지식 원칙*입니다. 그리스 신화에서 여신 데메테르는 전 세계의 곡식을 생산했지만, 사람들이 그것을 어떻게 사용하는지는 몰랐습니다. 즉, 그녀는 세상의 나머지 부분과 거의 연결되어 있지 않았습니다.

이 법칙은 일반적으로 "당신의 친구에게만 이야기하라"로 요약되며, 한 컴포넌트가 다른 컴포넌트의 내부 구조나 세부 호출 사슬을 알지 못하도록 해 결합도를 낮추는 것을 목표로 합니다. 말은 단순해 보이지만 실제로 적용하기는 쉽지 않습니다.

예를 들어 Order Placement 컴포넌트가 주문을 처리하기 위해 Payment Processing, Inventory Management, Customer Notification을 순서대로 호출해야 한다고 합시다. Order Placement가 이 모든 단계와 세부 호출 순서를 "알고" 있다면, 이 지식 자체가 결합도가 됩니다. 대신 Order Placement가 Inventory Management와만 상호작용하고, Inventory Management가 필요한 다른 컴포넌트를 호출하게 하면 Order Placement가 알아야 할 정보가 줄어들어 결합도가 낮아집니다.

<span id="page-34-0"></span>![Abbildung 8-14: 주문 접수 컴포넌트의 지식 이동 상세](_page_34_Figure_1.jpeg)

그림 8-14. Order Placement 컴포넌트에 있던 지식을 Inventory Management로 옮긴다

Inventory Management로 지식을 옮기면 Order Placement의 결합도가 줄어들지만, 대신 Inventory Management의 결합도가 높아질 수 있습니다. 데미터 법칙을 적용한다고 해서 시스템 전체 결합도가 반드시 줄어드는 것은 아니며, 결합도의 분포가 재조정되는 경우가 많습니다.

<span id="page-36-0"></span>![Abbildung 8-15: 지식을 줄여 결합도를 낮춘 주문 접수 컴포넌트](_page_36_Figure_1.jpeg)

그림 8-15. Order Placement 컴포넌트는 적은 지식을 보유할수록 시스템과 덜 결합된다

## 사례 연구: Going, Going, Gone - 컴포넌트 발굴 (Fallstudie: Going, Going, Gone - Komponenten entdecken)

특별한 제약이 없고 일반적으로 적용 가능한 컴포넌트 분해가 필요한 팀이라면 액터/액션 접근법이 좋은 출발점입니다.

GGG(Going, Going, Gone)에 액터/액션 접근법을 적용하면 세 가지 주요 역할이 드러납니다. *입찰자(Bidder)*, *경매인(Auctioneer)*, 그리고 내부 동작을 위한 일종의 공통 액터로서의 *시스템(System)*입니다. 이 역할들은 시스템과 다음과 같은 주요 액션으로 상호작용합니다.

#### *Bidder*

- 라이브 비디오 스트림을 본다.
- 입찰 라이브 스트림을 시청한다.
- 입찰을 제출한다.

#### *Auctioneer*

- 라이브 입찰을 시스템에 입력한다.
- 온라인 입찰을 수락한다.
- 품목을 판매 완료로 표시한다.

### *System*

- 경매를 시작한다.
- 결제를 처리한다.
- 입찰자 활동을 추적한다.

이러한 액션을 기반으로 아키텍트는 GGG를 위한 초기 컴포넌트 세트를 만들고 반복적으로 정제할 수 있습니다. 한 가지 가능한 해법은 [그림](#page-39-0) 8-16과 같습니다.

![Abbildung 8-16: GGG 초기 컴포넌트 설계](_page_39_Figure_0.jpeg)

[그림](#page-39-0) 8-16에서 각 역할과 액션은 컴포넌트에 대응됩니다. 컴포넌트는 정보를 주고받기 위해 협력해야 하며, 이 설계에서 선택한 컴포넌트는 다음과 같습니다.

#### *Video Streamer*

사용자에게 라이브 경매를 스트리밍한다.

#### *Bid Streamer*

입찰이 들어오는 즉시 사용자에게 전달한다. Video Streamer와 Bid Streamer는 모두 입찰자에게 경매를 읽기 전용 방식으로 보여 준다.

### *Bid Capture*

경매인과 입찰자의 입찰을 수집한다.

### *Bid Tracker*

입찰을 추적하며 시스템 오브 레코드 역할을 한다.

### *Auction Session*

경매를 시작한다. 특정 품목에 대한 경매가 종료되고 낙찰자가 결정되면, 이 컴포넌트가 결제 및 주문 이행 단계를 촉발하고, 다음 품목에 대한 알림을 입찰자에게 보낸다.

#### *Payment*

신용카드 결제를 위한 서드파티 결제 처리기다.

첫 번째 [컴포넌트 식별](#page-10-0) 라운드 후(그림 8-6 참조), 아키텍트는 앞서 도출한 아키텍처 특성 중 어떤 것이 컴포넌트 설계를 변경시킬지 분석합니다. 현재 설계는 입찰자와 경매인의 입찰을 모두 수집하는 Bid Capture 컴포넌트를 포함합니다. 기능적으로는 모든 입찰을 동일한 방식으로 수집하고 처리할 수 있기 때문에 타당해 보입니다. 하지만 앞서 식별한 아키텍처 특성 중 어떤 것이 입찰 수집에 필요할까요? 경매인은 수천 명이 동시에 접속할 수 있는 입찰자만큼의 확장성이나 탄력성이 필요하지 않을 수도 있습니다.

마찬가지로 경매인은 다른 시스템 부분보다 높은 신뢰성과 가용성을 요구할 수 있습니다. 예를 들어 입찰자가 로그인하지 못하거나 연결이 끊어지는 것은 비즈니스에 나쁘지만, 경매인에게 이러한 문제가 발생하면 치명적일 수 있습니다.

입찰자와 경매인이 동일한 아키텍처 특성에 대해 서로 다른 요구를 가진다는 점을 지원하기 위해, 아키텍트는 Bid Capture 컴포넌트를 Bid Capture와 Auctioneer Capture 두 개로 분할하기로 결정합니다. 갱신된 설계는 [그림](#page-43-0) 8-17에 나와 있습니다.

아키텍트는 Auctioneer Capture를 위한 새 컴포넌트를 만들고, Auctioneer Capture에서 Bid Streamer(온라인 입찰자에게 라이브 입찰을 보여 주기 위해)와 Bid Tracker(입찰 스트림을 관리하기 위해)로 이어지는 정보 링크도 갱신합니다. Bid Tracker는 이제 경매인의 단일 정보 스트림과 입찰자들의 다양한 스트림을 결합하는 컴포넌트입니다.

![Abbildung 8-17: Auctioneer Capture를 추가한 갱신 설계](_page_43_Figure_0.jpeg)

[그림](#page-43-0) 8-17의 설계가 최종 설계일 가능성은 크지 않습니다. 새 요구사항—예를 들어 신규 계정 등록 방법, 결제 기능 관리 방식 등—이 더 드러나야 합니다. 그럼에도 이 설계는 추가 반복을 위한 훌륭한 출발점입니다.

이것은 GGG 문제를 해결하기 위한 한 가지 컴포넌트 집합일 뿐이며, 유일하거나 최선의 해법이라는 뜻은 아닙니다. 단 하나의 방식으로만 구현할 수 있는 소프트웨어 시스템은 거의 없습니다. 어떤 설계에도 항상 다수의 트레이드오프가 존재합니다. 아키텍트라면 "유일한 정답"을 찾는 데 집착하지 말고, 가능한 한 객관적으로 다양한 설계 결정의 트레이드오프를 평가한 뒤, "가장 덜 나쁜" 트레이드오프를 가진 설계를 선택해야 합니다.
