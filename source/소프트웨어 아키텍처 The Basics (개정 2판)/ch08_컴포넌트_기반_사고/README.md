# ch08 컴포넌트 기반 사고

## 주요 요약

본 브리핑 문서는 소프트웨어 아키텍처의 핵심 원칙인 **'컴포넌트 기반 사고(Component-Based Thinking)'**를 심층적으로 분석합니다. 이 접근법은 시스템을 특정 ** 비즈니스 기능**을 수행하는 **논리적 컴포넌트들의 집합**으로 간주하며, 아키텍트가 시스템을 바라보는 관점을 제시합니다.

### 핵심 내용은 다음과 같습니다.

* **논리적 아키텍처의 정의**: 컴포넌트는 시스템의 **기능적 구성 요소**로, 소스 코드의 네임스페이스나 디렉토리 구조로 구체화됩니다. 이는 시스템이 무엇을 하는지에 초점을 맞춘 **'논리적 아키텍처(Logical Architecture)'**를 형성하며, 서비스나 데이터베이스 같은 물리적 요소를 다루는 **'물리적 아키텍처(Physical Architecture)'** 와 구분됩니다. 잘 정의된 논리적 아키텍처는 유지보수, 테스트, 배포가 용이한 구조의 기반이 됩니다.
* **컴포넌트 식별을 위한 반복적 프로세스**: 논리적 아키텍처는 일회성 작업이 아닌, **지속적인 피드백 루프** 를 통해 개발됩니다. 이 프로세스는 (1)초기 핵심 컴포넌트 식별, (2)사용자 스토리 할당, (3)역할 및 책임 분석, (4)아키텍처 특성 분석, (5)필요에 따른 리팩토링 및 추가 단계를 포함합니다.
* **핵심 컴포넌트 식별 기법**: 초기 컴포넌트 도출을 위해 **'워크플로우 접근법(Workflow Approach)'**(사용자 동선 기반)과 **'액터/액션 접근법(Actor/Action Approach)'**(사용자 유형과 행동 기반)이 유용합니다. 반면, 데이터 엔티티를 중심으로 컴포넌트를 만드는 **'엔티티 함정(Entity Trap)'**은 역할이 모호하고 책임이 과도한 컴포넌트를 낳는 ** 안티패턴**이므로 피해야 합니다.
* **느슨한 결합의 중요성**: 시스템의 유지보수성과 신뢰성을 높이려면 컴포넌트 간 **결합도(Coupling)**를 낮게 유지하는 것이 중요합니다. 이는 **'디미터 법칙(Law of Demeter)'**(최소 지식의 원칙)을 적용하여 달성할 수 있습니다. 즉, 각 컴포넌트가 시스템의 다른 부분에 대해 갖는 지식을 최소화함으로써, 변경의 파급 효과를 줄이고 독립성을 높일 수 있습니다.

![컴포넌트 기반 사고 개요](unnamed.png)

## 컴포넌트 기반 사고의 이해

** 컴포넌트 기반 사고**는 시스템의 구조를 상호작용하는 **논리적 컴포넌트들의 집합**으로 파악하는 **아키텍처적 접근법**입니다. 이는 클래스 수준이 아닌, 전체 시스템의 **기능적 구성 요소**를 중심으로 시스템을 설계하고 이해하는 방식입니다.

### 컴포넌트 정의

**논리적 컴포넌트**는 소프트웨어 시스템의 **'구성 요소(building blocks)'**입니다. 이는 특정 목적을 가진 집의 여러 방(침실, 주방, 욕실 등)에 비유할 수 있습니다. 각 컴포넌트는 ** 재고 관리**, **주문 처리**, **결제 처리** 등 특정 **비즈니스 기능**을 수행하며, 이러한 컴포넌트들이 모여 전체 시스템을 이룹니다.

* **물리적 구현**: 소프트웨어 아키텍처에서 논리적 컴포넌트는 일반적으로 특정 기능을 구현하는 소스 코드를 포함하는 **네임스페이스**또는 ** 디렉토리 구조**로 나타납니다. 보통 디렉토리 구조의 **최하위 노드(leaf node)** 가 논리적 컴포넌트에 해당하며, 상위 디렉토리는 시스템의 **도메인 및 하위 도메인**을 나타냅니다.
* **예시**: `order_entry/ordering/payment`라는 디렉토리 경로는 **'결제 처리(Payment Processing)'**컴포넌트를 나타낼 수 있습니다.

### 논리적 아키텍처와 물리적 아키텍처

아키텍처는 시스템의 ** 기능적 구성(논리적)**과 ** 물리적 구현(물리적)**이라는 두 가지 관점에서 볼 수 있습니다.

#### 논리적 아키텍처

** 논리적 아키텍처**는 시스템의 **논리적 컴포넌트들**과 그들 간의 **상호작용**을 정의합니다.

* **구성 요소**: 시스템의 기능적 구성 요소, **행위자(사용자)**와의 상호작용, 데이터가 사용되거나 전달되는 위치를 나타내는 ** 데이터 저장소** (데이터베이스가 아님)를 포함할 수 있습니다.
* **초점**: 사용자 인터페이스, 데이터베이스, 서비스 등 물리적 요소를 배제하고 **시스템이 무엇을 하는지**, 기능이 **어떻게 구분되고 상호작용하는지** 에 중점을 둡니다.
* **독립성**: 물리적 배포 방식(예: 모놀리식 또는 마이크로서비스)에 구애받지 않고 정의될 수 있습니다.

#### 물리적 아키텍처

**물리적 아키텍처**는 서비스, 사용자 인터페이스, 데이터베이스 등과 같은 **물리적 결과물** 을 포함합니다.

* **구성 요소**: 실제 배포되는 **서비스**, **서버**, **데이터베이스**, **메시지 큐** 등의 물리적 요소들을 보여줍니다.
* **아키텍처 스타일**: 마이크로서비스, 계층형 아키텍처, 이벤트 기반 아키텍처 등 구체적인 **아키텍처 스타일**에 부합해야 합니다.

#### 논리적 아키텍처의 중요성

많은 아키텍트들이 논리적 아키텍처 단계를 건너뛰고 바로 물리적 아키텍처 설계를 시작하지만, 이는 바람직하지 않습니다. **물리적 아키텍처만으로는 시스템 기능의 위치나 연관성을 파악하기 어렵기**때문입니다. 예를 들어, 결제 처리 기능이 여러 서비스에 분산되어 있을 경우, 전체적인 연관성을 이해하기 힘듭니다. 논리적 아키텍처가 없으면 개발팀이 코드를 어떻게 구성해야 할지에 대한 지침을 얻지 못해, 결국 ** 유지보수, 테스트, 배포가 어려운 비구조적인 시스템**이 될 가능성이 높습니다.

## 논리적 아키텍처 구축 프로세스

논리적 아키텍처 구축은 컴포넌트를 **지속적으로 식별하고 재구성**하는 **반복적인 프로세스**입니다.


1. **초기 핵심 컴포넌트 식별**: 시스템의 핵심 기능을 기반으로 초기 컴포넌트를 도출합니다.
2. **컴포넌트에 사용자 스토리 할당**: 각 컴포넌트에 요구사항이나 사용자 스토리를 할당하여 역할을 부여합니다.
3. **역할 및 책임 분석**: 각 컴포넌트가 너무 많은 책임을 지지 않는지, 할당된 스토리가 적절한지 분석합니다. (**응집도**)
4. **아키텍처 특성 분석**: 시스템이 지원해야 할 확장성, 안정성 등의 **아키텍처 특성**을 고려하여 컴포넌트 설계를 검토합니다.
5. **필요에 따른 컴포넌트 리팩토링 또는 추가**: 분석 결과를 바탕으로 컴포넌트를 분리, 통합 또는 신규 생성합니다.

이 프로세스는 시스템이 개발되고 변경됨에 따라 계속해서 반복되는 **피드백 루프**입니다.

## 핵심 컴포넌트 식별 기법

초기 컴포넌트를 완벽하게 정의하려 하기보다는, 시스템의 핵심 기능을 바탕으로 **'최선의 추측'**을 하고 반복적으로 개선하는 것이 더 나은 접근 방식입니다. 초기 컴포넌트는 기능이 채워지기 전까지는 이름만 있는 **'빈 양동이'**와 같습니다.

### 워크플로우 접근법

사용자가 시스템을 통해 겪는 ** 주요 작업 흐름(happy path)** 을 기반으로 컴포넌트를 식별하는 방법입니다.

* **예시 (주문 시스템)**:
  1. 사용자가 상품 카탈로그를 탐색한다 → **Item Browser**컴포넌트
  2. 사용자가 주문을 제출한다 → ** Order Placement**컴포넌트
  3. 사용자가 주문을 결제한다 → ** Order Payment**컴포넌트
  4. 사용자에게 주문 내역 이메일을 보낸다 → ** Customer Notification**컴포넌트
  5. 주문을 준비한다 → ** Order Fulfillment**컴포넌트

### 액터/액션 접근법

시스템의 여러 ** 행위자(actor)**와 그들이 수행하는 ** 주요 행동(action)**을 중심으로 컴포넌트를 식별합니다. 이 방법은 ** 여러 사용자 유형이 있는 시스템**에 특히 유용합니다.

* **예시 (주문 시스템)**:
  * **고객 (Customer Actor)**:
    * 상품 검색 → **Item Search**
    * 주문 제출 → **Order Placement**
    * 고객 정보 업데이트 → **Customer Profile**
  * **주문 포장 담당자 (Order Packer Actor)**:
    * 박스 크기 선택 → **Order Fulfillment**
    * 고객에게 주문 발송 → **Order Shipment**
  * **시스템 (System Actor)**:
    * 재고 조정 → **Inventory Management**
    * 결제 적용 → **Order Payment**

### 엔티티 함정 (안티패턴)

시스템의 **데이터 엔티티** (예: Customer, Item, Order)를 기반으로 **Customer Manager**, **Item Manager** 와 같은 컴포넌트를 만드는 것은 피해야 할 **안티패턴** 입니다.

* **문제점 1: 모호한 이름**: Order Manager가 정확히 무슨 일을 하는지 이름만으로는 알 수 없습니다.
* **문제점 2: 책임 과다**: Order Manager는 주문 유효성 검사, 제출, 이력, 처리, 배송 등 모든 주문 관련 기능을 떠안는 **'쓰레기 처리장'** 이 되기 쉽습니다.
* **문제점 3: 낮은 응집도**: 컴포넌트가 너무 많은 일을 하게 되어 유지보수, 테스트, 배포가 어려워지고 신뢰성이 떨어집니다.

## 컴포넌트 구체화 및 개선

### 컴포넌트에 사용자 스토리 할당

**'빈 양동이'** 같았던 초기 컴포넌트에 **사용자 스토리를 할당** 함으로써 구체적인 **역할과 책임** 을 부여합니다. 이 과정에서 새로운 컴포넌트가 필요하다는 사실을 발견하기도 합니다. 예를 들어, **'주문 상태 변경 시 고객에게 이메일 발송'** 이라는 요구사항은 Order Placement, Order Fulfillment, Order Shipment 컴포넌트 모두와 관련이 있습니다. 이메일 발송 코드를 여러 곳에 분산시키는 대신, 이 기능을 전담할 **Customer Notification** 이라는 새로운 컴포넌트를 정의하는 것이 합리적입니다.

### 역할 및 책임 분석 (응집도)

각 컴포넌트에 할당된 책임들을 분석하여 컴포넌트가 너무 많은 일을 하고 있지는 않은지 확인합니다. 이 단계의 핵심은 **응집도(cohesion)**, 즉 컴포넌트 내의 기능들이 얼마나 서로 밀접하게 관련되어 있는지를 평가하는 것입니다.

* **과도한 책임의 징후**: 컴포넌트의 역할을 설명할 때 "그리고", "또한", "추가적으로"와 같은 접속사가 자주 사용된다면 책임이 과도할 수 있습니다.
* **리팩토링 예시**: Order Placement 컴포넌트가 주문 검증, 장바구니 표시뿐만 아니라 결제 처리, 재고 조정, 이메일 발송까지 담당한다면 책임이 너무 많습니다. 이 경우, **Payment Processing**, **Inventory Management**, **Customer Notification** 컴포넌트로 책임을 분리하여 각 컴포넌트의 역할을 명확히 해야 합니다.

### 아키텍처 특성 분석

**확장성**, **신뢰성**, **가용성**, **민첩성** 등 시스템이 요구하는 **아키텍처 특성** 또한 컴포넌트의 크기와 설계에 영향을 미칩니다. 예를 들어, 기능적으로는 하나의 컴포넌트로 묶을 수 있더라도, 일부 기능이 다른 기능보다 훨씬 높은 확장성을 요구한다면 해당 부분을 **별도의 컴포넌트로 분리** 하는 것을 고려해야 합니다.

### 컴포넌트 리팩토링

소프트웨어 개발 과정에서는 예상치 못한 문제들이 발생하기 마련이므로 컴포넌트 설계는 **지속적으로 수정되고 개선**되어야 합니다. 아키텍트는 개발자와의 협력을 통해 시스템의 **수명 주기 동안 컴포넌트를 자주 리팩토링**할 준비가 되어 있어야 합니다.

## 컴포넌트 결합도 관리

**결합도(Coupling)** 는 컴포넌트들이 서로 통신하거나 한 컴포넌트의 변경이 다른 컴포넌트에 영향을 미치는 정도를 의미합니다. 결합도가 높을수록 시스템을 유지보수하고 테스트하기 어려워지므로, **느슨한 결합**을 지향해야 합니다.

### 정적 결합도

컴포넌트들이 **동기적으로 통신**할 때 발생하는 결합입니다.

* **구심적 결합도 (Afferent Coupling, Cₐ, Fan-in)**: 다른 컴포넌트들이 특정 컴포넌트에 의존하는 정도입니다. 예를 들어, 여러 컴포넌트가 Customer Notification 컴포넌트를 호출한다면, 이 컴포넌트의 구심적 결합도는 높습니다.
* **원심적 결합도 (Efferent Coupling, Cₑ, Fan-out)**: 특정 컴포넌트가 다른 컴포넌트들에 의존하는 정도입니다. 예를 들어, Order Placement 컴포넌트가 Order Fulfillment 컴포넌트를 호출한다면, Order Placement는 원심적 결합도를 가집니다.

### 시간적 결합도

**시간 순서나 트랜잭션**에 기반한 **비정적 의존성**입니다. 예를 들어, Order Placement 기능은 반드시 Order Shipment 기능보다 먼저 호출되어야 합니다. 이러한 시간적 결합은 도구로 찾아내기 어려워 **설계 문서나 오류 분석**을 통해 발견되는 경우가 많습니다.

## 느슨한 결합을 위한 디미터 법칙

시스템을 느슨하게 결합시키는 유용한 기법 중 하나는 **디미터 법칙(Law of Demeter)**, 즉 **최소 지식의 원칙(Principle of Least Knowledge)**입니다.

### 원칙: 최소 지식의 원칙

이 원칙은 **"하나의 컴포넌트는 다른 컴포넌트에 대해 제한된 지식만을 가져야 한다"** 고 명시합니다. 컴포넌트가 다른 부분에 대해 더 많이 알수록 결합도는 높아집니다.

### 적용 예시

* **문제 상황**: Order Placement 컴포넌트가 주문을 받으면, Inventory Management에 재고 감소를 지시합니다. 만약 재고가 부족하면, Order Placement는 Supplier Ordering에 재고 추가 주문을, Item Pricing에 가격 인상을 지시해야 한다는 사실을 알고 있습니다. 이처럼 Order Placement는 다른 컴포넌트들이 수행해야 할 작업에 대한 **지식을 너무 많이** 가지고 있어 결합도가 높습니다.
* **해결책**: Order Placement의 지식을 다른 컴포넌트로 **이전** 합니다. 재고 부족 시 재고를 추가 주문하고 가격을 조정해야 한다는 지식을 Inventory Management 컴포넌트로 옮깁니다.
* **결과**: Order Placement는 **재고 감소만 지시**하고, 그 이후의 일은 Inventory Management가 책임집니다. 이로써 Order Placement의 결합도는 낮아집니다. 이 과정에서 Inventory Management의 결합도는 높아질 수 있지만, 이는 **시스템 전반의 결합도를 재분배**하여 특정 컴포넌트의 복잡도를 낮추는 효과가 있습니다.

## 사례 연구: "Going, Going, Gone" 컴포넌트 도출

온라인 경매 시스템 **"Going, Going, Gone(GGG)"**에 ** 액터/액션 접근법**을 적용하여 컴포넌트를 도출하는 과정은 다음과 같습니다.

1. **액터 및 액션 식별**:
  * **입찰자 (Bidder)**: 라이브 비디오 스트림 보기, 입찰하기
  * **경매사 (Auctioneer)**: 현장 입찰 입력, 온라인 입찰 받기, 판매 완료 표시
  * **시스템 (System)**: 경매 시작, 결제, 입찰자 활동 추적
2. **초기 컴포넌트 도출**: 각 액션에 따라 **Video Streamer**, **Bid Streamer**, **Bid Capture**, **Bid Tracker**, **Auction Session**, **Payment** 등의 초기 컴포넌트를 만듭니다.
3. **아키텍처 특성 분석 및 리팩토링**:
  * Bid Capture 컴포넌트는 입찰자와 경매사의 입찰을 모두 처리하도록 설계되었습니다.
  * 그러나 **수천 명에 이를 수 있는 입찰자** 는 높은 **확장성과 탄력성** 이 필요하며, **단 한 명인 경매사** 는 그보다는 높은 **신뢰성과 가용성** 이 중요합니다.
  * 이처럼 **동일한 기능에 대해 서로 다른 아키텍처 특성** 이 요구되므로, Bid Capture 컴포넌트를 **Bid Capture(입찰자용)** 와 **Auctioneer Capture(경매사용)** 두 개로 분리합니다.

이와 같이 도출된 설계는 **최종안이 아닐 수 있으며**, 추가적인 요구사항이 발견됨에 따라 계속해서 개선될 것입니다. 소프트웨어 설계에는 **유일한 정답이 없으며**, 아키텍트는 다양한 설계안의 장단점을 객관적으로 평가하여 **'가장 덜 나쁜' 절충안** 을 선택해야 합니다.
