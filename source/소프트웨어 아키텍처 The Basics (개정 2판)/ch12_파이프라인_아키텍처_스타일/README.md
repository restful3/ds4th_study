# 파이프라인 아키텍처 스타일 브리핑

## 핵심 요약

파이프라인 아키텍처(파이프 및 필터 아키텍처)는 기능을 개별적인 처리 단계로 분리하는 기본적인 소프트웨어 아키텍처 스타일입니다. 이 구조는 특정 비즈니스 기능을 수행하는 **필터(Filter)**와 필터 간에 데이터를 전달하는 단방향 **파이프(Pipe)**라는 두 가지 핵심 구성 요소로 이루어집니다. 일반적으로 모놀리식으로 배포되어 단순성과 낮은 비용이라는 강점을 가지지만, 이로 인해 확장성, 탄력성, 내결함성에는 취약합니다.

핵심적인 특징은 다음과 같습니다.

* 네 가지 필터 유형: 프로세스를 시작하는 생산자(Producer), 데이터를 변환하는 변환기(Transformer), 조건을 검사하는 테스터(Tester), 프로세스를 종료하는 **소비자(Consumer)**로 구성됩니다.
* 단순성과 모듈성: 각 필터는 독립적이고 단일 책임을 가지므로 시스템을 이해하기 쉽고 유지보수가 용이합니다. 이는 Unix 셸의 명령어 조합 방식과 유사한 강력한 재사용성을 제공합니다.
* 배포 유연성: 주로 단일 배포 단위인 모놀리식으로 구현되지만, 각 필터를 별도의 서비스(예: AWS Lambda)로 배포하는 분산 아키텍처로도 구현할 수 있습니다.
* 명확한 트레이드오프: 모놀리식 구현은 단순성과 비용 효율성이 높지만 운영상의 약점이 뚜렷합니다. 분산형으로 구현하면 확장성 및 내결함성을 개선할 수 있으나, 복잡성과 비용이 증가하는 트레이드오프가 발생합니다.
* 적합한 사용 사례: 데이터 변환(ETL), 전자 데이터 교환(EDI)과 같이 명확하고 순차적인 단방향 처리 단계가 있는 시스템에 가장 적합합니다.

결론적으로 파이프라인 아키텍처는 **예측 가능한 워크플로우**를 가진 시스템을 신속하고 경제적으로 구축할 때 효과적인 선택지입니다.

![파이프라인 아키텍처 개요](unnamed.png)

## 파이프라인 아키텍처의 핵심 개념

### 기본 토폴로지: 파이프와 필터

파이프라인 아키텍처의 토폴로지(Topology)는 필터와 파이프라는 두 가지 주요 구성 요소로 정의됩니다.

* **필터(Filter)**: 시스템의 핵심 기능과 비즈니스 로직을 포함하는 독립적인 기능 단위입니다. 필터는 일반적으로 **상태를 가지지 않으며(stateless)** 오직 하나의 작업만 수행하도록 설계됩니다. 복합적인 작업은 단일 필터가 아닌 여러 필터의 연속적인 처리로 해결됩니다.
* **파이프(Pipe)**: 필터 간의 통신 채널 역할을 하며, 한 필터에서 처리된 데이터를 다음 필터로 전달합니다. 파이프는 일반적으로 **단방향(unidirectional)**이며 **점대점(point-to-point)** 방식으로 통신합니다.

이 두 구성 요소는 아래 그림과 같이 **체인 형태**로 연결되어 **단일 배포 단위**를 형성합니다.



### 필터의 네 가지 유형

파이프라인 아키텍처 스타일에는 역할에 따라 **네 가지 유형의 필터**가 존재합니다.

| 필터 유형 | 설명 | 유사 개념 (함수형 프로그래밍) |
|---------|------|---------------------------|
| **생산자(Producer)** | 프로세스의 시작점으로, 외부에서 데이터를 생성하거나 수신하여 파이프라인으로 내보냅니다. **소스(Source)**라고도 불립니다. (예: UI 입력, 외부 시스템 요청) | 해당 없음 |
| **변환기(Transformer)** | 입력을 받아 데이터를 변환, 보강 또는 계산한 후 다음 필터로 전달합니다. | **map** 함수 |
| **테스터(Tester)** | 입력을 받아 하나 이상의 기준에 따라 검사하고, 그 결과에 따라 데이터를 다음 단계로 전달할지 여부를 결정합니다. | **reduce** 함수와 유사 |
| **소비자(Consumer)** | 파이프라인 흐름의 종착점입니다. 최종 처리 결과를 데이터베이스에 저장하거나 UI 화면에 표시하는 역할을 합니다. | 해당 없음 |

이러한 필터들의 조합은 놀라운 효율성을 보여줍니다. **Donald Knuth**가 텍스트 파일에서 가장 빈번하게 사용된 단어 n개를 찾는 프로그램을 10페이지 이상의 Pascal 코드로 작성한 반면, **Doug McIlroy**는 단 6줄의 Unix 셸 스크립트(파이프와 필터 원칙 사용)로 동일한 문제를 해결한 일화는 이 아키텍처의 강력함을 보여줍니다.

tr -cs A-Za-z '\n' | tr A-Z a-z | sort | uniq -c | sort -rn | sed ${1}q


### 파이프의 역할 및 특징

파이프는 **필터 간의 통신**을 담당하는 채널입니다. 각 파이프는 **단방향**이며 한 소스에서 입력을 받아 다른 소스로 출력을 전달합니다. **페이로드(payload)**는 어떤 형식이든 가능하지만, 일반적으로 높은 성능을 위해 작은 데이터 덩어리를 선호합니다.

* **모놀리식 환경**: 스레드나 임베디드 메시징을 사용하여 비동기 통신을 구현할 수 있습니다.
* **분산 환경**: 필터가 별도의 서비스로 배포될 경우, 파이프는 REST, 메시징, 스트리밍 등 원격 통신 프로토콜을 통한 호출로 구현됩니다.

## 구현 및 배포 고려사항

### 배포 토폴로지

대부분의 파이프라인 아키텍처는 모든 필터가 동일한 배포 단위에 포함된 **모놀리식(Monolithic)**으로 구현됩니다. 하지만 각 필터(또는 필터 그룹)를 별도의 서비스로 배포하여 동기식 또는 비동기식 원격 호출을 사용하는 **분산 아키텍처(Distributed Architecture)**로 구축하는 것도 가능합니다.

### 데이터 토폴로지

데이터베이스 토폴로지는 **단일 데이터베이스**를 사용하는 것부터 각 필터마다 **별도의 데이터베이스**를 두는 것까지 매우 다양할 수 있습니다. 아래 예시는 **지속적인 피트니스 함수(아키텍처 테스트)**를 위한 파이프라인으로, 여러 필터가 각각 다른 데이터베이스를 사용하는 구조를 보여줍니다.

* Capture Raw Data (생산자): 원시 데이터를 로드하기 위해 'Raw data' 데이터베이스에 접근합니다.
* Time Series Sector (변환기): 분석 기간과 같은 구성 정보를 'Selection rules' 데이터베이스에서 읽습니다.
* Trend Analyzer (변환기): 데이터를 분석하고 그 결과를 'Analytics' 데이터베이스에 저장합니다.
* Graphing Tool (소비자): 최종적으로 분석 데이터를 기반으로 그래픽 보고서를 생성합니다.



### 클라우드 환경에서의 활용

파이프라인 아키텍처는 높은 모듈성 덕분에 **클라우드 기반 배포**에 매우 적합합니다. AWS에서는 **AWS Step Functions**를 사용하여 파이프라인 워크플로우를 정의하고, 각 필터를 별도의 **Lambda 함수**로 배포할 수 있습니다.

아래는 위 피트니스 함수 예시를 AWS Step Functions로 구현한 코드의 일부입니다.

{
  "Comment": "Measure and analyze scalability trends.",
  "StartAt": "Capture Raw Data",
  "States": {
    "Capture Raw Data": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:region:account_id:function:ra",
      "Next": "Time Series Selector"
    },
    "Time Series Selector": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:region:account_id:function:ti",
      "Next": "Trend Analyzer"
    },
    "Trend Analyzer": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:region:account_id:function:tr",
      "Next": "Graphing Tool"
    },
    "Graphing Tool": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:region:account_id:function:gr",
      "End": true
    }
  }
}


## 아키텍처 특성 분석

### 강점과 약점

파이프라인 아키텍처의 특성은 아래 표와 같이 평가될 수 있습니다. (1점: 매우 약함, 5점: 매우 강함)

| 아키텍처 특성 | 분류 | 별점 평가 |
|------------|------|---------|
| 전체 비용 | - | $ |
| 분할 유형 | 구조적 | 기술적(Technical) |
| 퀀텀 수 | 구조적 | 1 |
| 단순성 | 구조적 | ⭐⭐⭐⭐⭐ |
| 모듈성 | 구조적 | ⭐⭐ |
| 유지보수성 | 엔지니어링 | ⭐⭐ |
| 테스트 용이성 | 엔지니어링 | ⭐⭐⭐⭐ |
| 배포 용이성 | 엔지니어링 | ⭐⭐ |
| 발전성 | 엔지니어링 | ⭐⭐⭐ |
| 응답성 | 운영적 | ⭐⭐⭐⭐ |
| 확장성 | 운영적 | ⭐ |
| 탄력성 | 운영적 | ⭐ |
| 내결함성 | 운영적 | ⭐ |

* **강점:**
  * **단순성 및 비용**: 일반적으로 모놀리식으로 구현되므로 분산 아키텍처의 복잡성이 없어 이해하기 쉽고 구축 및 유지보수 비용이 저렴합니다.
  * **모듈성**: 각 필터가 독립적이므로 다른 필터에 영향을 주지 않고 특정 필터를 수정하거나 교체할 수 있습니다.
  * **테스트 용이성**: 필터의 모듈성 덕분에 개별 단위 테스트가 용이합니다.
* **약점:**
  * **확장성, 탄력성, 내결함성**: 모놀리식 구현의 특성상 이 세 가지 운영적 특성에서 매우 낮은 점수를 받습니다. 예를 들어, 메모리 부족과 같은 문제가 한 필터에서 발생하면 전체 애플리케이션이 중단될 수 있습니다.

### 트레이드오프

이 아키텍처의 가장 큰 **트레이드오프**는 **배포 방식**에 있습니다. 약점인 확장성, 탄력성, 내결함성은 각 필터를 비동기 통신을 사용하는 **분산 서비스**로 배포함으로써 크게 개선할 수 있습니다. 하지만 이는 아키텍처의 가장 큰 강점인 **단순성과 비용 효율성**을 희생하는 대가를 치릅니다.

## 주요 리스크 및 거버넌스

### 공통 리스크

1. **필터의 과도한 책임**: 필터가 **단일 책임 원칙**을 위반하고 너무 많은 기능을 수행하게 되면 아키텍처의 장점이 사라집니다.
2. **양방향 통신 도입**: 파이프는 단방향으로 설계되어야 합니다. 필터 간 양방향 통신이 필요하다면, 파이프라인 아키텍처가 적합하지 않거나 기능 분리가 잘못되었음을 시사합니다.
3. **오류 상태 처리**: 파이프라인 중간에 오류가 발생했을 때, 전체 프로세스를 정상적으로 종료하고 복구하는 것이 어려울 수 있습니다.
4. **필터 간 계약 관리**: 한 필터가 다음 필터로 전달하는 데이터의 형식(계약)을 변경하면, 후속 필터들이 오작동할 수 있어 엄격한 제어가 필요합니다.

### 거버넌스 전략

필터가 자신의 역할(생산자, 변환기 등)에 충실하도록 유도하는 것이 중요합니다. 이를 위한 기술적 거버넌스 기법 중 하나는 **태그(Tag)**를 사용하는 것입니다. Java에서는 **어노테이션(Annotation)**, C#에서는 **사용자 지정 특성(Custom Attribute)**으로 구현할 수 있습니다.

개발자는 필터의 진입점 클래스에 아래와 같이 태그를 명시함으로써 해당 필터의 유형과 역할을 명확히 인지할 수 있습니다. 이는 개발자가 필터에 **부적절한 책임**을 부여하는 것을 방지하는 데 도움을 줍니다.

* Java 예시:
* C# 예시:

## 적용 사례 및 팀 구성

### 적합한 사용 사례

파이프라인 아키텍처는 **명확하고 순차적인 단방향 처리 단계**가 있는 시스템에 이상적입니다. 특히 시간과 비용 제약이 큰 상황에서 단순성 덕분에 좋은 선택이 될 수 있습니다.

* **전자 데이터 교환(EDI) 도구**: 한 문서 형식을 다른 형식으로 변환하는 작업에 사용됩니다.
* **ETL(Extract, Transform, Load) 도구**: 데이터베이스 간에 데이터를 추출, 변환, 로드하는 데 활용됩니다.
* **오케스트레이터 및 미디에이터**: Apache Camel과 같은 도구에서 비즈니스 프로세스의 한 단계에서 다음 단계로 정보를 전달하는 데 사용됩니다.

아래 다이어그램은 서비스 원격 측정 데이터를 처리하는 **Kafka** 예시를 보여줍니다.



이 시스템에서 **Service Info Capture** 필터는 Kafka에서 데이터를 수신하고, **Duration filter**와 **Uptime filter**는 데이터의 종류를 검사하여 각각 Duration Calculator와 Uptime Calculator 변환 필터로 전달합니다. 최종 결과는 **Database Output** 소비자에 의해 MongoDB에 저장됩니다.

### 부적합한 시나리오

* 높은 확장성, 탄력성, 내결함성이 요구되는 시스템 (모놀리식 구현의 경우)
* 필터 간 양방향 통신이 필요한 시나리오
* 비결정적 워크플로우를 처리해야 하는 경우 (이벤트 기반 아키텍처가 더 적합)

### 팀 토폴로지와의 관계

파이프라인 아키텍처는 높은 모듈성 덕분에 다양한 **팀 토폴로지**와 잘 맞습니다.

* **스트림 정렬 팀(Stream-aligned Teams)**: 시스템의 시작부터 끝까지 하나의 흐름을 소유하는 팀 구조와 잘 어울립니다.
* **역량 강화 팀(Enabling Teams)**: 기존 흐름에 영향을 주지 않고 새로운 필터를 추가하여 실험을 수행하기 용이합니다.
* **복잡한 하위 시스템 팀(Complicated Subsystem Teams)**: 특정 필터의 복잡한 로직에만 독립적으로 집중할 수 있습니다.
* **플랫폼 팀(Platform Teams)**: 공통 도구나 서비스를 개발하여 재사용성을 높일 수 있습니다.
