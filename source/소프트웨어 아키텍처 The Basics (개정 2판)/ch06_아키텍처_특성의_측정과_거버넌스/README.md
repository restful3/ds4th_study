# ch06 아키텍처 특성의 측정과 거버넌스

## Executive Summary

소프트웨어 아키텍처의 핵심 과제는 성능, 모듈성, 확장성과 같은 아키텍처 특성이 모호하거나 조직 내에서 일관성 없이 정의되는 경우가 많다는 점입니다. 이러한 특성을 효과적으로 관리하고 유지하기 위해서는 구체적이고 객관적인 측정 및 거버넌스 체계가 필수적입니다. 본 브리핑 문서는 아키텍처 특성을 측정하고 제어하는 핵심 원칙과 기법을 종합적으로 분석합니다.

핵심적인 접근법은 **민첩성(Agility)** 과 같이 복합적인 특성을 테스트 용이성, 배포 용이성 등 측정 가능한 하위 구성 요소로 분해하는 것입니다. 이를 통해 아키텍처에 대한 공통된 이해를 확립하고 객관적인 평가가 가능해집니다. 측정은 크게 세 가지 유형으로 분류됩니다. 첫째, 운영적 측정은 성능, 확장성 등 직접 계량화할 수 있는 지표를 다루며, 평균 응답 시간뿐만 아니라 최대 응답 시간이나 통계적 모델링을 활용하여 심층적으로 분석합니다. 둘째, 구조적 측정은 코드의 내부 품질을 평가하며, 대표적인 예로 코드의 복잡도를 측정하는 '순환 복잡도(Cyclomatic Complexity)'가 있습니다. 셋째, 프로세스 측정은 테스트 커버리지나 배포 성공률과 같이 개발 프로세스와 연관된 특성을 다룹니다.

아키텍처의 무결성을 지속적으로 유지하기 위한 핵심 도구로 **피트니스 함수(Fitness Function)** 가 제시됩니다. 피트니스 함수는 특정 아키텍처 원칙(예: 계층 간 의존성 규칙, 순환 종속성 금지)이 지켜지는지를 자동으로 검증하는 메커니즘입니다. 이는 단위 테스트, 모니터링, 카오스 엔지니어링 등 기존 도구에 새로운 관점을 적용한 것으로, 아키텍처 거버넌스를 자동화하여 개발 압박 속에서도 중요하지만 긴급하지 않은 원칙들이 훼손되지 않도록 보호합니다. Netflix의 카오스 엔지니어링 사례는 피트니스 함수가 어떻게 시스템의 견고성을 극대화하는지를 잘 보여줍니다.

![아키텍처 특성의 측정과 거버넌스 인포그래픽](unnamed.png)

--------------------------------------------------------------------------------


## 1. 아키텍처 특성 측정의 과제

소프트웨어 아키텍트는 아키텍처 특성을 정의하고 측정하는 데 있어 여러 가지 근본적인 어려움에 직면한다. 이러한 과제를 해결하는 것은 효과적인 아키텍처 관리의 출발점이다.

* **추상성 및 모호성**: '민첩성(Agility)'이나 '배포 용이성(Deployability)'과 같은 많은 아키텍처 특성은 물리적인 실체가 없어 일반적인 용어로는 그 의미가 모호하다. "Wicked fast performance"와 같은 표현은 주관적이며 팀원마다 해석이 다를 수 있다.
* **정의의 불일치**: 동일한 기업 내에서도 부서마다 '성능'과 같은 핵심 특성에 대한 정의가 다를 수 있다. 개발자, 아키텍트, 운영팀이 공통된 정의에 합의하지 못하면 생산적인 논의가 불가능하다.
* **복합적 특성(Composite Characteristics)**: 많은 아키텍처 특성은 실제로는 더 작은 규모의 여러 특성들이 결합된 복합체다. 예를 들어, '민첩성'은 모듈성, 배포 용이성, 테스트 용이성 등으로 분해될 수 있다.

이 문제들을 해결하기 위한 핵심 전략은 복합적인 아키텍처 특성을 그 구성 요소로 **분해(Decomposition)** 하여 객관적으로 측정 가능한 속성을 찾아내는 것이다. 조직 전체가 표준화되고 구체적인 정의를 사용하기로 합의하면, 아키텍처에 대한 보편적인 언어가 형성되어 더 정확한 소통과 측정이 가능해진다.

## 2. 측정 유형별 접근법

아키텍처 특성은 그 성격에 따라 운영적, 구조적, 프로세스적 관점으로 나누어 측정할 수 있다.

### 운영적 측정 (Operational Measures)

성능이나 확장성처럼 직접 측정이 가능한 특성들이 여기에 해당한다. 하지만 이러한 명백해 보이는 지표조차도 팀의 목표에 따라 다양한 해석의 여지를 가진다.

* **다각적 성능 지표**: 단순히 '평균 응답 시간'만 측정할 경우, 1%의 요청이 극단적으로 오래 걸리는 예외 상황(outlier)을 놓칠 수 있다. 따라서 '최대 응답 시간'과 같은 추가 지표를 함께 측정하여 시스템의 안정성을 더 정확히 파악해야 한다.
* **통계적 분석 기반 접근**: 선진적인 팀들은 임의의 목표 수치를 정하는 대신, 시간 경과에 따른 데이터를 기반으로 통계적 모델을 구축한다. 예를 들어, 비디오 스트리밍 서비스는 확장성 데이터를 모델링하고, 실시간 측정값이 예측 모델을 벗어날 때 경고를 발생시킨다. 이는 모델 자체의 오류를 발견하거나 시스템의 실제 문제를 파악하는 데 도움을 준다.
* **진화하는 측정 항목**: 도구, 목표, 디바이스의 발전에 따라 측정 항목은 계속 진화한다. 최근에는 모바일 환경에서의 웹 성능을 파악하기 위해 'First Contentful Paint(최초 콘텐츠 렌더링 시간)', 'First CPU Idle(최초 CPU 유휴 시간)'과 같은 지표가 중요해졌다. 또한, 저대역폭 환경을 고려하여 페이지 다운로드 시 라이브러리 및 프레임워크의 최대 용량을 제한하는 'K-weight budgets'도 중요한 성능 지표로 활용된다.

### 구조적 측정 (Structural Measures)

모듈성과 같이 시스템 내부의 구조적 품질을 측정하는 것은 운영적 특성보다 더 어렵다. 아직 아키텍처의 전반적인 품질을 평가하는 포괄적인 척도는 없지만, 코드 구조의 특정 측면을 평가하는 데 유용한 지표와 도구는 존재한다.

#### 순환 복잡도 (Cyclomatic Complexity, CC)

순환 복잡도는 1976년 Thomas McCabe Sr.가 개발한 코딩 수준의 메트릭으로, 코드의 복잡성을 객관적으로 측정하는 데 사용된다.

* **정의**: 그래프 이론을 코드에 적용하여 계산되며, 특히 코드 내에서 서로 다른 실행 경로를 만드는 **결정 지점(decision points)** 의 수를 기반으로 한다. if문과 같은 조건문이 없는 함수의 CC는 1이며, 조건문이 하나 추가될 때마다 가능한 실행 경로가 늘어나 CC 값이 증가한다.
* **계산 공식**: 단일 함수에 대한 공식은 CC = E − N + 2이다 (여기서 E는 엣지(결정), N은 노드(코드 라인)를 의미).
* **한계**: CC는 코드의 복잡도를 측정할 수는 있지만, 그 복잡도가 문제 도메인에서 비롯된 필연적인 복잡도인지, 아니면 잘못된 설계로 인한 우발적인 복잡도인지 구별하지 못한다. 이는 특히 무차별 대입(brute force) 방식으로 문제를 해결하는 경향이 있는 생성형 AI가 작성한 코드를 평가할 때 유용하다.
* **적정 기준**: 업계에서는 일반적으로 CC 값이 10 미만이면 수용 가능하다고 보지만, 저자들은 5 미만을 유지하는 것이 응집력 있고 잘 설계된 코드를 나타낸다고 권장한다. 테스트 주도 개발(TDD)과 같은 기술적 프랙티스는 자연스럽게 더 작고 복잡도가 낮은 메서드를 생산하는 긍정적인 부수 효과가 있다.

### 프로세스 측정 (Process Measures)

일부 아키텍처 특성은 소프트웨어 개발 프로세스와 밀접하게 연관되어 있다.

* **테스트 용이성(Testability)**: 코드 커버리지 도구를 통해 테스트가 실행하는 코드의 비율을 객관적으로 측정할 수 있다. 하지만 100% 코드 커버리지를 달성했더라도, 검증(assertion) 로직이 부실하다면 코드의 정확성에 대한 신뢰를 줄 수 없다. 즉, 도구는 사고와 의도를 대체할 수 없다.
* **배포 용이성(Deployability)**: 배포 성공률, 배포 소요 시간, 배포 중 발생하는 문제나 오류의 수와 같은 지표로 측정할 수 있다.
* **프로세스가 아키텍처에 미치는 영향**: 배포 용이성과 테스트 용이성이 높은 우선순위를 가질 경우, 아키텍트는 아키텍처 수준에서 모듈성과 격리(isolation)를 강조하게 된다. 이처럼 소프트웨어 프로젝트의 거의 모든 요소는 아키텍트가 중요한 결정을 내리게 만든다면 아키텍처 특성이 될 수 있다.

## 3. 피트니스 함수를 통한 아키텍처 거버넌스

아키텍트가 특성을 정의하고 우선순위를 정한 후, 개발팀이 시간 압박 속에서도 설계를 올바르게 구현하도록 보장하는 방법이 필요하다. 이것이 바로 아키텍처 거버넌스의 역할이며, 이를 자동화하는 강력한 도구가 피트니스 함수이다.

### 피트니스 함수(Fitness Function)란?

**피트니스 함수**는 진화 연산(evolutionary computing) 분야에서 유래한 개념으로, 아키텍처 특성 또는 특성 조합의 무결성에 대한 객관적인 평가를 제공하는 모든 메커니즘을 의미한다. 이는 새로운 프레임워크가 아니라 단위 테스트, 메트릭, 모니터링, 카오스 엔지니어링과 같은 기존 검증 메커니즘을 아키텍처 거버넌스 관점에서 재조명한 것이다.

| 피트니스 함수 유형 | 문제점 | 해결책 | 관련 도구/사례 |
| --- | --- | --- | --- |
| 순환 종속성 방지 | 개발자가 무분별하게 클래스를 임포트해 컴포넌트 간 순환 종속성이 발생하며, 이는 재사용성을 해치고 **Big Ball of Mud** 안티패턴으로 이어진다. | 순환 종속성을 감지하는 테스트를 작성해 지속적 통합(CI) 빌드에 포함시키고, 위반 시 빌드가 실패하도록 만든다. | JDepend |
| 계층형 아키텍처 강제 | 국소적 성능 최적화를 이유로 계층을 우회하면 장기적인 아키텍처 건전성이 훼손된다. | 계층 역할과 허용된 의존성을 코드로 정의하고 위반 시 테스트가 실패하도록 한다. | ArchUnit (Java), NetArchTest (.NET) |
| 카오스 엔지니어링 | 장애는 언젠가 반드시 발생하므로 대비가 부족하면 복원력이 약해진다. | 프로덕션에서 의도적으로 장애(높은 지연, 서버 다운 등)를 시뮬레이션해 대응 능력을 검증한다. | Netflix Chaos Monkey, Chaos Kong |
| 보안 및 규정 준수 | 알려진 취약점이나 운영 규정 위반이 누락될 수 있다. | 프로덕션을 지속적으로 스캔해 보안/거버넌스 규칙 위반 서비스를 찾아낸다. | Netflix Security Monkey, Conformity Monkey |
| 자원 관리 | 더 이상 사용되지 않는 **고아 서비스(orphaned services)** 가 남아 비용을 낭비한다. | 참조되지 않는 인스턴스를 자동 종료해 자원을 회수한다. | Netflix Janitor Monkey |

### 피트니스 함수의 철학

피트니스 함수는 아툴 가완디의 저서 ***체크리스트 선언(The Checklist Manifesto)*** 에서 설명하는 체크리스트와 유사한 역할을 한다. 조종사나 외과 의사가 체크리스트를 사용하는 이유는 그들이 절차를 잊어버려서가 아니라, 복잡하고 반복적인 작업에서 세부 사항을 놓치기 쉽기 때문이다.

마찬가지로 피트니스 함수는 무거운 거버넌스 메커니즘이 아니라, 중요하지만 긴급하지 않은 아키텍처 원칙을 표현하고 자동으로 검증하는 가벼운 알림 장치이다. 이는 아키텍트가 중요한 거버넌스 검사를 아키텍처의 기질(substrate) 자체에 내장하여, 개발자들이 수많은 다른 우선순위에 밀려 중요한 아키텍처 원칙을 우발적으로 위반하는 것을 방지한다. 성공적인 피트니스 함수 구현을 위해서는 아키텍트와 개발자 간의 긴밀한 협업이 필수적이다.
