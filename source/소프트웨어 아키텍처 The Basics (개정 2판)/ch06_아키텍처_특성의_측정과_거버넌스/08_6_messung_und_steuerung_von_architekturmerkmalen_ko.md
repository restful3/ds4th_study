---
lang: ko
format:
  html:
    toc: true
    embed-resources: true
    theme: cosmo
---

# 6장. 아키텍처 특성의 측정과 통제 (Kapitel 6. Messung und Steuerung von Architekturmerkmalen)

이 저작물은 AI의 도움을 받아 번역되었습니다. 여러분의 피드백과 의견을 환영합니다: [translation-feedback@oreilly.com](mailto:translation-feedback@oreilly.com)

소프트웨어 아키텍트는 성능, 탄력성, 확장성과 같은 운영적 특성부터 모듈성, 배포 용이성과 같은 구조적 특성까지 프로젝트 전반에 걸친 엄청나게 다양한 아키텍처 특성과 마주합니다. 모호한 용어나 느슨한 정의 속에서 헤매기보다는 아키텍처 특성을 어떻게 측정하고 통제할 수 있는지를 이해하는 편이 훨씬 유익합니다. 이 장에서는 대표적인 아키텍처 특성 몇 가지를 구체적으로 정의하고, 이를 위한 거버넌스 메커니즘을 설계하는 방법을 살펴봅니다.

# 아키텍처 특성의 측정 (Messung der Architekturmerkmale)

아키텍트가 아키텍처 특성을 정의하는 일은 여러 이유로 어렵습니다.

*물리학처럼 명확하지 않다*

많은 아키텍처 특성은 일상 언어에서 매우 모호합니다. 예를 들어 아키텍트는 *민첩성(Agilität)*이나 *배포 가능성(Einsatzfähigkeit)*을 어떻게 설계해야 할까요? *"살인적으로 빠른 성능(wicked fast performance)"*은 또 무엇을 의미할까요? 업계 사람들은 공통 용어조차 각자 전혀 다른 의미로 사용합니다. 때로는 정당한 이유가 있지만, 때로는 그냥 우연히 그렇게 된 경우도 많습니다.

### *정의의 편차*

같은 조직 안에서도 부서마다 *성능(Leistung)*과 같은 핵심 특성을 다르게 정의하는 상황이 빈번합니다. 개발자, 아키텍트, 운영 책임자 등이 공통된 정의조차 공유하지 못하는데, 어떻게 제대로 된 대화를 나누겠습니까?

#### *너무 복합적이다*

우리의 [5장](#page--1-0) 복합 아키텍처 특성 논의에서 기억하듯, 바람직한 아키텍처 특성 가운데 상당수는 더 작은 특성들의 묶음입니다. 예를 들어 민첩성은 모듈성, 배포 가능성, 테스트 용이성과 같은 특성으로 세분할 수 있습니다.

복합 아키텍처 특성을 구성 요소로 분해하는 일은 세 가지 문제를 모두 해결할 수 있는 객관적인 정의를 마련하는 핵심 단계입니다.

조직 구성원 전체가 아키텍처 특성에 대해 표준화된 구체적 정의를 사용하기로 합의하면, 아키텍처를 위한 공통 *언어*가 생깁니다. 이렇게 표준화하면 복합 특성의 포장을 벗겨 *객관적으로 측정 가능한* 속성을 찾아낼 수 있습니다.

## **운영 지표 (Operative Maßnahmen)**

성능이나 확장성과 같이 직접 측정 가능한 아키텍처 특성도 많지만, 팀의 목표에 따라 해석이 아주 미묘하게 달라집니다. 예를 들어 팀이 특정 요청의 평균 응답 시간을 측정한다고 해 봅시다. 이는 운영적 아키텍처 특성을 가늠하는 유용한 지표입니다. 하지만 평균만 본다면 어떨까요? 전체 요청 가운데 1%가 어떤 모서리 사례 때문에 다른 요청보다 10배 이상 오래 걸린다면? 웹사이트 트래픽이 충분히 많다면 이런 이상치는 눈에 띄지 않을 수도 있습니다. 이상치를 포착하려면 최대 응답 시간도 함께 측정해야 합니다.

성숙한 팀은 단순히 성능 수치를 정해 놓는 데 그치지 않고, 통계 분석에 기반해 정의를 다집니다. 예를 들어 어느 동영상 스트리밍 서비스가 확장성을 모니터링하고 싶다고 합시다. 임의의 수치를 목표치로 정해 두는 대신, 엔지니어는 시간이 지나며 스케일링 데이터를 측정하고 통계 모델을 만들어, 실시간 지표가 예측 모델 범위를 벗어나면 경보를 발생시킵니다. 이런 상황은 두 가지를 의미할 수 있습니다. 모델이 틀렸거나(팀은 이런 사실을 알고 싶어 합니다), 시스템에 문제가 생겼거나(역시 알고 싶어 하죠).

팀이 측정하는 특성의 종류는 도구, 목표, 디바이스, 역량의 발전과 함께 빠르게 변합니다. 최근 들어 많은 팀이 모바일 이용자의 성능 문제를 드러내는 *First Contentful Paint*와 *First CPU Idle*과 같은 지표에 대한 성능 예산을 중점적으로 살펴봅니다. 이런 항목과 그 외 무수한 요소가 계속 변하기 때문에, 팀은 앞으로도 새로운 지표와 측정 방식을 찾아낼 것입니다.

#### **성능의 다양한 맛 (DIE VIELEN GESCHMACKSRICHTUNGEN DER LEISTUNG)**

이 책에서 다루는 많은 아키텍처 특성은 복수의 정의를 갖습니다. 성능이 대표적인 예입니다. 많은 프로젝트는 웹 애플리케이션의 요청·응답 주기가 얼마나 오래 걸리는지와 같은 일반적 성능으로 충분합니다. 하지만 많은 조직의 아키텍트와 DevOps 엔지니어는 애플리케이션의 특정 부분마다 구체적인 성능 예산을 painstaking하게 설정해 둡니다. 예를 들어 사용자의 행동을 연구하고, 특정 용량이나
많은 기업이 사용자의 행동을 분석해 첫 화면이 렌더링되는 최적 시간이 1초의 일부분이라는 사실을 확인했습니다(브라우저나 모바일 기기에서 웹페이지가 진행 중이라는 첫 시각적 신호). 대부분의 애플리케이션이 이 지표를 두 자릿수 초대에서 기록하지만, 보다 많은 사용자를 끌어들이려는 현대적 웹사이트에는 반드시 추적해야 할 핵심 지표입니다. 이런 사이트를 운영하는 기업들은 이를 달성하기 위해 매우 정교한 측정 방식을 채택했습니다.

## **구조적 지표 (Strukturelle Maßnahmen)**

또 다른 범주의 지표는 구조적 특성에 초점을 맞춥니다. 이런 지표는 일반적으로 아키텍트와 개발자가 모듈성, 결합도, 복잡성과 같은 요소에 대해 서로 다른 관점을 갖는다는 사실을 인정합니다. 많은 코드 품질 도구가 이런 구조적 측면을 정량화하려고 시도하며, 가장 오래되고 흔한 지표 중 하나가 바로 *순환 복잡도(zyklomatische Komplexität)*입니다. 순환 복잡도는 모듈성에 가벼운 영향을 주지만, 코드의 복잡도를 측정하는 훌륭한 방법입니다.

#### **순환 복잡도 (ZYKLOMATISCHE KOMPLEXITÄT)**

순환 복잡도(CC)는 1976년 Thomas McCabe가 도입한 지표로, 코드의 복잡도를 수학적으로 측정합니다. 이 지표는 *엣지(E)* 수에서 *노드(N)* 수를 뺀 뒤 2를 더해 계산합니다. 2는 함수의 시작과 끝 지점으로 구성된 단일 구성 요소를 나타냅니다.

순환 복잡도를 계산하려면, 평가 대상 함수의 흐름 그래프를 만들어야 합니다. [예제](#page-6-0) 6-1은 단순한 비교 함수이고, [그림](#page-7-0) 6-1은 해당 함수의 흐름 그래프입니다.

<span id="page-6-0"></span>**예제 6-1. 순환 복잡도를 계산하기 위한 샘플 코드**

```
int compare(int a, int b) {
    if (a == b)
      return 0;
    else if (a > b)
      return 1;
    else
      return -1;
}
```

[예제](#page-6-0) 6-1의 순환 복잡도는 3 − 2 + 2 = 3이며, [그림](#page-7-0) 6-1이 이를 시각화합니다.

<span id="page-7-0"></span>![](_page_7_Figure_1.jpeg)

그림 6-1. 비교 함수의 순환 복잡도 그래프

공식 속 숫자 2는 단일 함수/메서드에 대한 단순화를 의미합니다. 다른 메서드로의 팬아웃 호출(그래프 이론에서는 *연결된 컴포넌트*라고 합니다)이 있다면, 보다 일반화된 공식 CC = E − N + 2P를 사용하며, 여기서 *P*는 연결된 컴포넌트 수를 뜻합니다.

아키텍트와 개발자는 과도하게 복잡한 코드가 "코드 냄새"라는 데 동의합니다. 즉, 코드에서 풍기는 형편없는 징후가 있을 정도로 좋지 않은 상태라는 뜻입니다. 이런 코드는 모듈성, 테스트 용이성, 배포 용이성 등 코드베이스가 가져야 할 거의 모든 바람직한 특성에 해를 끼칩니다. 팀이 시간이 지날수록 높아지는 복잡도를 관리하지 못하면, 결국 코드베이스 전체가 복잡도에 잠식됩니다.

순환 복잡도는 아키텍트에게 주어진 지표가 얼마나 무딜 수 있는지를 잘 보여 줍니다. 이 지표는 코드의 복잡도는 측정하지만, 그 복잡도가 *필요한* 결과(복잡한 문제를 풀기 때문에)인지, 아니면 *우연한* 산물(형편없는 설계를 구현했기 때문에)인지 알려 주지는 않습니다. CC와 같은 지표는 개발자가 작성했든 생성형 AI가 작성했든 코드를 평가할 때 매우 유용합니다. 생성형 AI는 문제를 힘으로 밀어붙이는 경향이 있어 종종 의도치 않은 복잡도를 만들어냅니다.

#### **순환 복잡도의 적정 기준 (WAS IST EIN GUTER WERT FÜR ZYKLOMATISCHE KOMPLEXITÄT?)**

이 주제에 대해 이야기할 때마다 가장 많이 받는 질문은 "CC의 적정 임계값이 얼마인가요?"입니다. 소프트웨어 아키텍처에 관한 모든 질문과 마찬가지로 대답은 "상황에 따라 다르다"입니다. 보다 구체적으로는 문제 도메인의 복잡도에 달려 있습니다. 예를 들어 알고리즘적으로 복잡한 문제라면, 그에 대한 해법 역시 복잡한 함수를 낳습니다. 아키텍트가 CC에서 살펴봐야 할 핵심 질문은 다음과 같습니다. 함수가 복잡한 이유가 도메인 때문인가요, 아니면 형편없는 코딩 때문인가요? 코드가 적절히 분해되지 않았나요? 다시 말해, 거대한 메서드를 더 작고 논리적인 부분으로 나누어 작업(과 복잡도)을 더 작고 잘 작동하는 메서드로 분산할 수 있지 않을까요?

업계에서는 일반적으로 CC가 10 미만이면 허용 가능한 수준으로 봅니다(도메인 복잡성 등 다른 고려 사항이 없다면). 우리는 이 임계값이 너무 높다고 생각하며, 코드가 5 미만이라면 응집력 있고 잘 숙고된 코드라는 신호이기 때문에 더욱 선호합니다. Java 세계의 지표 도구 [Crap4J](http://www.crap4j.org/)는 CC와 코드 커버리지를 조합해 코드가 얼마나 "엉망(crap)"인지 측정합니다. CC가 50을 넘으면 커버리지가 아무리 높아도 엉망인 상태를 만회할 수 없습니다. Neal이 실무에서 본 가장 끔찍한 사례는 어떤 상용 소프트웨어 패키지의 핵심 기능이었던 단일 C 함수로, CC가 800이 넘었습니다! 4,000줄이 넘는 코드가 하나의 함수에 몰려 있었고, 불가능할 정도로 깊은 중첩 루프를 피하기 위해 GOTO 문도 많이 사용했습니다.

테스트 주도 개발(TDD)과 같은 기술적 실천은 평균적으로 특정 문제 영역에 대해 더 작고 덜 복잡한 메서드를 산출하는 긍정적 부수 효과가 있습니다. TDD에서는 개발자가 간단한 테스트를 작성한 뒤, 그 테스트를 통과시키기 위해 필요한 최소한의 코드만 작성하려고 합니다. 불연속적 행동과 좋은 테스트 경계에 집중하다 보니 고르게 생각된, 독립적인 메서드가 탄생하며 CC도 낮아집니다.

### **프로세스 지표 (Prozessmaßnahmen)**

일부 아키텍처 특성은 소프트웨어 개발 프로세스와 겹칩니다. 예를 들어 민첩성은 흔히 바람직한 특성으로 언급되지만, 테스트 용이성과 배포 가능성과 같은 특성들로 구성된 복합 아키텍처 특성입니다.

테스트 용이성은 거의 모든 플랫폼에서 활용 가능한 코드 커버리지 도구로 측정할 수 있으며, 이 도구는 테스트가 코드의 몇 퍼센트를 실행했는지 보고합니다. 하지만 다른 테스트와 마찬가지로, 도구가 사고와 의도를 대신할 수는 없습니다. 예를 들어 코드 커버리지가 100%인 코드베이스일지라도, 부실한 어설션을 사용하면 코드의 정확성에 대한 신뢰를 줄 수 없습니다.

테스트 용이성과 마찬가지로 배포 가능성도 객관적 측정이 가능합니다. 배포 성공률, 배포 소요 시간, 배포 중 발생한 이슈/결함 수 등이 대표적인 지표입니다. 각 팀은 조직과 팀의 우선순위와 목표를 정성·정량적으로 담아낼 수 있는 측정값 조합을 신중하게 선택해야 합니다.

민첩성과 그에 연관된 속성은 명백히 소프트웨어 개발 프로세스와 연관되어 있지만, 그 프로세스가 아키텍처의 구조에도 영향을 줍니다. 예를 들어 손쉬운 배포와 테스트 용이성이 최우선이라면, 아키텍트는 아키텍처 수준에서 우수한 모듈성과 격리를 강조할 것입니다. 이는 구조적 결정을 좌우하는 아키텍처 특성의 한 예입니다. 소프트웨어 프로젝트에서 일어나는 거의 모든 것은 우리의 세 가지 기준을 충족해 아키텍처 특성이 될 수 있으며, 그러면 아키텍트는 이를 고려해 중요한 결정을 내려야 합니다.

# 거버넌스와 피트니스 함수 (Governance- und Fitnessfunktionen)

아키텍처 특성을 정의하고 우선순위를 정한 뒤, 아키텍트는 개발자가 이러한 우선순위를 존중하고 일정 압박과 무관하게 정확하고 안전한 방식으로 설계를 구현하도록 어떻게 보장할 수 있을까요? 많은 소프트웨어 프로젝트가 긴급한 과제에 쫓기지만, 아키텍트 역시 아키텍처를 *통제*할 수 있는 도구와 기법이 필요합니다. 모듈성은 중요하지만 긴급하지 않은 아키텍처 측면의 대표적인 예입니다.

## **규제형 아키텍처 특성 (Merkmale der regulierenden Architektur)**

*거버넌스(Governance)*라는 단어는 "조종하다"라는 뜻의 그리스어 *kubernan*에서 왔으며, 아키텍트 역할의 중요한 요소입니다. 말 그대로, 아키텍트가 영향을 미치고 싶어 하는 소프트웨어 개발 프로세스의 모든 측면을 포괄합니다. 예를 들어 소프트웨어를 안전하게 지키는 일은 분명 중요하지만, 때때로 아키텍트 입장에서는 긴급하지 않을 수도 있습니다. 소프트웨어가 안정적으로 잘 작동하고, 일반적인 공격에도 취약하지 않다면, 목표한 수준의 보안 성숙도를 갖출 수 있습니다. 반대로, 소프트웨어가 자주 다운되고 쉽게 해킹된다면, 보안은 갑자기 가장 급한 문제가 됩니다.

## **피트니스 함수 (Fitness-Funktionen)**

*피트니스 함수(fitness function)*라는 개념은 Neal이 공저한 *Building Evolutionary Architectures*에서 도입되었으며, 이후 빠르게 진화하고 발전해 왔습니다. 이 개념은 종종 진화적 아키텍처의 핵심 개념으로 간주됩니다. 우리는 피트니스 함수를 다음과 같이 정의합니다.

> **피트니스 함수**는 아키텍처 특성에 대한 건설적 또는 파괴적 변화의 영향도를 정확하게 측정하는 기술, 프로세스, 진단을 포함한 *어떤 메커니즘*이다.

피트니스 함수는 아키텍트가 다운로드해서 사용할 수 있는 새로운 프레임워크가 아닙니다. 오히려 기존 도구들을 바라보는 새로운 관점입니다. 정의에서 "*어떤 메커니즘*"이라고 표현한 이유도 여기에 있습니다. 아키텍처 특성 검증 기법은 그 특성만큼이나 다양한 형태를 띱니다. 피트니스 함수는 혼돈 공학(chaos engineering), 지표, 모니터링, 단위 테스트 라이브러리 등 기존 검증 메커니즘과 용도에 따라 겹치기도 합니다([그림](#page-15-0) 6-2 참조).

<span id="page-15-0"></span>![](_page_15_Figure_0.jpeg)

그림 6-2. 피트니스 함수의 메커니즘

아키텍처 특성에 따라 피트니스 함수를 구현하는 도구도 매우 다양합니다. 이제 모듈성의 여러 측면을 검증하는 피트니스 함수 예시를 살펴보겠습니다.

### **순환 의존성 (Zyklische Abhängigkeiten)**

모듈성은 대부분의 아키텍트가 중시하는 암묵적 아키텍처 특성입니다. 모듈성이 제대로 관리되지 않으면 코드베이스의 구조가 손상되므로, 아키텍트는 대체로 모듈성을 지키는 일을 강조합니다. 하지만 많은 플랫폼에서는 이런 선한 의도에 반하는 힘이 작용합니다. 예를 들어 Java나 .NET IDE에서 아직 import하지 않은 클래스를 참조하면, IDE가 자동 import 여부를 묻는 대화 상자를 띄웁니다. 이런 일이 빈번하다 보니 프로그래머 대부분은 자동 import 대화 상자를 반사적으로 확인합니다. 하지만 컴포넌트 사이에서 무분별하게 클래스를 import하면 모듈성은 순식간에 붕괴할 수 있습니다. [그림](#page-17-0) 6-3은 아키텍트가 특히 피하고 싶어 하는 대표적 안티패턴인 *순환 의존성*을 보여 줍니다.

[그림](#page-17-0) 6-3에서는 각 컴포넌트가 다른 모든 컴포넌트를 참조합니다. 이런 네트워크는 모듈성을 해치며, 다른 컴포넌트를 끌어들이지 않고 특정 컴포넌트 하나만 재사용하는 것이 불가능해집니다. 게다가 그 다른 컴포넌트가 또 다른 컴포넌트와 결합되어 있다면 어떻게 될까요? 전체 아키텍처는 점점 더 [Big Ball of Mud](https://oreil.ly/usx7p) 안티패턴으로 기울어집니다. 그렇다면 아키텍트는 개발자 어깨 너머를 계속 지켜보지 않고도 이런 행동을 어떻게 제어할 수 있을까요? 코드 리뷰는 도움이 되지만, 개발 주기의 너무 늦은 시점에 진행되어 충분히 효과적이지 않습니다. 개발팀이 코드 리뷰까지 일주일 동안 마음껏 import를 추가했다면, 이미 코드베이스는 큰 피해를 입었을 것입니다.

<span id="page-17-0"></span>![](_page_17_Picture_1.jpeg)

그림 6-3. 컴포넌트 간 순환 의존성

이 문제에 대한 해법은 [예제](#page-17-1) 6-2처럼 사이클을 탐지하는 피트니스 함수를 작성하는 것입니다.

<span id="page-17-1"></span>**예제 6-2. 컴포넌트 사이클을 감지하는 피트니스 함수**

```
public class CycleTest {
    private JDepend jdepend;
    @BeforeEach
    void init() {
      jdepend = new JDepend();
      jdepend.addDirectory("/path/to/project/persistence/classes");
      jdepend.addDirectory("/path/to/project/web/classes");
      jdepend.addDirectory("/path/to/project/thirdpartyjars");
    }
    @Test
    void testAllPackages() {
      Collection packages = jdepend.analyze();
      assertEquals("Cycles exist", false, jdepend.containsCycles());
    }
}
```

이 코드는 메트릭 도구 [JDepend](https://oreil.ly/ozzzk)를 사용해 패키지 간 의존성을 검사합니다. JDepend는 Java 패키지 구조를 이해하며, 사이클을 발견하면 테스트를 실패시킵니다. 아키텍트는 이 테스트를 프로젝트의 지속적 빌드에 포함해, 혈기왕성한 개발자가 실수로 사이클을 도입할까 하는 걱정을 덜 수 있습니다. 이는 소프트웨어 개발에서 *긴급하지 않지만 중요한* 실천을 보호하는 피트니스 함수의 훌륭한 예입니다. 아키텍트에게는 매우 중요한 관심사지만, 일상적인 프로그래밍에는 거의 영향을 주지 않습니다.

### **주요 순열 거리 피트니스 함수 (Abstand von der Hauptsequenz Fitnessfunktion)**

["결합도"](#page--1-1)에서 소개한 다소 에소테릭한 지표인 *주요 순열과의 거리(Distanz zur Hauptreihe)*도 피트니스 함수로 검증할 수 있으며, [예제](#page-19-0) 6-3이 그 방법을 보여 줍니다.

<span id="page-19-0"></span>**예제 6-3. 주요 순열 거리 피트니스 함수**

```
@Test
void AllPackages() {
    double ideal = 0.0;
    double tolerance = 0.5; // 프로젝트에 따라 조정
    Collection packages = jdepend.analyze();
    Iterator iter = packages.iterator();
    while (iter.hasNext()) {
      JavaPackage p = (JavaPackage) iter.next();
      assertEquals("Distance exceeded: " + p.getName(),
        ideal, p.distance(), tolerance);
    }
}
```

이 코드는 JDepend를 사용해 허용 가능한 값의 임계값을 정의하고, 클래스가 허용 범위를 벗어나면 테스트를 실패시킵니다. (다음 절에서 소개할 ArchUnit도 비슷한 피트니스 함수를 만들 수 있도록 해 줍니다.) 아키텍처 특성에 대한 이러한 객관적 측정 예시는 피트니스 함수를 개발하고 적용할 때 개발자와 아키텍트가 협력하는 일이 얼마나 중요한지 잘 보여 줍니다. 아키텍트가 상아탑에 틀어박혀 개발자가 이해할 수 없는 난해한 피트니스 함수를 만드는 것이 아니라, 코드베이스의 품질을 보장하는 자동화된 거버넌스 규칙을 도입하는 것이 목적입니다.

#### **팁 (TIPP)**

피트니스 함수를 도입하기 전에, 아키텍트는 반드시 개발자가 그 목적을 이해했는지 확인해야 합니다.

최근 몇 년 사이 피트니스 함수용 도구는 전보다 훨씬 정교해졌는데, 그중에는 특정 목적을 위한 전문 도구도 있습니다. 대표적인 예가 [ArchUnit](https://archunit.org/)입니다. ArchUnit은 [JUnit 생태계](https://junit.org/)의 여러 부분을 활용하는 Java 테스트 프레임워크로, 사전에 정의된 다양한 거버넌스 규칙을 단위 테스트 형태로 제공하며, 아키텍트가 모듈성을 고려한 맞춤형 테스트를 작성할 수 있게 해 줍니다. [그림](#page-21-0) 6-4의 다층 아키텍처를 살펴보세요.

<span id="page-21-0"></span>![](_page_21_Picture_0.jpeg)

그림 6-4. 다층 아키텍처

[그림](#page-21-0) 6-4처럼 다층 모놀리스를 설계할 때 아키텍트는 분명한 이유가 있어 각 레이어를 정의합니다(이러한 이유와 트레이드오프는 [10장](#page--1-0)에서 설명합니다). 하지만 일부 개발자는 이런 패턴의 중요성을 이해하지 못하며, 다른 이들은 성능과 같은 국지적 우려를 이유로 "허락보다 용서를 구하는 편이 쉽다"는 태도를 취하곤 합니다. 그러나 이들이 아키텍처적 이유를 잠식하도록 방치하면 장기적인 아키텍처 건강이 크게 훼손됩니다.

ArchUnit은 [예제](#page-22-0) 6-4와 같이 피트니스 함수를 통해 이 문제를 해결할 수 있도록 해 줍니다.

<span id="page-22-0"></span>**예제 6-4. 레이어를 통제하는 ArchUnit 피트니스 함수**

```
layeredArchitecture()
    .layer("Controller").definedBy("..controller..")
    .layer("Service").definedBy("..service..")
    .layer("Persistence").definedBy("..persistence..")
    .whereLayer("Controller").mayNotBeAccessedByAnyLayer()
    .whereLayer("Service").mayOnlyBeAccessedByLayers("Controller")
    .whereLayer("Persistence").mayOnlyBeAccessedByLayers("Service");
```

[예제](#page-22-0) 6-4에서 아키텍트는 레이어 간 바람직한 관계를 정의하고, 이를 검증하는 피트니스 함수를 작성해 통제합니다.

.NET 진영에도 [NetArchTest](https://oreil.ly/EMXpv)라는 비슷한 도구가 있으며, [예제](#page-22-1) 6-5는 C#으로 레이어 의존성을 검사하는 방법을 보여 줍니다.

#### <span id="page-22-1"></span>**예제 6-5. 레이어 의존성을 확인하는 NetArchTest**

```
var result = Types.InCurrentDomain()
    .That()
    .ResideInNamespace("NetArchTest.SampleLibrary.Presentation")
    .ShouldNot()
    .HaveDependencyOn("NetArchTest.SampleLibrary.Data")
    .GetResult()
    .IsSuccessful;
```

테스트 용이성에 대한 논의에서 드러났듯, 모든 지표나 측정에는 개발자가 시스템을 악용하려 할 위험이 존재합니다. 개발자가 아키텍트가 준수 여부를 어떻게 측정하는지 알게 되면, 옳은 일을 하기보다 지표를 만족하는 코드를 작성하려 들 수 있습니다. 예를 들어 편법을 쓰는 개발자가 단위 테스트는 작성하되 어설션을 넣지 않는 사례가 흔합니다. 코드를 "건드리긴" 했지만 제대로 동작하는지 검증하지 않은 상태에서 코드 커버리지 지표를 속이는 것이죠. ArchUnit 같은 도구로 거버넌스 코드를 작성하면 모든 단위 테스트에 적어도 하나의 어설션이 포함되도록 강제해 이런 행동을 예방할 수 있습니다. 물론 고의로 규칙을 어기려는 사람이라면 어떻게든 빠져나갈 방법을 찾겠지만, 이러한 피트니스 함수는 적어도 우발적 실수는 막아 줍니다.

피트니스 함수의 또 다른 사례는 Netflix의 "Chaos Monkey"와 그에 관련된 [Simian Army](https://oreil.ly/GipHq)입니다. Netflix가 운영을 Amazon Cloud로 이전하기로 결정했을 때, 아키텍트는 더 이상 운영을 통제할 수 없게 되어 우려했습니다. "운영에서 장애가 발생하면 어떻게 되는가?"라는 질문이 생긴 것이죠. 이 문제를 해결하기 위해 그들은 *혼돈 공학(Chaos Engineering)*이라는 학문을 만들어냈습니다. Chaos Monkey는 본질적으로 운영 환경에서의 피트니스 함수로, 시스템이 어느 정도의 혼돈을 견딜 수 있는지 보기 위해 일반적인 혼란 상황을 시뮬레이션합니다. 일부 AWS 인스턴스에서는 지연(latency)이 문제였기 때문에 Chaos Monkey는 높은 지연을 시뮬레이션했습니다(이 문제가 워낙 심각해 결국 Latency Monkey라는 별도 도구까지 만들었습니다). 이후 Amazon 데이터센터 하나가 통째로 종료되는 상황을 시뮬레이션하는 Chaos Kong 등 추가 도구가 등장했고, 이를 통해 Netflix는 실제로 그런 장애가 발생했을 때 피해를 방지할 수 있었습니다.

특히 *Conformity*, *Security*, *Janitor* "Monkey"(피트니스 함수)는 자동화된 통제 접근 방식을 잘 보여 줍니다. Conformity Monkey를 사용하면 Netflix 아키텍트가 운영 환경에서 준수해야 할 거버넌스 규칙을 정의하고 이를 시행할 수 있습니다. 예를 들어 모든 서비스가 모든 요청에 오류 없이 응답해야 한다고 결정하면, 그 검사를 Conformity Monkey에 추가합니다. Security Monkey는 열려 있어서는 안 되는 포트나 구성 오류처럼 알려진 보안 취약점을 찾아냅니다.

마지막으로 Janitor Monkey는 다른 서비스에서 더 이상 참조하지 않는 인스턴스를 찾아냅니다. Netflix의 아키텍처는 진화적 성격을 갖고 있어, 개발자가 정기적으로 새로운 서비스로 마이그레이션하고 기존 서비스를 고립된 상태로 남겨 두곤 합니다. 클라우드에서 서비스를 운영하려면 비용이 든다는 점을 고려하면, Janitor Monkey는 이렇게 고아가 된 서비스를 찾아내 운영 환경에서 제거합니다.

혼돈 공학은 아키텍처를 바라보는 흥미로운 시각을 제공합니다. 어떤 것이 *언젠가* 고장날지 여부가 아니라, *언제* 고장날지에 집중합니다. 이러한 중단을 예측하고 테스트해 [문제가 되기 전에 막으면](https://www.oreilly.com/library/view/chaos-engineering/9781492043850) 시스템은 훨씬 더 탄탄해집니다. Netflix 혁신가 중 일부인 Casey Rosenthal과 Nora Jones가 쓴 *Chaos Engineering*(O'Reilly, 2020)은 이 접근법을 자세히 다룹니다.

Atul Gawande의 영향력 있는 저서 *The Checklist [Manifesto](https://oreil.ly/XNcV9)* (Metropolitan, 2009)는 조종사나 외과의처럼 전문직 종사자가 체크리스트를 어떻게 사용하는지(때로는 법적으로 의무화되어 있기도 합니다)를 설명합니다. 이는 이들이 직무를 몰라서도, 건망증이 있어서도 아닙니다. 오히려 복잡한 업무를 반복 수행하다 보면 누구나 세부 사항을 잊기 쉽기 때문에, 간결한 체크리스트가 효과적인 기억 보조 역할을 하게 됩니다.

피트니스 함수를 바라볼 때도 같은 관점이 필요합니다. 피트니스 함수는 무거운 거버넌스 메커니즘이 아니라, 아키텍트가 중요한 아키텍처 원칙을 표현하고 자동으로 검증할 수 있게 해 주는 수단입니다. 개발자는 보안이 취약한 코드를 배포하면 안 된다는 사실을 알고 있지만, 실제로는 수십, 수백 가지 우선순위가 서로 경쟁합니다. Security Monkey 같은 도구와 피트니스 함수 전반은 아키텍트가 중요한 거버넌스 검증을 아키텍처의 기반에 녹여 넣을 수 있도록 도와줍니다.
