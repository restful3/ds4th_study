# 서비스 기반 아키텍처

## 요약

**서비스 기반 아키텍처 (Service-Based Architecture)** 는 마이크로서비스 아키텍처 스타일의 **하이브리드 변형** 으로, **유연성** 과 **실용성** 덕분에 가장 현실적인 아키텍처 스타일 중 하나로 평가받습니다. 이 아키텍처는 **분산형 구조** 를 가지면서도 마이크로서비스나 이벤트 기반 아키텍처와 같은 다른 분산 아키텍처에 비해 **복잡성** 과 **비용** 이 낮아, 특히 비즈니스 관련 애플리케이션에서 널리 채택됩니다.

핵심적인 특징은 시스템을 특정 비즈니스 도메인이나 하위 도메인을 대표하는 **독립적으로 배포 가능한 '도메인 서비스'** 들로 분할하고, 선택적으로 **모놀리식 데이터베이스** 를 공유하는 구조에 있습니다. 각 도메인 서비스는 비교적 규모가 큰 **조대(coarse-grained)** 기능 단위를 포함하며, 이로 인해 기존의 **ACID 트랜잭션** 을 활용하여 **데이터 무결성** 을 강력하게 보장할 수 있습니다.

서비스 기반 아키텍처는 높은 수준의 **모듈성**, **유지보수성**, **배포 용이성**을 제공하면서도, 마이크로서비스의 극단적인 세분성에서 오는 복잡성은 피할 수 있습니다. 이러한 특성 덕분에 마이크로서비스 아키텍처로 완전히 전환하기 전, 시스템의 어떤 부분을 미세 서비스로 만들지 분석하고 결정하는 **'디딤돌(stepping stone)' 아키텍처**로서 매우 효과적인 선택지가 될 수 있습니다.

![서비스 기반 아키텍처 개요](unnamed.png)


--------------------------------------------------------------------------------


## 1. 아키텍처 개요 및 토폴로지

서비스 기반 아키텍처는 **분산형 매크로 계층 구조**를 따릅니다. 기본적인 토폴로지는 개별적으로 배포된 **사용자 인터페이스(UI)**, 원격으로 호출되는 **조대(coarse-grained) 서비스**들, 그리고 선택적으로 사용되는 하나의 **모놀리식 데이터베이스**로 구성됩니다.

 그림 1: 서비스 기반 아키텍처의 기본 토폴로지

### 1.1. 도메인 서비스

이 아키텍처 스타일의 서비스는 일반적으로 시스템의 특정 도메인 또는 하위 도메인을 나타내므로 **'도메인 서비스'** 라고 불립니다.

* **세분성**: 도메인 서비스는 '주문 처리'나 '주문 배송'과 같이 시스템 기능의 일부를 대표하는 **조대(coarse-grained)** 단위입니다.
* **독립성 및 배포**: 각 서비스는 서로 독립적이며 별도로 배포됩니다. 일반적으로 **컨테이너화(Docker, Kubernetes)** 가 필수는 아니며, 기존 모놀리식 애플리케이션처럼 배포될 수 있습니다.
* **서비스 수**: 단일 모놀리식 데이터베이스를 사용할 경우, 변경 제어, 확장성, 내결함성 문제를 피하기 위해 도메인 서비스의 수를 **12개 이하** 로 최소화하는 것이 권장됩니다.
* **확장성**: 시스템의 확장성, 내결함성, 처리량 요구사항에 따라 단일 도메인 서비스의 여러 인스턴스를 생성할 수 있으며, 이 경우 UI와 도메인 서비스 간의 **로드 밸런싱**이 필요합니다.

### 1.2. 원격 접근 및 데이터베이스

* **원격 접근**: UI는 일반적으로 **REST** 와 같은 원격 접근 프로토콜을 통해 서비스에 접근합니다. UI에 내장된 **서비스 로케이터 패턴** 을 통해 서비스에 직접 접근하거나, **API 게이트웨이** 또는 **프록시** 를 통해 접근할 수 있습니다.
* **데이터베이스**: 중앙에서 공유되는 **모놀리식 데이터베이스**를 사용하는 것이 일반적입니다. 이를 통해 서비스들은 기존 모놀리식 계층형 아키텍처에서처럼 SQL 쿼리와 조인을 활용할 수 있습니다. 서비스 수가 적기 때문에 **데이터베이스 연결 고갈 문제**는 거의 발생하지 않습니다.


--------------------------------------------------------------------------------


## 2. 서비스 설계 및 세분성

도메인 서비스는 **조대**하기 때문에 그 자체로 하나의 작은 애플리케이션처럼 설계될 수 있습니다.

### 2.1. 도메인 서비스 내부 설계

두 가지 인기 있는 설계 접근 방식은 다음과 같습니다.

1. **계층형 설계 (기술적 분할)**: **API 파사드 계층**, **비즈니스 로직 계층**, **영속성 계층** 으로 구성됩니다.
2. **도메인 설계 (도메인 분할)**: 모듈형 모놀리스 아키텍처와 유사하게, 각 도메인 서비스를 하위 도메인으로 나눕니다.

 그림 2: 도메인 서비스의 설계 변형

어떤 설계를 사용하든, 도메인 서비스는 UI가 비즈니스 기능을 실행하기 위해 상호작용하는 **API 접근 파사드**를 포함해야 합니다. 이 파사드는 UI로부터 들어온 **비즈니스 요청을 오케스트레이션**하는 책임을 집니다.

### 2.2. 세분성 비교: 서비스 기반 vs. 마이크로서비스

**세분성**의 차이는 두 아키텍처 스타일 간의 중요한 차이점을 만듭니다.

특징	서비스 기반 아키텍처	마이크로서비스 아키텍처
세분성	조대(Coarse-grained)	미세(Fine-grained), 단일 목적
오케스트레이션	서비스 내부의 클래스 수준에서 오케스트레이션 (예: OrderService가 주문, 결제, 재고 업데이트 모두 처리)	분산된 여러 서비스를 외부에서 오케스트레이션 (예: OrderPlacement 서비스가 PaymentService 호출)
트랜잭션	ACID (원자성, 일관성, 고립성, 지속성) 트랜잭션. 표준 데이터베이스 커밋 및 롤백으로 데이터 무결성 보장.	BASE (기본 가용성, 소프트 상태, 최종 일관성) 트랜잭션. 데이터 불일치 발생 시 '보상 업데이트'를 통해 일관성 복구.
변경 영향	기능 변경 시 관련 기능이 포함된 전체 서비스를 테스트하고 재배포해야 함 (예: 주문 로직 변경 시 결제 기능도 함께 테스트/배포).	변경된 기능에 해당하는 소규모 서비스만 테스트하고 재배포하면 됨.


--------------------------------------------------------------------------------


## 3. 아키텍처 유연성 및 변형

서비스 기반 아키텍처는 **UI**, **API 계층**, **데이터베이스 토폴로지** 측면에서 높은 **유연성** 을 제공합니다.

* **UI 옵션**: 단일 모놀리식 UI에서부터 각 도메인 서비스에 맞춰진 개별 UI까지 다양하게 구성할 수 있습니다. UI를 분리하면 시스템의 **확장성**, **내결함성**, **민첩성**이 향상됩니다.  그림 3: 서비스 기반 아키텍처의 세 가지 UI 변형
* **API 게이트웨이 옵션**: UI와 서비스 사이에 **API 계층(리버스 프록시 또는 API 게이트웨이)** 을 추가할 수 있습니다. 이는 외부 시스템에 기능을 노출하거나, 보안, 메트릭, **서비스 디스커버리** 같은 공통 관심사를 통합하거나, 다중 인스턴스를 가진 서비스의 **부하를 분산** 하는 데 유용합니다.  그림 4: UI와 도메인 서비스 사이에 API 계층 추가
* **데이터 토폴로지 옵션**: **모놀리식 데이터베이스**를 효과적으로 지원하는 유일한 분산 아키텍처이지만, 데이터베이스를 여러 개로 분할하여 각 서비스마다 전용 데이터베이스를 가질 수도 있습니다. 이 아키텍처 스타일에서는 **서비스 간 통신**을 하기보다는 **데이터베이스 수준에서 데이터를 공유**하는 것이 일반적으로 더 나은 접근 방식입니다.  그림 5: 서비스 기반 아키텍처의 데이터베이스 토폴로지


--------------------------------------------------------------------------------


## 4. 데이터베이스 변경 관리

**모놀리식 데이터베이스**를 지원하지만, **스키마 변경 관리**는 매우 중요하고 어려운 과제입니다.

* **안티패턴: 단일 공유 라이브러리** 데이터베이스 테이블 스키마를 나타내는 **엔티티 객체** 들을 모두 포함하는 **단일 공유 라이브러리(예: JAR, DLL)** 를 사용하는 것은 **안티패턴** 입니다. 이 경우, 하나의 테이블 구조만 변경되어도 해당 라이브러리를 사용하는 모든 서비스를 수정하고 재배포해야 합니다.  그림 6: 단일 공유 라이브러리 사용은 안티패턴으로 간주됨
* **모범 사례: 논리적 파티셔닝과 다중 라이브러리** 데이터베이스 변경의 영향과 위험을 줄이는 효과적인 방법은 데이터베이스를 도메인별로 **논리적으로 분할** 하고, 각 논리적 파티션에 해당하는 별도의 **공유 라이브러리** 를 만드는 것입니다. 이렇게 하면 특정 도메인의 테이블 변경은 해당 라이브러리를 사용하는 서비스에만 영향을 미치므로, 다른 서비스들은 다시 테스트하거나 재배포할 필요가 없습니다.  그림 7: 다중 공유 라이브러리를 사용한 데이터베이스 변경 관리


--------------------------------------------------------------------------------


## 5. 주요 고려사항 및 거버넌스

### 5.1. 공통된 위험

* **과도한 서비스 간 통신**: 도메인 서비스 간의 통신이 많아지는 것은 **도메인이 잘못 분할** 되었거나, 해당 문제에 이 아키텍처 스타일이 적합하지 않다는 신호일 수 있습니다. 이상적으로 **결합은 데이터베이스 수준에서만** 이루어져야 합니다.
* **너무 많은 도메인 서비스**: 실용적인 한계는 약 **12개** 입니다. 이보다 많아지면 테스트, 배포, 모니터링, **데이터베이스 연결** 및 **변경 관리** 에서 문제가 발생할 수 있습니다.

### 5.2. 거버넌스

* **변경 영향 범위**: 아키텍트는 변경 사항이 여러 도메인 서비스에 걸쳐 확산되지 않도록 보장해야 합니다.
* **서비스 간 통신 제한**: 대부분의 경우 도메인 서비스는 **독립적**이어야 하며, **오케스트레이션**은 UI나 API 게이트웨이 수준에서 이루어져야 합니다.

### 5.3. 팀 토폴로지

서비스 기반 아키텍처는 **도메인별로 분할** 되므로, 팀 또한 **도메인 영역에 맞춰 구성** 될 때(예: 특정 기능에 특화된 **교차 기능 팀**)가장 효과적으로 작동합니다. 반면, **UI팀**, **백엔드팀**, **데이터베이스팀** 과 같이 기술적으로 분할된 팀 구조와는 잘 맞지 않습니다.


--------------------------------------------------------------------------------


## 6. 아키텍처 특성 평가

서비스 기반 아키텍처의 특성을 **1~5점 척도**로 평가한 결과는 다음과 같습니다.

특성	분류	별점 평가	설명
전체 비용	-		다른 분산 아키텍처에 비해 상대적으로 저렴함
파티셔닝 유형	구조적	Domain	기술이 아닌 비즈니스 도메인을 기준으로 시스템을 분할함
퀀텀 수	구조적	1 to many	공유 자원(DB, UI) 유무에 따라 단일 또는 다중 퀀텀 구성 가능
단순성	구조적	★★★★☆	구현하기 가장 간단한 분산 아키텍처 중 하나
모듈성	구조적	★★★★☆	도메인별로 서비스가 분리되어 모듈성이 높음
유지보수성	엔지니어링	★★★★★	도메인 범위가 명확하여 유지보수가 용이함
테스트 용이성	엔지니어링	★★★★★	모듈성을 기반으로 테스트 커버리지를 높이기 쉬움
배포 용이성	엔지니어링	★★★★★	모놀리스보다 위험이 적고 빈번한 배포가 가능함
발전 가능성	엔지니어링	★★★★★	민첩성, 테스트 용이성, 배포 용이성으로 시장 출시 시간 단축
응답성	운영	★★★★☆	서비스가 독립적으로 작동하여 높은 응답성 유지
내결함성	운영	★★★★☆	서비스가 독립적이므로 한 서비스의 장애가 다른 서비스에 영향을 미치지 않음
확장성	운영	★★★☆☆	서비스가 조대하여 미세 서비스보다 확장 효율성이 낮음
탄력성	운영	★★☆☆☆	확장 시 더 많은 기능이 복제되어 비용 효율성이 떨어짐


--------------------------------------------------------------------------------


## 7. 강점 및 활용 사례

### 7.1. 주요 강점

* **실용성**: 다른 분산 아키텍처에 비해 낮은 비용과 복잡성으로 높은 수준의 **확장성**, **민첩성**, **내결함성**, **가용성**을 제공합니다. "페라리를 사서 출퇴근 정체 시간에만 운전하는" 것과 같은 과도한 성능 낭비를 피할 수 있습니다.
* **도메인 주도 설계(DDD) 적합성**: 서비스가 조대하고 도메인에 특화되어 있어 **DDD** 와 잘 부합합니다.
* **ACID 트랜잭션 지원**: 서비스가 조대하여 트랜잭션 범위가 특정 도메인 서비스로 한정되므로, 다른 분산 아키텍처보다 **ACID 트랜잭션** 을 더 잘 활용하여 **데이터 무결성** 을 보장합니다.
* **마이크로서비스로의 디딤돌**: 이 아키텍처는 복잡한 세분성이나 서비스 조정 문제 없이 높은 **모듈성**을 달성하고자 할 때 훌륭한 선택입니다. 특히 **마이크로서비스로 전환하기 전 단계**로 유용합니다.

"애플리케이션의 모든 부분이 마이크로서비스로 구성될 필요는 없다." — Mark Richards

### 7.2. 활용 사례: "Going Green" 전자제품 재활용 애플리케이션

**"Going Green"** 은 낡은 전자기기를 재활용하는 시스템으로, 서비스 기반 아키텍처를 통해 구현되었습니다.

* **도메인 서비스**: 견적(Quoting), 입고(Receiving), 평가(Assessment), 결제(Accounting), 상태 조회(Item Status), 재활용(Recycling), 보고(Reporting) 등 각 도메인 영역이 별도의 독립적인 **도메인 서비스**로 구현됩니다.
* **아키텍처 퀀텀 분리**: 시스템은 **외부 고객 대면 부분**과 **내부 운영 부분**으로 나뉘어 각각 별도의 UI와 데이터베이스를 가집니다. 이를 통해 **네트워크 영역을 분리**하여 보안을 강화하고, 별도의 **아키텍처 퀀텀**을 구성합니다.
* **선택적 확장**: 고객 트래픽이 많은 **Quoting** 및 **ItemStatus** 서비스만 여러 인스턴스로 확장하고, 다른 내부 운영 서비스는 단일 인스턴스로 유지하여 **자원 효율성** 을 높입니다.

 그림 8: "Going Green" 애플리케이션 아키텍처

이처럼 서비스 기반 아키텍처는 비즈니스 요구사항에 맞춰 유연하게 구조를 조정하면서도, 분산 시스템의 주요 이점을 합리적인 비용으로 얻을 수 있는 강력하고 실용적인 스타일입니다.
