---
lang: ko
format:
  html:
    toc: true
    embed-resources: true
    theme: cosmo
---

# 14장. 서비스 기반 아키텍처 스타일 (Kapitel 14. Stil der servicebasierten Architektur)

이 작업은 AI를 활용하여 번역되었습니다. 피드백과 의견을 환영합니다: [translation-feedback@oreilly.com](mailto:translation-feedback@oreilly.com)

서비스 기반 아키텍처(service-based architecture)는 마이크로서비스 아키텍처 스타일의 하이브리드 변형으로, 특히 유연성 때문에 가장 실용적인 스타일 중 하나로 간주됩니다. 서비스 기반 아키텍처는 분산 아키텍처이지만, 다른 분산 아키텍처(예: 마이크로서비스나 이벤트 기반 아키텍처)만큼 복잡하거나 비용이 많이 들지 않아 비즈니스 관련 애플리케이션에서 인기 있는 선택입니다.

## 토폴로지 (Topologie)

서비스 기반 아키텍처의 기본 토폴로지는 분산 매크로 계층 구조(distributed macro layered structure)를 따르며, 별도로 배포되는 사용자 인터페이스, 별도로 배포되는 원격의 조대한 입도(coarse-grained)의 서비스들, 그리고 선택적으로 모놀리식 데이터베이스로 구성됩니다.

그림 14-1이 이 스타일의 *기본* 토폴로지를 보여주지만, 별도의 사용자 인터페이스와 별도의 데이터베이스 사용을 포함하여 크게 달라질 수 있습니다. 이 장에서는 이러한 토폴로지 변형들을 자세히 설명합니다.

이 아키텍처 스타일의 서비스들은 일반적으로 시스템의 특정 도메인 또는 하위 도메인을 나타내며, 따라서 *도메인 서비스(domain services)*라고 불립니다. 도메인 서비스는 일반적으로 조대한 입도이며 시스템 기능의 일부를 나타냅니다(예: 주문 처리 또는 주문 배송). 일반적으로 서로 독립적이며 별도로 배포됩니다. 다른 모놀리식 애플리케이션처럼 배포되며 반드시 컨테이너에 구현될 필요는 없습니다(Docker나 Kubernetes와 같은 컨테이너에 도메인 서비스를 배포하는 것도 선택 사항입니다). 단일 모놀리식 데이터베이스를 사용할 때, 아키텍트는 변경 제어, 확장성, 장애 허용(fault tolerance) 문제를 피하기 위해 도메인 서비스의 수를 최소화해야 합니다(12개 이하를 권장합니다).

![](_page_2_Picture_0.jpeg)

그림 14-1. 서비스 기반 아키텍처 스타일의 기본 토폴로지

일반적으로 각 도메인 서비스는 단일 인스턴스로 배포됩니다. 그러나 시스템의 확장성, 장애 허용 및 처리량 요구 사항에 따라 아키텍트는 때때로 도메인 서비스의 여러 인스턴스를 생성합니다. 이를 위해서는 일반적으로 사용자 인터페이스와 도메인 서비스 사이에 어떤 형태의 부하 분산이 필요하며, 이를 통해 사용자 인터페이스가 정상적이고 사용 가능한 서비스 인스턴스로 라우팅될 수 있습니다.

서비스에 대한 원격 액세스는 사용자 인터페이스에서 원격 액세스 프로토콜을 통해 이루어지며, 일반적으로 REST입니다. 다른 옵션으로는 메시징, 원격 프로시저 호출(Remote Procedure Call, RPC), 프록시 또는 게이트웨이가 있는 API 계층, 또는 SOAP도 있습니다. 대부분의 경우 사용자 인터페이스에는 서비스 로케이터 패턴(service locator pattern)이 내장되어 있어 서비스에 직접 액세스할 수 있습니다. 서비스 로케이터 패턴은 API 게이트웨이나 프록시에 내장될 수도 있습니다.

서비스 기반 아키텍처는 일반적으로 중앙에서 공유하는 모놀리식 데이터베이스를 사용합니다. 이를 통해 서비스들은 전통적인 모놀리식 계층 아키텍처에서처럼 SQL 쿼리와 조인을 활용할 수 있습니다. 이 아키텍처에서 일반적으로 발생하는 적은 수의 서비스로 인해, 사용 가능한 데이터베이스 연결의 고갈은 드물게 문제가 됩니다. 그러나 데이터베이스 변경 관리는 도전 과제가 될 수 있습니다. "데이터 토폴로지" 섹션에서는 서비스 기반 아키텍처에서 데이터베이스 변경을 고려하고 관리할 수 있는 기술을 설명합니다.

### 스타일 세부 사항 (Stil Besonderheiten)

서비스 기반 아키텍처의 도메인 서비스는 일반적으로 조대한 입도이므로, 각 도메인 서비스는 일반적으로 API 파사드 계층(API facade layer), 비즈니스 계층, 지속성 계층으로 구성된 다층 아키텍처 스타일로 설계됩니다. 다른 인기 있는 설계 접근 방식은 모듈식 모놀리식 아키텍처 스타일(11장 참조)과 유사하게 각 도메인 서비스를 하위 도메인으로 나누는 것입니다. 두 접근 방식 모두 그림 14-2에 나와 있습니다.

![](_page_5_Picture_0.jpeg)

계층형 설계 (기술적 분할, Layered design - technical partitioning)

도메인 설계 (도메인 분할, Domain design - domain partitioning)

![](_page_5_Figure_3.jpeg)

설계에 관계없이, 도메인 서비스는 사용자 인터페이스가 상호 작용하여 어떤 형태의 비즈니스 기능을 실행하는 일종의 API 액세스 파사드를 포함해야 합니다. API 액세스 파사드는 일반적으로 사용자 인터페이스로부터의 비즈니스 요청을 오케스트레이션하는 책임을 맡습니다.

전자상거래 웹사이트에서 서비스 기반 아키텍처를 사용하는 예를 고려해 보겠습니다. 비즈니스 요청이 사용자 인터페이스에서 들어옵니다: 고객이 일부 항목을 주문합니다. 이 단일 요청은 OrderService 도메인 서비스 내의 API 액세스 파사드에서 수신됩니다. API 액세스 파사드는 이 요청을 충족하는 데 필요한 모든 것을 내부적으로 제어합니다: 주문, 주문 ID 생성, 결제, 주문된 각 제품의 재고 업데이트. 마이크로서비스 아키텍처에서는 이 요청을 실행하는 데 많은 별도로 배포된 분산 단일 목적 서비스의 오케스트레이션이 필요할 것입니다. 서비스 기반 아키텍처의 클래스 수준에서의 내부 오케스트레이션과 마이크로서비스 아키텍처의 외부 서비스 오케스트레이션 간의 입도 차이는 두 스타일 간의 많은 중요한 차이점 중 하나를 나타냅니다.

도메인 서비스가 조대한 입도이므로, 정규 ACID 데이터베이스 트랜잭션(원자성, 일관성, 격리, 내구성, Atomicity, Consistency, Isolation, Durability)은 표준 데이터베이스 커밋과 롤백으로 단일 도메인 서비스 내에서 데이터베이스 무결성을 보장할 수 있습니다. 이와 대조적으로, 마이크로서비스와 같은 고도로 분산된 아키텍처의 세밀한 입도의 단일 목적 서비스는 BASE 트랜잭션(Basic Availability, Soft State, Eventual Consistency)으로 알려진 분산 트랜잭션 기술을 사용합니다. 이러한 세밀한 입도의 서비스는 서비스 기반 아키텍처의 ACID 트랜잭션이 지원할 수 있는 것과 동일한 수준의 데이터베이스 무결성을 지원하지 않습니다.

이 점을 명확히 하기 위해, 서비스 기반 전자상거래 웹사이트의 주문 프로세스를 고려해 봅시다. 고객이 주문을 하지만 결제에 사용한 신용카드가 만료되었다고 가정합니다. 이 결제는 동일한 서비스 내의 원자적 트랜잭션이므로, 서비스는 표준 트랜잭션 롤백으로 데이터베이스에 지금까지 추가된 모든 것을 삭제할 수 있습니다. 서비스는 고객에게 결제를 수행할 수 없다고 알립니다.

이제 더 작고 세밀한 입도의 서비스가 있는 마이크로서비스 아키텍처에서 동일한 프로세스를 고려해 봅시다. 먼저 OrderPlacement 서비스가 요청을 받아들이고, 주문을 생성하고, 주문 ID를 생성하고, 주문을 주문 테이블에 삽입합니다. 그런 다음 OrderPlacement 서비스는 PaymentService 서비스를 호출하여 결제를 시도합니다. 신용카드가 만료되어 결제를 수행할 수 없으면 주문을 할 수 없습니다. 이제 데이터가 불일치 상태에 있습니다: 주문 정보는 이미 입력되었지만 아직 승인되지 않았습니다. 데이터를 일관된 상태로 만들려면 OrderPlacement 서비스에 *보상 업데이트(compensating update)*(9장 참조)라고 하는 별도의 작업을 적용해야 합니다.

### 서비스 설계와 입도 (Dienstgestaltung und Granularität)

도메인 서비스가 조대한 입도이므로 더 나은 데이터 무결성과 일관성을 허용하지만, 큰 트레이드오프가 있습니다. 서비스 기반 아키텍처에서 주문 기능을 변경해야 한다면, 팀은 결제 처리를 포함한 서비스의 전체 기능을 테스트하고 재배포해야 합니다. 마이크로서비스 아키텍처에서는 동일한 변경이 더 작고 세밀한 입도의 OrderPlacement 서비스에만 영향을 미치므로 PaymentService에 대한 테스트와 배포가 필요하지 않습니다. 또한 도메인 서비스가 더 많은 기능을 제공하므로 다른 것이 손상될 위험이 더 큽니다(결제 처리 포함). 마이크로서비스에서는 각 서비스가 단일 기능만 담당하므로 변경 시 다른 기능이 손상될 위험이 적습니다.

### 사용자 인터페이스 옵션 (Optionen der Benutzeroberfläche)

서비스 기반 아키텍처 스타일은 많은 UI 변형을 포함하여 매우 유연합니다. 예를 들어, 아키텍트는 그림 14-1에 표시된 모놀리식 사용자 인터페이스를 개별 사용자 인터페이스로 분할할 수 있으며, 각 도메인 서비스에 맞춰 조정할 수 있습니다. 이는 시스템 전체의 확장성, 장애 허용, 민첩성을 향상시킬 것입니다. 이러한 UI 변형은 그림 14-3에 나와 있습니다.

![](_page_10_Figure_0.jpeg)

예를 들어, 일반적인 주문 시스템은 고객이 주문을 하기 위한 사용자 인터페이스와 주문 포장자가 포장할 항목을 보기 위한 별도의 내부 사용자 인터페이스, 그리고 고객 지원을 위한 인터페이스를 가질 수 있습니다.

### API 게이트웨이 옵션 (API Gateway Optionen)

이 아키텍처 스타일의 유연성 덕분에 그림 14-4에 표시된 것처럼 사용자 인터페이스와 서비스 사이에 역방향 프록시(reverse proxy) 또는 API 게이트웨이로 구성된 API 계층을 삽입할 수 있습니다. 이는 외부 시스템에 도메인 서비스의 기능을 액세스 가능하게 하고, 공통 횡단 관심사(예: 메트릭, 보안, 감사 요구 사항, 서비스 디스커버리)를 통합하여 API 게이트웨이로 이동하고, 여러 인스턴스를 가진 도메인 서비스의 부하를 분산하는 데 유용합니다.

![](_page_12_Picture_0.jpeg)

## 데이터 토폴로지 (Daten-Topologien)

서비스 기반 아키텍처는 아키텍트에게 많은 데이터베이스 토폴로지 옵션을 제공하여 유연성을 강조합니다. 이 유형의 아키텍처는 모놀리식 데이터베이스를 효과적으로 지원할 수 있는 분산 아키텍처라는 점에서 독특합니다. 그러나 이 모놀리식 데이터베이스는 여러 데이터베이스로 분할될 수 있으며, 각 서비스에 대한 도메인별 데이터베이스를 생성하는 것까지 가능합니다(마이크로서비스와 유사). 여러 개의 별도 데이터베이스를 사용할 때, 아키텍트는 다른 도메인 서비스가 각 데이터베이스의 데이터를 필요로 하지 않는지 확인해야 하며, 이는 도메인 서비스 간 통신으로 이어질 수 있습니다. 일반적으로 이 아키텍처 스타일에서는 다른 도메인 서비스를 호출하는 것보다 데이터를 공유하는 것이 더 좋습니다. 이러한 데이터베이스 변형은 그림 14-5에 나와 있습니다.

![](_page_14_Figure_0.jpeg)

![](_page_14_Figure_1.jpeg)

![](_page_14_Figure_2.jpeg)

이 아키텍처 스타일이 모놀리식 데이터베이스를 지원하지만, 데이터베이스 테이블의 스키마 변경이 제대로 수행되지 않으면 모든 도메인 서비스에 영향을 미칠 수 있습니다. 이는 데이터베이스 변경을 매우 비용이 많이 들고 위험한 작업으로 만들어 높은 노력, 조정 및 전반적인 신뢰성이 필요합니다.

서비스 기반 아키텍처에서 데이터베이스 테이블의 스키마를 나타내는 공유 클래스 파일(소위 *엔티티 객체(entity objects)*)은 일반적으로 모든 도메인 서비스에서 사용되는 사용자 정의 공유 라이브러리에 있습니다(예: JAR 또는 DLL 파일). 이러한 공유 라이브러리는 SQL 코드도 포함할 수 있습니다. 모든 엔티티 객체에 대한 단일 공유 라이브러리를 생성하는 것은 서비스 기반 아키텍처를 구현하는 *가장 효과적이지 않은* 방법입니다. 데이터베이스 테이블 구조가 변경될 때마다 해당 엔티티 객체 라이브러리도 변경되어야 하며, 이는 실제로 변경된 테이블에 액세스하는지 여부와 관계없이 *모든* 서비스가 변경되고 재배포되어야 함을 의미합니다. 공유 라이브러리 버전 관리가 이 문제를 해결할 수 있지만, 상세한 수동 분석을 수행하지 않고는 어떤 서비스가 테이블 변경의 영향을 받는지 알기 어렵습니다. 서비스 기반 아키텍처에서 안티패턴으로 간주되는 이 시나리오는 그림 14-6에 나와 있습니다.

![](_page_16_Figure_0.jpeg)

그림 14-6. 데이터베이스 엔티티 객체에 대한 단일 공유 라이브러리 사용은 변경 시 모든 서비스에 영향을 미치며 서비스 기반 아키텍처에서 안티패턴으로 간주됩니다

데이터베이스 변경의 영향과 위험을 줄이는 한 가지 방법은 데이터베이스를 논리적으로 분할하고 이러한 논리적 분할을 별도의 공유 라이브러리를 통해 나타내는 것입니다. 그림 14-7에서 데이터베이스는 논리적으로 5개의 별도 도메인으로 나뉩니다: 일반(General), 고객(Customer), 청구(Billing), 주문(Order), 추적(Tracking). 도메인 서비스는 데이터베이스의 논리적 분할에 해당하는 5개의 해당 공유 라이브러리를 사용합니다. 이 기술을 사용하면 아키텍트가 특정 논리적 도메인(이 경우 Invoicing) 내의 테이블에 대한 모든 변경 사항이 엔티티 객체(그리고 아마도 SQL)를 포함하는 해당 공유 라이브러리와 일치합니다. 영향을 받는 유일한 서비스는 이 공유 라이브러리를 사용하는 서비스입니다. 다른 서비스는 이 변경의 영향을 받지 않으므로 재테스트 및 재배포가 필요하지 않습니다.

![](_page_18_Picture_0.jpeg)

그림 14-7에서 데이터베이스는 Common Domain과 모든 서비스에서 사용되는 해당 common_entities_lib 공유 라이브러리를 포함합니다. 이는 비교적 일반적입니다. 이러한 테이블은 모든 서비스에서 공유되므로 변경 사항은 공유 데이터베이스에 액세스하는 모든 서비스와 조정되어야 합니다. 이러한 테이블(및 해당 엔티티 객체와 도메인 서비스)에 대한 변경의 잠재적 부작용을 완화하는 한 가지 방법은 버전 관리에서 공유 엔티티 객체를 잠그고(사용 가능한 경우) 데이터베이스 팀만 변경할 수 있도록 하는 것입니다. 이렇게 하면 변경을 더 잘 제어할 수 있으며 모든 서비스에서 사용하는 공유 테이블을 변경하는 것이 얼마나 중요한지 명확해집니다.

#### 팁 (TIPP)

서비스 기반 아키텍처에서 데이터베이스 변경을 더 잘 제어하려면 명확하게 정의된 데이터 도메인을 포기하지 않고 데이터베이스의 논리적 분할을 가능한 한 세밀하게 만들어야 합니다.

# 클라우드 고려 사항 (Überlegungen zur Cloud)

분산 아키텍처이므로 서비스 기반 스타일은 도메인 서비스가 일반적으로 조대한 입도임에도 불구하고 클라우드 환경에서 잘 작동합니다. 큰 범위로 인해 도메인 서비스는 일반적으로 서버리스 함수가 아닌 컨테이너화된 서비스로 구현되며, 클라우드 데이터 저장소, 데이터베이스 및 메시징 서비스를 문제없이 활용할 수 있습니다.

### 일반적인 위험 (Gemeinsame Risiken)

서비스 간 통신은 마이크로서비스에서는 일반적이지만, 아키텍트는 서비스 기반 아키텍처 스타일에서는 이를 피하려고 합니다. 이상적으로는 도메인이 가능한 한 독립적이어야 하며 결합은 데이터베이스 수준에서만 발생해야 합니다. 도메인 서비스 간의 너무 많은 통신은 아키텍트가 도메인을 올바르게 분할하지 않았거나 해결할 문제에 적합한 아키텍처 스타일이 아니라는 좋은 지표입니다.

또 다른 일반적인 위험은 *너무 많은* 도메인 서비스를 설정하는 것입니다. 실용적인 상한선은 약 12개입니다. 더 많으면 테스트, 배포, 모니터링 및 데이터베이스 연결 및 변경에 문제가 발생할 수 있습니다.

### 거버넌스 (Governance)

이 책에서 논의된 일반적인 구조적 및 운영적 아키텍처 거버넌스 기술(예: 순환 복잡도, 확장성, 응답성 등) 외에도, 아키텍트는 서비스 기반 아키텍처의 구조적 무결성을 보장하기 위해 특수 거버넌스 테스트를 적용할 수 있습니다.

도메인 서비스는 가능한 한 독립적이어야 하므로, 먼저 변경 사항이 여러 도메인 서비스에 걸쳐 있지 않은지 확인해야 합니다. 그렇다면 도메인 경계가 적절하게 정의되지 않았거나 서비스 기반 아키텍처가 문제에 가장 적합한 스타일이 아니라는 좋은 지표입니다.

서비스 간 통신을 사용할 수 없는 경우, 아키텍트는 도메인 서비스 간의 통신 범위도 결정할 수 있습니다. 한 도메인 서비스가 다른 도메인 서비스와 통신해야 하는 상황과 워크플로가 확실히 있습니다. 예를 들어 OrderProcessing 도메인은 고객에게 주문 상태 정보를 이메일로 보내기 위해 CustomerNotification 도메인과 통신해야 합니다. 그러나 대부분의 경우 도메인 서비스는 서로 크게 독립적이어야 하며 오케스트레이션은 사용자 인터페이스 또는 API 게이트웨이 수준에서 이루어져야 합니다.

# 팀 토폴로지 고려 사항 (Überlegungen zur Team-Topologie)

서비스 기반 아키텍처는 도메인별로 분할되므로 팀도 도메인 영역에 따라 조직될 때 가장 잘 작동합니다(예: 전문화된 기능 간 팀). 도메인 관련 요구 사항이 나타나면 도메인 관련 기능 간 팀이 다른 팀이나 서비스에 영향을 주지 않고 특정 도메인 서비스 내에서 이 기능을 함께 작업할 수 있습니다. 반대로, 기술적으로 분할된 팀(예: UI 팀, 백엔드 팀, 데이터베이스 팀 등)은 도메인 분할로 인해 이 아키텍처 스타일과 잘 작동하지 않습니다. 기술적으로 조직된 팀에 도메인 요구 사항을 할당하려면 대부분의 기업에서 어려운 수준의 팀 간 통신과 협업이 필요합니다.

"팀 토폴로지와 아키텍처"에서 설명된 특정 팀 토폴로지와 서비스 기반 아키텍처를 조정하기 위한 아키텍트의 몇 가지 고려 사항은 다음과 같습니다:

#### 스트림 중심 팀 (Auf den Strom ausgerichtete Teams)

도메인 경계가 올바르게 정렬되면 스트림 중심 팀은 이 아키텍처 스타일과 잘 작동하며, 특히 스트림이 특정 도메인에 맞춰져 있을 때 그렇습니다. 그러나 스트림이 도메인 서비스에 정의된 경계를 넘어가면 서비스 기반 아키텍처가 더 어려워집니다. 이 경우 아키텍트는 경계와 도메인 서비스의 입도를 분석하고 스트림에 다시 맞추거나 다른 아키텍처 스타일을 선택해야 합니다.

#### 활성화 팀 (Teams befähigen)

서비스 기반 아키텍처는 도메인 서비스가 매우 조대한 입도이므로 팀 토폴로지와 결합할 때 다른 분산 아키텍처만큼 효과적이지 않습니다. 그러나 아키텍트는 각 도메인 서비스에 대해 적절한 컴포넌트를 신중하게 식별하고 생성하여 이 스타일의 모듈성을 높일 수 있습니다. 그러면 전문가와 팀 간 구성원이 이러한 컴포넌트를 기반으로 제안하고 실험할 수 있습니다.

#### 복잡한 하위 시스템 팀 (Teams mit komplizierten Subsystemen)

복잡한 하위 시스템 팀은 이 아키텍처 스타일의 도메인 및 하위 도메인 수준의 모듈성을 활용하여 다른 팀 구성원(및 서비스)과 독립적으로 복잡한 도메인 또는 하위 도메인을 처리하는 데 집중할 수 있습니다.

#### 플랫폼 팀 (Plattform-Teams)

서비스 기반 아키텍처의 높은 수준의 모듈성은 공통 도구, 서비스, API 및 작업을 사용하여 플랫폼 팀 토폴로지의 이점을 활용하는 데 도움이 됩니다.

# 스타일 특성 (Stilmerkmale)

그림 14-8의 표에서 1점 평가는 특정 아키텍처 특성이 아키텍처에서 잘 지원되지 않음을 의미하며, 5점 평가는 아키텍처 특성이 아키텍처 스타일의 가장 강력한 특징 중 하나임을 의미합니다. 스코어카드의 각 특성에 대한 정의는 4장에서 찾을 수 있습니다.

|             | 아키텍처 특성 (Architectural characteristic) | 별점 (Star rating)        |
|-------------|------------------------------|---------------------------|
|             | 전체 비용 (Overall cost)                 | $$                      |
| 구조적 (Structural)  | 분할 유형 (Partitioning type)            | 도메인 (Domain)                    |
|             | 퀀텀 수 (Number of quanta)             | 1 to many                 |
|             | 단순성 (Simplicity)                   | ***                       |
|             | 모듈성 (Modularity)                   | ***                       |
| 엔지니어링 (Engineering) | 유지보수성 (Maintainability)              | ***                       |
|             | 테스트 가능성 (Testability)                  | ***                       |
|             | 배포 가능성 (Deployability)                | ***                       |
|             | 진화 가능성 (Evolvability)                 | ***                       |
| 운영 (Operational) | 응답성 (Responsiveness)               | ***                       |
|             | 확장성 (Scalability)                  | ***                       |
|             | 탄력성 (Elasticity)                   | **                        |
|             | 장애 허용 (Fault tolerance)              | ***                       |

서비스 기반 아키텍처는 *도메인 분할(domain-partitioned)* 아키텍처입니다. 즉, 구조가 기술적 고려 사항(예: 프레젠테이션 로직 또는 지속성 로직)이 아닌 도메인에 의해 결정됩니다.

7장에서 소개하고 13장에서 다시 다룬 전자 재활용 애플리케이션 Going Green의 예를 들어 보겠습니다. 이 장의 목적을 위해 Going Green이 서비스 기반 아키텍처를 사용한다고 상상해 봅시다. 각 서비스는 별도로 배포되는 소프트웨어 단위이며 특정 도메인(예: 항목 평가)으로 제한됩니다. 이 영역 내에서 수행된 변경은 이 특정 서비스와 관련 사용자 인터페이스 및 데이터베이스에만 영향을 미칩니다. 특정 평가 변경을 지원하기 위해 다른 것을 변경할 필요가 없습니다.

분산 아키텍처에서 퀀텀의 수는 1보다 크거나 같을 수 있습니다. 예를 들어 Going Green의 모든 서비스가 동일한 데이터베이스 또는 사용자 인터페이스를 사용하는 경우 전체 시스템은 단일 퀀텀일 것입니다. 그러나 "스타일 세부 사항" 섹션에서 설명한 것처럼 사용자 인터페이스와 데이터베이스 모두 연합(분할)될 수 있으며, 이는 전체 시스템 내에서 여러 퀀텀으로 이어집니다. 그림 14-9에서 Going Green 시스템은 두 개의 퀀텀을 포함합니다. 하나는 애플리케이션의 고객 대면 부분을 위한 것으로 자체 사용자 인터페이스, 데이터베이스 및 일련의 서비스(Quoting 및 Item Status)를 포함합니다. 다른 부분은 전자 기기의 수령, 평가 및 재활용의 내부 프로세스를 다룹니다. 내부 작업을 위한 퀀텀은 별도로 배포된 서비스와 두 개의 별도 사용자 인터페이스를 포함하지만, 모두 동일한 데이터베이스를 사용하므로 애플리케이션의 내부 부분을 단일 퀀텀으로 만듭니다.

![](_page_28_Figure_0.jpeg)

서비스 기반 아키텍처에 5점 평가를 주지 않았지만, 많은 중요한 영역에서 여전히 높은 평가(4점)를 받습니다. 애플리케이션을 별도의 도메인 서비스로 분할하면 더 빠른 변경(민첩성), 도메인 범위 지정을 기반으로 한 모듈성으로 인한 더 나은 테스트 커버리지(테스트 가능성), 모놀리식 아키텍처보다 더 자주 그리고 더 낮은 위험으로 애플리케이션을 배포할 수 있는 능력(배포 가능성)이 가능합니다. 이 세 가지 특성은 시장 출시 시간을 단축하고 기업이 새로운 기능을 제공하고 오류를 비교적 빠르게 수정할 수 있게 합니다.

장애 허용과 애플리케이션의 전체 가용성도 서비스 기반 아키텍처에서 높게 평가됩니다. 도메인 서비스가 다소 조대한 입도이지만, 4점 평가는 이 아키텍처 스타일의 서비스가 일반적으로 자체 포함되어 있고 코드와 데이터베이스의 공유 덕분에 일반적으로 서비스 간 통신이 발생하지 않기 때문입니다. 따라서 도메인 서비스가 실패하면(예: Going Green의 Receiving 서비스) 다른 6개 서비스에 영향을 미치지 않습니다.

확장성은 서비스의 조대한 입도 특성으로 인해 3점으로만 평가되며, 탄력성은 이에 따라 2점으로만 평가됩니다. 프로그래밍 방식의 확장성과 탄력성이 이 아키텍처 스타일로 확실히 가능하지만, 더 세밀한 입도의 서비스를 가진 아키텍처(예: 마이크로서비스)보다 더 많은 기능이 복제되어 비용 효율성이 떨어지고 기계 리소스 측면에서 덜 효율적입니다. 서비스 기반 아키텍처에서는 일반적으로 더 나은 처리량이나 장애 조치가 필요하지 않는 한 각 서비스의 단일 인스턴스만 사용됩니다. 좋은 예는 Going Green입니다(그림 14-9 참조) - Quoting 및 Item Status 서비스만 높은 고객 트래픽을 지원하기 위해 확장해야 합니다. 다른 운영 서비스는 단일 인스턴스만 필요하므로 인메모리 캐싱 및 데이터베이스 연결 풀링과 같은 것을 지원하기가 더 쉽습니다.

단순성과 전체 비용은 이 아키텍처 스타일을 마이크로서비스, 이벤트 기반 아키텍처 또는 공간 기반 아키텍처와 같은 다른 더 비싸고 복잡한 분산 아키텍처와 구별하는 두 가지 추가 요소입니다. 이는 서비스 기반 아키텍처를 구현할 수 있는 가장 간단하고 비용 효율적인 분산 아키텍처 중 하나로 만듭니다. 이것은 매력적인 제안이지만 항상 그렇듯이 트레이드오프가 있습니다. 비용과 복잡성이 높을수록 4점 특성(예: 확장성, 탄력성 및 장애 허용)이 더 좋아집니다.

유연성과 많은 3점 및 4점 아키텍처 특성의 결합은 서비스 기반 아키텍처를 존재하는 가장 실용적인 스타일 중 하나로 만듭니다. 훨씬 더 강력한 분산 아키텍처가 있지만, 많은 기업은 이러한 성능이 너무 높은 대가를 치른다고 생각합니다. 다른 기업은 단순히 그렇게 많은 성능이 *필요하지 않다*는 것을 알게 됩니다. 이는 페라리를 사서 출퇴근 교통 체증에서만 사용하는 것과 같습니다 - 물론 멋져 보이지만, 성능, 속도 및 민첩성의 낭비입니다!

서비스 기반 아키텍처는 도메인 주도 설계에도 매우 적합합니다. 서비스가 조대한 입도이고 도메인별로 특화되어 있으므로 각 도메인은 해당 특정 도메인을 포함하는 별도로 배포된 서비스에 잘 맞습니다. 기능을 단일 소프트웨어 단위로 분할하면 해당 도메인을 변경하기 쉽습니다.

데이터베이스 트랜잭션을 유지하고 조정하는 것은 일반적으로 *최종 일관성(eventual consistency)*(즉, 독립적인 데이터베이스 업데이트가 결국 서로 동기화됨)에 의존하는 분산 아키텍처에서 항상 문제이며, 전통적인 *ACID 트랜잭션(ACID transactions)*(즉, 데이터베이스 업데이트가 단일 작업 단위에서 조정되고 함께 수행됨)에 의존하지 않습니다. 서비스 기반 아키텍처는 서비스가 조대한 입도이기 때문에 다른 분산 아키텍처보다 ACID 트랜잭션을 더 잘 활용합니다. 이는 트랜잭션 범위가 특정 도메인 서비스로 고정되어 대부분의 모놀리식 애플리케이션에서 찾을 수 있는 전통적인 커밋 및 롤백 트랜잭션 기능을 가능하게 함을 의미합니다.

마지막으로, 서비스 기반 아키텍처는 입도 및 서비스 조정의 복잡성에 얽매이지 않고 높은 수준의 모듈성을 달성하려는 아키텍트에게 좋은 선택입니다(18장의 "안무와 오케스트레이션" 참조).

## 예제와 사용 사례 (Beispiele und Anwendungsfälle)

서비스 기반 아키텍처 스타일의 유연성과 성능을 설명하기 위해 오래된 전자 기기(예: iPhone 또는 Galaxy 휴대폰)를 재활용하는 시스템인 Going Green 예제를 다시 살펴보겠습니다.

Going Green의 처리 프로세스는 다음과 같이 작동합니다:

1. 고객은 Going Green에 (웹사이트나 키오스크를 통해) 오래된 전자 기기에 대해 얼마를 지불할 것인지 문의합니다(*견적, Quoting*).
2. 고객이 제안에 만족하면 기기를 재활용 회사로 보냅니다(*수령, Receiving*).
3. Going Green은 기기의 상태를 평가합니다(*평가, Assessment*).
4. 기기가 양호한 상태이면 Going Green은 고객에게 기기에 대한 대금을 지불합니다(*청구, Billing*). 이 프로세스 동안 고객은 언제든지 웹사이트에 접속하여 기기의 상태를 확인할 수 있습니다(*항목 상태, Item Status*).
5. 평가를 기반으로 Going Green은 기기를 안전하게 파기하고 부품을 재활용하거나 Facebook Marketplace 또는 eBay와 같은 제3자 판매 플랫폼에서 재판매합니다(*재활용, Recycling*).
6. Going Green은 재활용 활동에 대한 재무 및 운영 보고서를 정기적으로 생성합니다(*보고, Reporting*).

그림 14-10은 이 시스템이 서비스 기반 아키텍처로 구현되는 방법을 보여줍니다. 방금 식별한 각 도메인 영역은 별도의 독립적인 도메인 서비스로 구현됩니다. 확장되어야 하는 서비스(따라서 여러 서비스 인스턴스가 필요함)는 더 높은 처리량이 필요한 서비스입니다(이 경우 고객 대면 서비스인 Quoting 및 ItemStatus). 다른 서비스는 확장할 필요가 없으므로 단일 서비스 인스턴스만 필요합니다.

![](_page_34_Figure_0.jpeg)

이 예에서 UI 애플리케이션은 영역으로 나뉩니다: *고객 대면(Customer Facing)*, *상품 수령(Receiving)*, *재활용 및 회계(Recycling and Accounting)*. 이러한 분리는 사용자 인터페이스 수준에서 우수한 장애 허용, 우수한 확장성 및 적절한 보안을 보장합니다(외부 고객이 내부 기능에 액세스할 네트워크 경로가 없기 때문). 또한 두 개의 별도 물리적 데이터베이스가 있습니다: 하나는 외부 고객 대면 작업용이고 다른 하나는 내부 작업용입니다. 이를 통해 내부 데이터와 프로세스를 외부 프로세스와 분리된 네트워크 영역에 저장할 수 있으며(수평선으로 표시됨), 훨씬 더 나은 보안(액세스 제한 및 데이터 보호)을 제공하고 별도의 아키텍처 퀀텀을 나타냅니다. 방화벽을 통한 단방향 액세스는 내부 서비스가 고객 대면 정보에 액세스하고 업데이트할 수 있지만 그 반대는 불가능합니다. 데이터베이스에 따라 팀은 내부 테이블 미러링 및 외부 테이블 동기화를 사용하여 두 데이터베이스 간의 데이터를 동기화할 수도 있습니다.

또한 Assessment 서비스는 새로운 제품이 도착하거나 시장에 출시됨에 따라 지속적으로 변경됩니다. 서비스 기반 아키텍처를 사용하면 이러한 빈번한 변경이 단일 도메인 서비스로 제한되어 민첩성, 테스트 가능성 및 배포 가능성을 보장합니다.

서비스 기반 아키텍처는 다른 분산 아키텍처에 비해 비교적 낮은 비용으로 높은 수준의 확장성, 민첩성, 장애 허용, 가용성 및 응답성을 제공하는 매우 유연한 아키텍처 스타일입니다. 이러한 요소들이 이를 인기 있는 선택으로 만듭니다.

서비스 기반 아키텍처는 기업이 다른 분산 아키텍처 스타일로 마이그레이션하거나 처음부터 새로운 분산 시스템을 구축하는 경우에 관계없이 다른 분산 아키텍처를 위한 발판으로도 잘 적합합니다. 이것이 우리의 가장 중요한 요점으로 이어집니다:

*애플리케이션의 모든 부분이 마이크로서비스로 구성될 필요는 없습니다.*

#### —Mark Richards

서비스 기반 아키텍처로 전환하거나 목표 아키텍처 스타일로 전환하기 *전에* "발판"으로 생성하면 팀이 도메인을 분석하고 아키텍처의 어느 부분이 마이크로서비스가 *되어야* 하는지 결정할 수 있습니다. Going Green 예제에서 Recycling 및 Accounting 서비스는 더 이상 세분화될 필요가 없으며 아마도 도메인 서비스로 남아야 합니다. 그러나 Assessment 서비스는 자주 변경되고 높은 수준의 민첩성을 필요로 하므로 *이* 서비스는 각 유형의 전자 기기에 대해 하나씩 별도의 서비스로 나누어져야 합니다. Going Green 팀이 이 단계를 건너뛰고 *직접* 마이크로서비스 아키텍처로 전환한다면 반드시 마이크로서비스가 될 필요가 없더라도 *모든* 기능이 마이크로서비스로 끝날 것입니다.

이것은 서비스 기반 아키텍처가 아키텍트들 사이에서 매우 인기 있는 많은 이유 중 일부에 불과합니다. 그러나 이것은 많은 분산 아키텍처 스타일 중 하나일 뿐이며, 모두를 이해하는 것은 특정 비즈니스 문제에 대한 올바른 솔루션을 찾는 데 도움이 됩니다. 따라서 다른 분산 아키텍처를 살펴보겠습니다.
